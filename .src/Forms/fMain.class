' Gambas class file

'------------------------------------------------------------------------------

'Variables del formulario

Public currentFile As String

Public CursorX As Integer
Public CursorY As Integer

Public Xr As Float
Public Yr As Float

Public KeysAccumulator As String
Public TmrTicks As Integer

'Public SelectedWidth As Boolean

'Private PropertiesFlag As Boolean = False
Private PropertiesFlag As Boolean = True
Private RawFlag As Boolean = False

'variables de ambiente
Public flgShowInspector As Boolean = False

Public flgWheelCounter As Integer
Public InUse As Boolean                         ' variable auxiliar para evitar eventos indeseados
Public $hDrawTimer As New Timer As "DrawTimer"
Public $hSearchTimer As New Timer As "SearchTimer"

'' Printing stuff
Public MyPrinter As Printer

Public ftring As New Float[]
Public ftring2 As New Float[]
Public GLArea1 As GLArea
'Public GLPaper As GLArea

Public tabViews As TabPanel

'Public Printer1 As New Printer

Public Sub DrawTimer_Timer()

    gcd.Drawing.GLAreaInUse.Refresh
    'glarea1.Refresh

End Sub

Public Sub SearchTimer_Timer()

    gcd.Drawing.HoveredEntities = clsMouseTracking.CheckAboveEntities(xr, yr)
    If gcd.Drawing.HoveredEntities.Count > 0 Then
        gcd.Drawing.HoveredEntity = gcd.Drawing.HoveredEntities.First
    Else
        gcd.Drawing.HoveredEntity = Null
    End If

End Sub

Public Sub Run() As Boolean

    ' acomodo el tamanio de los controles
    Me.tblLineWt.w = 128
    Me.tblLTypes.w = 128
    Me.mbtColors.w = 32
    Me.cmbDimStyle.w = 128
    Me.grdLayers.w = 146
    Me.Menus.Hide
    'Me.tbnLayersOnScreen.w = 96
    Me.tabDrawings[0].Visible = False

    pnlCoords.W = pnlToolbarLeft.W
    pnlBarBottom.H = 32

    'PanelBlockFit.Visible = False 'ag = CStr(PanelBlockFit.h)
    'PanelBlockFit.h = 0

    fMain.grdLayers.Rows.Count = 1
    fMain.grdLayers.Columns.Count = 5
    'fMain.grdLayers.Rows[0].Height = 32
    fMain.grdLayers.Rows.Height = 28
    fMain.grdLayers[0, 1].Alignment = Align.Left
    fMain.grdLayers[0, 2].Alignment = Align.Left
    fMain.grdLayers[0, 3].Alignment = Align.Left
    fMain.grdLayers[0, 4].Alignment = Align.Left
    fMain.grdLayers.Columns[0].w = 18 ' color
    fMain.grdLayers.Columns[1].w = 18 ' color
    fMain.grdLayers.Columns[2].w = 18 ' color
    fMain.grdLayers.Columns[3].w = 18 ' color
    fMain.grdLayers.Columns[4].w = 72 ' color

    fLayersOnScreen.Move(Me.grdLayers.x, Me.grdLayers.y + Me.grdLayers.h + 1)

    ' ' ToolButtonList  depre
    '
    ' tblLines.AddToolButton("tbnLine",, Picture.Load("/home/martin/GambasCAD/png/line.png"), "cadLine")
    ' tblLines.AddToolButton("tbnRay",, Picture.Load("/home/martin/GambasCAD/png/ray.png"), "cadRay")
    '
    ' tblCircles.AddToolButton("tbncircle",, Picture.Load("/home/martin/GambasCAD/png/circle3.png"), "cadcircle")
    ' tblCircles.AddToolButton("tbnellipse",, Picture.Load("/home/martin/GambasCAD/png/ellipse full.png"), "cadellipse")
    ' tblCircles.AddToolButton("tbnarc",, Picture.Load("/home/martin/GambasCAD/png/ARC.png"), "cadarc")

    '
    ' ' Armo la barra Inquiry
    '

    'Action_Activate("file_new")

    tmrAutosave.Delay = config.AutoSaveDelayMin * 1000 * 60
    'tmrAutosave.Enabled = True

    Me.Visible = False

    LeerRecientes
    LoadButtons(32, 4)
    SetButtonPics(Me)

    splitterH.Layout = Config.SplitterH
    splitterV.Layout = Config.SplitterV


    Me.Show()
    Wait
    Me.Visible = True
    'glPlus.ClearColor(Config.BackgroundColor)

End

'' Escanea el control Padre y busca en el Path SVGs cuyo nombre coincidan con los controles hijos
'' excluidos las tres primeras letras, luego asigna la imagen Ej: tbnCopy <-- copy.svg
Public Sub SetButtonPics(padre As Object, Optional sSvgPath As String = "")

    Dim c As Control, o As Object
    Dim sName As String, svgNames As String[]
    Dim p As Picture
    Dim i As Integer

    If sSvgPath = "" Then sSvgPath = gcd.dirResources &/ "svg" &/ Config.IconFamily

    For Each o In padre.Children
        i = 0
        Try i = o.Children.Count
        If i > 0 Then               ' el control tiene hijos
            SetButtonPics(o, sSvgPath)
        Else                        ' busco si hay una imagen SVG
            sName = Mid(o.name, 4)
            svgNames = Dir(sSvgPath, sName & ".svg")

            If svgNames.Count > 0 Then
                o.w = Config.ButtonSize
                o.h = Config.ButtonSize
                o.Picture = Image.Load(sSvgPath &/ svgNames[0]).Stretch(Config.ButtonSize, Config.ButtonSize).Picture
                o.text = ""
            Endif
        Endif
    Next

End

Public Function Action_Activate(sAction As String) As Boolean
    ' Acciones de los botones y los menús (para no repetir código)
    ' El string de la acción es una propiedad de cada botón o menú
    ' El código que se ejecuta lo hace dentro de la rutina llamada, nunca dentro de este mismo evento.

    Dim r As Float
    Dim NewDrawing As Drawing
    Dim f, fDxf, fBak As String
    'Dim fMinimal As String = "./minimal/minimal-2010.dxf"
    Dim fMinimal As String = "./minimal/minimal.dxf"
    Dim fx As String[]
    Dim fbas As String
    Dim sWName As String
    Dim t As String
    Dim iColor, i As Integer
    Dim imgCirculito As Image
    Dim clsJob As String
    Dim d As Drawing
    Dim sActionParams As String[]

    Try gcd.debuginfo(Last.name)

    Select Case LCase(sAction)

        Case "applyprops"
            For i = 0 To tblProperties.Rows.Max
                If tblProperties[i, 1].Tag Then ' esta propiedad cambio
                    clsEntities.EditEntities(LCase(tblProperties[i, 0].text), tblProperties[i, 1].Text)
                End If
            Next

        Case "new_sheet"

            fSheet.ShowModal()
            GLArea1.Refresh

        Case Like "_*"
            ' todo lo que empiece con _ lo envio al job
            gcd.clsJob.KeyText(sAction)
        Case "mentities-copy"
            Dim sToCopy As String
            For Each e As Entity In gcd.Drawing.SelectedEntities
                sToCopy &= clsEntities.EntityToJsonString(e)

            Next

            Clipboard.Clear
            Clipboard.Copy(sToCopy)

        Case "undo"

            gcd.Drawing.uUndo.DoUndo()
            gcd.Regen

        Case "redo"

            gcd.Drawing.uUndo.DoRedo()
            gcd.Regen
        Case "config"

            fOptions.ShowModal
            Me.tabDrawings[0].Visible = Config.ShowConsoleTab
            glPlus.ClearColor(Config.BackgroundColor)

        Case "exit"

            form_Close

        Case "regen"

            gcd.Regen

            ' Case "pdf_export"
            '
            '     If Printer1.Configure() Then Return
            '     Printer1.Print
        Case "print"

            If Not gcd.Drawing.CurrPrintStyle Then gcd.Drawing.CurrPrintStyle = New PrintStyle
            fPrint.Show '.run()
            ' If i = 1 Then
            '
            '     Printer1.Print
            ' Else If i = 0 Then
            '     gcd.debugInfo("Print cancelled")
            '
            ' Else If i = 2 Then
            '     gcd.debugInfo("Selecting what to print")
            '
            ' End If

            ' vemos si hay q imprimir algo

        Case "undo"
            gcd.Drawing.uUndo.DoUndo()
            gcd.Regen

        Case "about"
            i = fAbout.ShowModal()

            ' Case "redo"
            '     gcd.Drawing.uUndo.DoRedo()
            '     gcd.Regen
        Case "window_close"
            For i = 0 To gcd.Drawings.Count
                If gcd.Drawings[i] = gcd.Drawing Then
                    gcd.Drawings.Remove(i)
                    If gcd.Drawings.Count > 0 Then
                        gcd.Drawing = gcd.Drawings[0]
                        Redraw
                    Else

                        Action_Activate("file_new")
                    Endif
                    Break
                End If

            Next

        Case "window_closeall"
            gcd.Drawings.Clear
            Action_Activate("file_new")

        Case Like "windowchange_*"

            sWName = Mid(sAction, 14)

            For Each d In gcd.Drawings
                If sWName = d.FileName Then
                    gcd.Drawing = d
                    gcd.UpdateLayersCombo
                    gcd.UpdateLineWtCombo
                    gcd.UpdateLineTypeCombo
                    gcd.UpdatDimTypeTypeCombo
                    Me.redraw
                    Me.Text = f

                    'FillWindowMenu
                    Break
                Endif
            Next

        Case "file_quit"

            Me.Close
            Quit

        Case "file_new"

            actions.FileNew

        Case "file_open"

            actions.FileOpen

        Case Like "file_open_*"

            sWName = Mid(sAction, 11)

            actions.FileOpen(sWName)

        Case "file_save"

            f = gcd.Drawing.FileName
            fbas = File.Dir(f) &/ File.BaseName(f)
            fBak = "'" & fbas & ".bak'"
            If gcd.Drawing.RequiresFileRename Then
                Me.Action_Activate("file_saveas")
                Return
            Else
                If Exist(f) Then
                    If Exist(fBak) Then Shell "rm " & fBak Wait
                    Shell "mv '" & f & "' '" & fbas & ".bak'" Wait
                End If

                If File.Ext(f) = "dxf" Then
                    Dxf.SaveFile(f, gcd.Drawing)
                Else If File.Ext(f) = "dwg" Then
                    ' guardamos la version DXF en el dir adecuado, con el nombre elegido
                    't = main.dirDxfOut &/ Utils.FileWithoutExtension(Utils.FileFromPath(f)) & ".dxf"
                    t = Temp & ".dxf"
                    Dxf.SaveFile(t, gcd.Drawing)
                    t = gcd.oda_dxftodwg(t)
                    ' como el proceso de grabado pudo resultar en error, chequeo la existencia primero

                    If Exist(t) Then Move t To f

                End If

            Endif

        Case "file_saveas"

            f = gcd.Drawing.FileName
            fbas = File.Dir(f) &/ File.BaseName(f)
            fBak = "'" & fbas & ".bak'"

            'Dialog.AutoExt = True
            Dialog.Filter = ["*.dxf", "DXF Drawing exchange 2010", "*.dwg", "DWG AutoCAD Drawing file 2010"]
            If Dialog.SaveFile() Then Return ' cancel saving

            f = Dialog.Path

            If File.Ext(f) = "" Then f = File.SetExt(f, "dxf")

            If Exist(f) Then
                If Message.Question(("The file exist"), ("Replace"), ("Cancel")) = 2 Then
                    f = ""
                Endif
            Endif

            If f = "" Then
                Print "Cancel"
            Else

                'If LCase(File.Ext(f)) <> "dxf" Then f &= ".dxf"
                If Exist(f) Then
                    If Exist(fBak) Then Shell "rm " & fBak Wait
                    Shell "mv '" & f & "' '" & fbas & ".bak'" Wait
                End If

                gcd.Drawing.FileName = f
                gcd.Drawing.RequiresFileRename = False
                Action_Activate("file_save")

                Me.Text = f

            Endif

        Case Like "cad*"

            ' actions, with & for additional parameters
            ' cadDimension_Linear&horizontal

            Dim o As Object, sRunWith As String, iParam As Integer, c As Class

            sActionParams = Split(sAction, "&")
            sRunWith = UCase(Mid(sActionParams[0], 4))
            Try iParam = CInt(sActionParams[1])

            o = gcd.CCC[sRunWith]
            If Not o Then Return
            gcd.clsJobPrevious = gcd.clsJob
            ' check if the class needs to be run trough other class
            If o.usewith = "" Then                        ' its a tool
                gcd.clsJob = o
                gcd.clsJob.start(iParam)

            Else                                           ' its propably an eentity

                gcd.clsJob = gcd.CCC[o.usewith]
                gcd.clsJob.start(o, iParam)

            End If

        Case Like "layer_change_*"

            Dim sLayerName As String

            sLayerName = Mid(sAction, 14)

            ' mbtLayers.Text = sLayerName
            ' iColor = gcd.Drawing.cLayers[sLayerName][dxf.codColor]
            ' mbtLayers.Picture = paintPlus.picCirculito(8, gcd.gColor[iColor], Color.ButtonForeground)

            ' informamos
            gcd.Drawing.CurrLayer = gcd.GetLayer(sLayerName)

            ' si tengo algo seleccionado, debo cambiar su color a este
            clsEntities.EditEntities("layer", gcd.Drawing.CurrLayer.name)

            clsEntities.DeSelection()

        Case Like "color_*"

            iColor = CInt(Mid(sAction, 7))
            mbtColors.Text = "Color " & CStr(iColor) 'Me.mbtColors.Children[iColor].Text
            If iColor = 256 Then mbtColors.Text = "ByLayer"
            If iColor = 257 Then mbtColors.Text = "ByBlock"

            mbtColors.Picture = paintPlus.picCirculito(8, gcd.gColor[iColor], Color.ButtonForeground)

            gcd.Drawing.CurrColor = iColor

            ' si tengo algo seleccionado, debo cambiar su color a este
            clsEntities.EditEntities("color", iColor)
            clsEntities.DeSelection()

        Case "more_colors"

            iColor = fColors.ShowModal()
            If iColor < 0 Then Return

            Me.Action_Activate("color_" & CStr(iColor))

        Case Like "linewt_change_*"

            gcd.Drawing.CurrLineWt = CInt(Mid(sAction, 15)) / 100

            clsEntities.EditEntities("linewt", gcd.Drawing.CurrLineWt)
            clsEntities.DeSelection()

        Case Like "ltype_change_*"

            gcd.Drawing.CurrLineType = gcd.FindLType(Mid(sAction, 14))

            clsEntities.EditEntities("linetype", gcd.Drawing.CurrLineType)
            clsEntities.DeSelection()

        Case "grid"
            gcd.Drawing.GridActive = Not gcd.Drawing.GridActive
            If gcd.Drawing.GridActive Then DrawingAids.RebuildGrid

        Case "ortho"
            gcd.Orthogonal = Not gcd.Orthogonal
        Case "snap"
            If gcd.SnapMode <> 0 Then gcd.SnapMode = 0 Else gcd.SnapMode = Config.SnapModeSaved

    End Select

End

Public Sub LeerRecientes()

    'TODO esto deberia estar en un ini
    ' obtengo los lastopen

    Dim mnuLastOpen As New Menu(Me)
    Dim mnuFiles As Menu

    mnuLastOpen.Name = "LastOpenedFiles"
    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen1
    mnuFiles.Action = "file_open_" & Config.FilesLastOpen1

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen2
    mnuFiles.Action = "file_open_" & config.filesLastOpen2

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen3
    mnuFiles.Action = "file_open_" & config.filesLastOpen3

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen4
    mnuFiles.Action = "file_open_" & config.filesLastOpen4

    mnuFiles = New Menu(mnuLastOpen)
    mnuFiles.Text = Config.FilesLastOpen5
    mnuFiles.Action = "file_open_" & config.filesLastOpen5

    MenuButton1.Menu = "LastOpenedFiles"

End

Public Sub GuardarParaMetros()

    If main.setting.lastopen1 <> "" Then config.LastOpen1 = main.setting.lastopen1
    If main.setting.lastopen2 <> "" Then config.LastOpen2 = main.setting.lastopen2
    If main.setting.lastopen3 <> "" Then config.LastOpen3 = main.setting.lastopen3
    If main.setting.lastopen4 <> "" Then config.LastOpen4 = main.setting.lastopen4
    If main.setting.lastopen5 <> "" Then config.LastOpen5 = main.setting.lastopen5

End

Public Sub AddFilesOpen(sFilename As String)

    ' verifico que ya lo tenga en la lista de recientes
    If sFilename = Config.FilesLastOpen1 Then Return ' nada que hacer

    ' ubico en primer lugar al archivo reciente
    If sFilename = Config.FilesLastOpen2 Then
        Swap Config.FilesLastOpen2, Config.FilesLastOpen1
        Return
    End If

    If sFilename = Config.FilesLastOpen3 Then
        Swap Config.FilesLastOpen3, Config.FilesLastOpen1
        Return
    End If
    If sFilename = Config.FilesLastOpen4 Then
        Swap Config.FilesLastOpen4, Config.FilesLastOpen1
        Return
    End If
    If sFilename = Config.FilesLastOpen5 Then
        Swap Config.FilesLastOpen5, Config.FilesLastOpen1
        Return
    End If

    ' no lo tengo, descarto el ultimo y lo agrego al principio, desplazando el resto
    Config.FilesLastOpen5 = Config.FilesLastOpen4
    Config.FilesLastOpen4 = Config.FilesLastOpen3
    Config.FilesLastOpen3 = Config.FilesLastOpen2
    Config.FilesLastOpen2 = Config.FilesLastOpen1
    Config.FilesLastOpen1 = sFilename

End

Public Sub VerifLastOpen(sA_Abrir As String)

    Dim loTengo As Integer
    ' reacomodo los Recientes, de maanera SIMPLE

    ' primero veo si lo tengo
    loTengo = False
    If sA_Abrir = mnuReciente1.text Then loTengo = 1
    If sA_Abrir = mnuReciente2.text Then loTengo = 2
    If sA_Abrir = mnuReciente3.text Then loTengo = 3
    If sA_Abrir = mnuReciente4.text Then loTengo = 4
    If sA_Abrir = mnuReciente5.text Then loTengo = 5

    If Not lotengo Then
        ' desplazo todos los recientes hacia abajo
        main.setting.lastopen5 = main.setting.lastopen4
        main.setting.lastopen4 = main.setting.lastopen3
        main.setting.lastopen3 = main.setting.lastopen2
        main.setting.lastopen2 = main.setting.lastopen1
        main.setting.lastopen1 = sA_Abrir

        GuardarParametros
        LeerRecientes

    End If
    sA_Abrir = ""

End

Public Sub form_Close()

    actions.ExitProgram

End

Public Sub form_Open()

End

Public Sub glarea1_Resize()

    GLplus.Resize(glarea1)

End

' Public Sub GLPaper_resize()
'
'     GLplus.Resize(GLPaper)
'
' End

Public Sub GLArea1_draw()

    Dim iParent As Integer
    Dim i, BackGroundColor As Integer
    Dim L As Layer
    Dim vpt As Viewport
    Dim e As Entity

    If Not gcd.DrawingReady Then Return

    gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)

    gl.LoadIdentity

    gl.Translatef(gcd.Drawing.Sheet.PanX, gcd.Drawing.Sheet.PanY, 0)

    gl.Scalef(gcd.Drawing.Sheet.ScaleZoom, gcd.Drawing.Sheet.ScaleZoom, 1)

    If gcd.DrawHoveredEntity Then
        If gcd.Drawing.HoveredEntity Then
            gl.CallList(gcd.Drawing.HoveredEntity.glDrwListRemark)
        End If
    End If

    gcd.clsJob.Draw()
    If Not gcd.Drawing.Sheet.IsModel Then   ' Sheet view

        For Each vpt In gcd.Drawing.Sheet.vViewports
            gl.LoadIdentity

            ' el scissor no se ve afectado por las trnasformaciones!!!!!!!!

            'glPlus.Rectangle2D(-GLArea1.W / 2 + gcd.XPix(vpt.X0), GLArea1.h / 2 - gcd.YPix(vpt.Y0), gcd.Pixels(vpt.X1 - vpt.x0), gcd.Pixels(vpt.Y1 - vpt.y0))

            'gl.Scissor(-GLArea1.W / 2 + gcd.XPix(vpt.X0), GLArea1.h / 2 - gcd.YPix(vpt.Y0), gcd.Pixels(vpt.X1 - vpt.x0), gcd.Pixels(vpt.Y1 - vpt.y0))

            gl.Translatef(gcd.Drawing.Sheet.PanX, gcd.Drawing.Sheet.PanY, 0)

            gl.Scalef(gcd.Drawing.Sheet.ScaleZoom, gcd.Drawing.Sheet.ScaleZoom, 1)

            gl.Translatef(vpt.PanX, vpt.PanY, 0)
            gl.Scalef(vpt.ScaleZoom, vpt.ScaleZoom, 1)

            'gl.Enable(GL.sCISSOR_TEST)

            For Each L In vpt.Layers
                If L.Visible Then gl.CallList(L.glList)
            Next
            gl.Disable(gl.SCISSOR_TEST)
        Next

        'gl.Viewport(0, 0, gcd.Drawing.GLAreaInUse.W, gcd.Drawing.GLAreaInUse.h)

        gl.LoadIdentity

        gl.Translatef(gcd.Drawing.Sheet.PanX, gcd.Drawing.Sheet.PanY, 0)

        gl.Scalef(gcd.Drawing.Sheet.ScaleZoom, gcd.Drawing.Sheet.ScaleZoom, 1)

        For Each e In gcd.Drawing.Sheet.Entities
            'gcd.CCC[e.gender].Draw(e)
            gl.CallList(e.glDrwList)
        Next

        'gl.CallList(gcd.Drawing.Sheet.Layer.glList)

        ' esto representa la hoja a imprimir

        If gcd.Drawing.Sheet.Viewport Then ' tenemos un viewport activo
            BackGroundColor = Color.LightGray
            glPlus.Rectangle2D(gcd.Drawing.Sheet.Viewport.x0, gcd.Drawing.Sheet.Viewport.Y0, gcd.Drawing.Sheet.Viewport.X1 - gcd.Drawing.Sheet.Viewport.x0, gcd.Drawing.Sheet.Viewport.y1 - gcd.Drawing.Sheet.Viewport.y0, gcd.Drawing.Sheet.BackGroundColor)
        Else
            BackGroundColor = gcd.Drawing.Sheet.BackGroundColor
        End If

        glPlus.Rectangle2D(0, 0, gcd.Drawing.Sheet.pPrintStyle.PaperSizeW, gcd.Drawing.Sheet.pPrintStyle.PaperSizeH, BackGroundColor)

    Else ' Model view

        gl.CallList(gcd.Drawing.GlListSelectedEntities)

        For Each L In gcd.Drawing.Layers
            If L.Visible Then gl.CallList(L.glList)
        Next

    End If

    ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja ultimo

    '
    If gcd.DrawBounds Then DrawingAids.DrawPolygons

    DrawingAids.DrawCoordenadas

    DrawingAids.DibujaHelper


    '
    'clsEntities.DrawArrays()

    ' POI dinamicos
    If gcd.Drawing.flgShowPOIinfo And gcd.Drawing.iEntity.Count > 0 Then

        Select gcd.Drawing.iEntity[2]
            Case gcd.poiMidPoint
                glPlus.PolygonFilled([gcd.Drawing.iEntity[0] - gcd.Metros(4), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] + gcd.Metros(4), gcd.Drawing.iEntity[0] + gcd.Metros(4), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] - gcd.Metros(4)], Color.Blue, Color.Green)
            Case gcd.poiQuadrant
                glPlus.PolygonFilled([gcd.Drawing.iEntity[0] - gcd.Metros(6), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] + gcd.Metros(6), gcd.Drawing.iEntity[0] + gcd.Metros(6), gcd.Drawing.iEntity[1], gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1] - gcd.Metros(6)], Color.Cyan, Color.Cyan)

            Case 0
                ' nada
            Case gcd.poiCenter, gcd.poiBasePoint

                glPlus.CIRCLE([gcd.Drawing.iEntity[0], gcd.Drawing.iEntity[1]], gcd.Metros(4), Color.Cyan, True, False)
                'glPlus.Rectangle2D(gcd.Drawing.iEntity[0] - gcd.Metros(4), gcd.Drawing.iEntity[1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1, 1)

            Case Else
                glPlus.Rectangle2D(gcd.Drawing.iEntity[0] - gcd.Metros(4), gcd.Drawing.iEntity[1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1)
        End Select

    Endif


    ' test

    'glPlus.PolyLines([0, 0, 1, 0, 1, -20, 0, -20, 0, 0], color.blue,, [10, -10])

    If gcd.Drawing.GridActive Then gl.CallList(gcd.Drawing.GLListGrid)

    If gcd.flgNewPosition Then
        clsEntities.CollectVisibleEntities
        gcd.flgNewPosition = False
    End If

End

' NUEVO Protocolo del Mouse para OpenGL: todo se envia a la clsJob actuante

Public Sub GLArea1_MouseDown()

    gcd.clsJob.mouseDown()

End

' Public Sub GLPaper_MouseDown()
'
'     gcd.clsJob.mouseDown()
'
' End

Public Sub GLArea1_DblClick()

    gcd.clsJob.DblClick()

End

' Public Sub GLPaper_MouseMove()
'
'     GLArea1_MouseMove
'
' End

Public Sub GLArea1_MouseMove()

    If Not gcd.clsJob Then Return
    Xr = gcd.Xreal(Mouse.x)
    Yr = gcd.Yreal(Mouse.y)

    ' Universal:
    gcd.clsJob.MouseMove()

    'Me.lblCoordX.Text = Mouse.x & ":" & Mouse.y & " <-> " & Format(Xr, Config.FormatCoord) & " : " & Format(Yr, config.FormatInquiries)
    Me.lblCoordX.Text = "X: " & Mouse.x & " -> " & Format(Xr, Config.FormatCoord)
    Me.lblCoordY.Text = "Y: " & Mouse.y & " -> " & Format(Yr, config.FormatCoord)
    Me.lblCoordX.Refresh
    Me.lblCoordY.Refresh

    If Mouse.Middle Then
        cadPan.MouseMove()
    Else If Mouse.Left Then

    Else If Mouse.Right Then

    Else
        ' If gcd.flgsearchingallowed Then
        '     gcd.Drawing.HoveredEntity = clsMouseTracking.CheckAboveEntity(Xr, Yr)
        '     If gcd.Drawing.HoveredEntity Then gcd.redraw
        '     ' If gcd.Drawing.HoveredEntityPrevious <> gcd.Drawing.HoveredEntity Then
        '     '     gcd.Drawing.HoveredEntityPrevious = gcd.Drawing.HoveredEntity
        '     '     gcd.Drawing.HoveredEntity = Null
        '     '
        '     ' Endif
        ' End If
        ReSearch

    End If

    '   If gcd.clsJob.gender <> "Pan" Then
    '     gcd.clsJobPreZoom = gcd.clsJob
    '     gcd.clsJob = cadPan
    '     gcd.clsJob.Start()
    '     ' glarea1.Refresh  ' glarea1.Refresh
    '     '
    '     '
    '   Else
    '
    '     gcd.clsJob = gcd.clsJobPreZoom
    '
    '   End If
    '
    ' End If

End

Public Sub GLArea1_MouseUp()

    gcd.clsJob.MouseUp()

End

' Public Sub GLPaper_MouseUp()
'
'     gcd.clsJob.MouseUp()
'
' End

Public Sub GLArea1_MouseWheel()



    gcd.clsJob.MouseWHEEL()




    gcd.setdashes
    DrawingAids.RebuildGrid



End

' Public Sub GLPaper_Draw()
'
'     Dim iParent As Integer
'     Dim i As Integer
'     Dim L As Layer
'
'     Dim vpt As Viewport
'     Dim e As Variant
'
'     If Not gcd.DrawingReady Then Return
'
'     glPlus.ClearColor(Color.Black) 'gcd.gColor[Color.Red))
'
'     gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)
'
'     gl.LoadIdentity
'
'     gl.Translatef(gcd.Drawing.CurrSheet.PanX, gcd.Drawing.CurrSheet.PanY, 0)
'
'     gl.Scalef(gcd.Drawing.CurrSheet.ScaleZoom, gcd.Drawing.CurrSheet.ScaleZoom, 1)
'
'     ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja primero
'
'     ' Primero la grid
'     ' DrawingAids.DrawGrid
'
'     ' ' TEST
'     ' Dim fArcParams As Float[]
'     '
'     ' ' aqui podria usar una rutina de arco entre 3 puntos
'     ' fArcParams = puntos.Arc3Point(0, 0, -100, 50, -300, 20)
'     ' ' traslado el centro
'     ' gl.Translatef(fArcParams[0], fArcParams[1], 0)
'     ' glPlus.ARC(fArcParams[2], fArcParams[3], fArcParams[4] - fArcParams[3], Color.Blue, 1, 0)
'     ' gl.Translatef(-fArcParams[0], -fArcParams[1], 0)
'     ' fArcParams = Null
'     '
'
'     ' If gcd.Drawing.HoveredEntityPrevious Then
'     '     ' si no esta seleccionada, la resalto
'     '     'If Not arrEntities[iEntity[3]].Selected Then
'     '     'iParent = clsEntities.GetParentBlock(gcd.Drawing.iEntity[3]) ' esto verifica si tiene que resaltar el bloque completo
'     '
'     '     If gcd.DrawHoveredEntity Then gl.CallList(gcd.Drawing.HoveredEntityPrevious.glDrwListRemark)
'     '     '     Gcd.CCC[gcd.Drawing.HoveredEntityPrevious.gender].DrawRemark(gcd.Drawing.HoveredEntityPrevious)
'     '     ' End If
'     ' End If
'
'     ' If gcd.DrawHoveredEntity Then
'     '     If gcd.Drawing.HoveredEntity Then gl.CallList(gcd.Drawing.HoveredEntity.glDrwListRemark)
'     ' End If
'     ' DrawingAids.DrawCoordenadas
'     '
'     ' DrawingAids.DibujaHelper
'     '
'     ' gl.CallList(gcd.Drawing.GlListSelectedEntities)
'     glPlus.Rectangle2D(0, 0, gcd.Drawing.CurrSheet.pPrintStyle.PaperSizeW, gcd.Drawing.CurrSheet.pPrintStyle.PaperSizeH, gcd.Drawing.CurrSheet.BackGroundColor)
'
'     For Each vpt In gcd.Drawing.CurrSheet.vViewports
'         gl.LoadIdentity
'         gl.Translatef(vpt.PanX, vpt.PanY, 0)
'         gl.Scalef(vpt.ScaleZoom, vpt.ScaleZoom, 1)
'         gl.Scissor()
'         For Each L In vpt.Layers
'             If L.Visible Then gl.CallList(L.glList)
'         Next
'     Next
'
'     For Each e In gcd.Drawing.CurrSheet.Entities
'         gcd.CCC[e.gender].Draw(e)
'     Next
'
'     gcd.clsJob.Draw()
'
' End
'
' ' El objetivo es que el zoom dinamico se haga manteniendo el dibujo que esta en la pos del mouse
' Public Sub GLPaper_MouseWheel()
'
'     Dim px, py, dx, dy, factor As Float
'     ' chequeamos si vale la pena seguir dibujando la grid, o sea, menos de 3 pixels
'     ' Inc flgWheelCounter
'     ' Debug "Mouse weel", flgWheelCounter
'
'     ' TODO: revisar la siguiente linea
'     'If gcd.Pixels(FMain.GridSpacing) < 5 Then FMain.GridActive = False Else FMain.GridActive = True
'     '
'     ' px = gcd.Xreal(Mouse.x) ' posicion real en donde esta el mouse, previo al zoom
'     ' py = gcd.Yreal(Mouse.y)
'
'     ' TODO: , redondear para que la escala sea 1:100 1:75 1:50 etc
'
'     factor = (1 + 0.075 * Mouse.Delta)
'
'     gcd.Drawing.CurrSheet.ScaleZoom *= factor
'
'     Debug "ScaleZoom", gcd.Drawing.CurrSheet.ScaleZoom
'     '
'     ' dx = gcd.Xreal(Mouse.x) ' posicion real en donde esta el mouse, posterior al zoom
'     ' dy = gcd.Yreal(Mouse.y)
'
'     ' pero con ciertos limites TODO: imponer
'     ' If ScaleZoom < 0.001 Then ScaleZoom = 0.001
'     ' If ScaleZoom > 50 Then ScaleZoom = 50
'
'     ' nuevo metodo (el Pan esta en pixels)
'     ' gcd.Drawing.PanX += gcd.pixels(dx - px)
'     ' gcd.Drawing.PanY += gcd.pixels(dy - py)
'     '
'     ' gcd.flgNewPosition = True
'     '
'     ' gcd.redraw 'glarea1.Refresh
'     gcd.Drawing.CurrSheet.GLSheet.Refresh
'     ' despues de actualizar la pantalla, recolectamos las entidades visibles
'
'     ' Dec flgWheelCounter
'
' End

Public Sub tabFile_MouseWheel()

    Stop Event

End

Public Sub redraw()

    $hDrawTimer.Trigger
    Wait 0.001

End

Public Sub ReSearch()

    $hSearchTimer.Trigger
    Wait 0.001

End

Public Sub CheckBestPOI()



End


' Public Sub txtInput_KeyRelease()
'
'     If Key.code = Key.Esc Then
'         txtInput.Hide
'         Me.SetFocus
'     End If
'
'     If (Key.code = Key.Enter) Or (Key.code = Key.Return) Then
'         gcd.clsJob.KeyText(txtInput.Text)
'
'         txtInput.Hide
'         Me.SetFocus
'     End If
'
' End

Public Sub Form_Keyrelease()

    Dim com As Variant
    Dim umx As Integer     '' Index in undo array
    Dim uEnty As Entity    '' Undo entity
    Dim aEnty, e As Entity    '' Actual entity
    Dim imx As Integer     '' Index in Entities array
    Dim SelectMode As Boolean

    ' Print Key.Code
    Dim t As Float = Timer

    ' If txtInput.Visible Then Return

    Select Key.Code

        Case Key.Enter, Key.Return
            Debug KeysAccumulator
            ' txtInput.Visible = False
            ' gcd.clsJob.KeyText(txtInput.Text)
            ' txtInput.Text = ""
            '
            ' Me.SetFocus
            '            Form_Activate()

            gcd.clsJob.KeyText(KeysAccumulator)
            KeysAccumulator = ""

        Case Key.f2
            ' t = Timer
            ' Dim NE As New Entity
            ' Debug "Creando 500.000 lineas"
            ' For a = 1 To 500000
            '     NE = cadLine.NewEntity([Rnd(-100, 100), Rnd(-100, -100), Rnd(100, 100), Rnd(100, 100)])
            '     Ngcd.CCC[e.gender].finish(ne)
            '     gcd.Drawing.oEntities.Add(ne, ne.Handle)
            '
            ' Next
            ' Debug "Creadas", Timer - t
            ' t = Timer
            ' gcd.FillLayers()
            ' gcd.Regen
            ' cadZoomE.Start()
            ' clsEntities.CollectVisibleEntities
            '
            ' Debug "Regen en ", Timer - t
            ' Dim oka As Boolean
            ' t = Timer
            ' For Each NE In gcd.Drawing.oEntities
            '     oka = Ngcd.CCC[e.gender].MouseOverMe(NE, 2000, 2000, 10)
            ' Next
            ' Debug "Tracking via Gcd.CCC[e.gender] en ", Timer - t
            '
            ' t = Timer
            '
            ' NE = clsMouseTracking.CheckAboveEntity(2000, 2000, 10)
            '
            ' Debug "Tracking via clsMouseTRacking en ", Timer - t
            '
            ' ' lleno poi
            ' t = Timer
            ' For Each NE In gcd.Drawing.oEntities
            '     Inc a
            '     gcd.Drawing.poiLines.Insert(NE.p.Copy())
            '     gcd.Drawing.oExtras.Add(ne.Handle, Str(a))
            ' Next
            ' Debug "Llenado del POI en ", Timer - t
            ' t = Timer
            ' a = puntos.inPolySegment(gcd.Drawing.poiLines, 2000, 2000, 10)
            ' Debug "Busqueda via POI en ", Timer - t
            ' Stop
            ' ftring = puntos.PolygonTriangulation3([185, -315, 185, -295, 179, -295, 179, -296, 184, -296, 184, -314, 179, -314, 179, -315])

            'ftring2 = puntos.PolygonTriangulation([185, -315, 185, -295, 179, -295, 179, -296, 184, -296, 184, -314, 179, -314, 179, -315])

            'puntos.Translate(ftring2, 80, 0)
            ' Dim NE As New Entity
            ' ne = cadLWPolyline.NewEntity(ftring2)
            ' gcd.Drawing.oEntities.Add(ne, ne.Handle)
            '
            ' ftring2 = [0, 0, 0, 20, -10, 20, -10, 15, -5, 15, -5, 10, -10, 10, -10, 0, 0, 0]
            ' 'ftring2 = puntos.InvertPolyline(ftring2)
            ' ne = cadLWPolyline.NewEntity(ftring2)
            ' gcd.Drawing.oEntities.Add(ne, ne.Handle)
            '
            ' ftring2 = New Float[]
            ' ftring2 = puntos.LinePolyIntersection([-10, 8, -1, 12], ne.p)
            ' Stop
        Case Key.F3  ' tecla reservada para Test de todo tipo
            ' test
            'Utils.SaveClass(gcd.Drawing.Entities[gcd.Drawing.Entities.First], User.home &/ "SaveClassTest.json")

            'Utils.SaveClass(gcd.Drawing, User.home &/ "SaveClassTestDrawing.json")

            Dim c As New Collection, s As String

            c = dgn.ReadDGN("samp15.dgn")
            Stop
        Case Key.f5

            If FInspector.MyState > 0 Then FInspector.Close

            If gcd.Drawing.SelectedEntities.Count > 0 Then
                FInspector.run(gcd.Drawing.SelectedEntities[gcd.Drawing.SelectedEntities.First])
            End If

        Case Key.f6

            gcd.DrawBounds = Not gcd.DrawBounds
            Me.redraw
        Case Key.F4

            gcd.DrawHatch = Not gcd.DrawHatch
            gcd.RegenList

        Case Key.BackSpace

            KeysAccumulator = Left(KeysAccumulator, -1)


        Case Key.F11

        Case Key.Esc

            gcd.clsJob.KeyText("U")

        Case Key.Space
            Stop Event

        Case Key.Del
            gcd.clsJob.KeyText("Erase")

        Case Key.ControlKey
            KeysAccumulator = "Function"

        Case Else
            ' A GOOD KEY
            If InStr(KeysAccumulator, "Function") > 0 Then

                ' Select Key.Code
                '   Case Asc("1") ' Properties
                '
                '     Select PropertiesFlag
                '       Case 1 ' Tools
                '         PropertiesFlag = 2
                '         pnlProperties.Visible = True
                '         pnlIcons.Visible = False
                '         'btnSelectionMode.Value = False
                '       Case 2 ' Props
                '         PropertiesFlag = 0
                '         pnlProperties.Visible = False
                '         pnlIcons.Visible = False
                '         'btnSelectionMode.Value = True
                '
                '       Case Else ' Invisible
                '         PropertiesFlag = 1
                '         pnlProperties.Visible = False
                '         pnlIcons.Visible = True
                '
                '     End Select
                '
                '     If PropertiesFlag = False Then
                '       pnlProperties.Visible = True
                '       PropertiesFlag = True
                '       pnlIcons.Visible = False
                '       btnSelectionMode.Value = False
                '     Else
                '       pnlProperties.Visible = False
                '       PropertiesFlag = False
                '       pnlIcons.Visible = True
                '       btnSelectionMode.Value = True
                '     Endif
                '
                '   Case Asc("2") ' Layers
                '
                '     'Case Asc("3") ' Blocks
                '
                '     'Case Asc("4...") ' More...
                '     'KeysAccumulator &= "-" & Key.Text
                '     'Case Else
                '     '    KeysAccumulator = ""
                '     'pnlProperties.Visible = False
                '     'pnlDebug.Visible = False
                '
                '   Case Asc("3") ' Raw properties for debuging
                '     If RawFlag = False Then
                '       pnlRaw.Visible = True
                '       RawFlag = True
                '     Else
                '       pnlRaw.Visible = False
                '       RawFlag = False
                '     Endif
                '
                '   Case Asc("a"), Asc("A") ' Select/Unselect All
                '     SelectMode = True
                '     For Each aEnty In gcd.Drawing.arrEntities
                '       If aEnty.Selected Then
                '         SelectMode = False
                '         Break
                '       Endif
                '     Next
                '
                '     If SelectMode Then
                '       For Each aEnty In gcd.Drawing.arrEntities
                '         If aEnty.Selected = False Then
                '           aEnty.Selected = True
                '         Endif
                '       Next
                '     Else
                '       For Each aEnty In gcd.Drawing.arrEntities
                '         If aEnty.Selected Then
                '           aEnty.Selected = False
                '         Endif
                '       Next
                '     Endif
                '     fMain.regen
                '
                '   Case Asc("z"), Asc("Z") ' Undo
                '
                '     If gcd.Drawing.arrUndo.Count > 0 Then
                '       umx = gcd.Drawing.arrUndo.Max
                '
                '       uEnty = gcd.Drawing.arrUndo[umx]
                '       For Each aEnty In gcd.Drawing.arrEntities
                '         If aEnty.Handle = uEnty.Handle Then
                '           gcd.Drawing.arrEntities.Remove(imx, 1)
                '           gcd.Drawing.arrEntities.Add(uEnty, imx)
                '           gcd.Drawing.arrUndo.Remove(umx, 1)
                '           fMain.regen
                '           'gcd.Redraw
                '           Break
                '         Endif
                '         Inc imx
                '       Next
                '
                '     Endif
                '   Case Else
                '     KeysAccumulator = ""
                '
                ' End Select

            Else
                If key.text <> "" Then

                    KeysAccumulator &= Key.Text
                    'gcd.clsJob.KeyPress()

                    DrawingAids.ErrorMessage = ""
                    DrawingAids.Refresh
                End If
                ' If fmain.txtInput.Visible Then Return
                ' If Key.Normal <> "" Then
                '     fmain.txtInput.X = fmain.W / 2
                '     fmain.txtInput.Y = fmain.h / 2
                '     fmain.txtInput.SetFocus()
                '     fmain.txtInput.Text = Key.Text
                '     fmain.txtInput.Visible = True
                ' End If

            Endif

    End Select

    'DrawingAids.DibujaHelper

End

' Public Sub tbLayerForm_Click()
'
'     fLayersOnScreen.Move(tbLayerForm.ScreenX, tbLayerForm.ScreenY + tbLayerForm.h)
'     fLayersOnScreen.Show()
'
' End

Public Sub grdLayers_Click()

    If gcd.flgShowingLayers Then
        fLayersOnScreen.Hide
        gcd.flgShowingLayers = False

    Else
        If grdLayers.Column = 1 Then ' Visibility
            gcd.Drawing.CurrLayer.Visible = Not gcd.Drawing.CurrLayer.Visible

            If gcd.Drawing.CurrLayer.Visible Then grdLayers[0, 1].Picture = fLayersOnScreen.picVisibleOn Else grdLayers[0, 1].Picture = fLayersOnScreen.picVisibleOff

        Else If grdLayers.Column = 2 Then ' frozen
            gcd.Drawing.CurrLayer.Frozen = Not gcd.Drawing.CurrLayer.Frozen

            If gcd.Drawing.CurrLayer.Frozen Then grdLayers[0, 2].Picture = fLayersOnScreen.picFrozenOn Else grdLayers[0, 2].Picture = fLayersOnScreen.picFrozenOff

        Else If grdLayers.Column = 3 Then ' lock
            gcd.Drawing.CurrLayer.Locked = Not gcd.Drawing.CurrLayer.Locked

            If gcd.Drawing.CurrLayer.Locked Then grdLayers[0, 3].Picture = fLayersOnScreen.picLockedOn Else grdLayers[0, 3].Picture = fLayersOnScreen.picLockedOff

        Else

            gcd.flgShowingLayers = True

            fLayersOnScreen.Run()
            'fLayersOnScreen.Move(grdLayers.ScreenX, grdLayers.ScreenY + grdLayers.h + 1)
            ' puede venir un cambio de Layers, lo que con una seleccion implica que se cambian
            ' las propiedades de dichas entidades y hay que regenerar
            'fLayersOnScreen.Y = grdLayers.ScreenY + grdLayers.h + 1
        End If
    End If

End

' Public Sub FillWindowMenu()
'
'     Dim d As Drawing
'     Dim mItem As Menu
'
'     mnuWindow.Children.Clear
'
'     For Each d In gcd.Drawings
'         mItem = New Menu(mnuWindow)
'         mItem.Text = d.FileName
'         If d = gcd.Drawing Then mItem.Checked = True Else mItem.Checked = False
'         mItem.Action = "windowchange_" & d.FileName
'     Next
'
'     mItem = New Menu(mnuWindow)
'     mItem.Text = "" ' separador
'
'     ' y ahora agrego dos
'     mItem = New Menu(mnuWindow)
'     mItem.Text = ("Close")
'     mItem.Action = "window_close"
'
'     mItem = New Menu(mnuWindow)
'     mItem.Text = ("Close all")
'     mItem.Action = "window_closeall"
'
' End

' Public Sub ToggleButton3_Click()
'
'     If Not ToggleButton3.Value Then
'         ToggleButton3.Tag = CStr(ToggleButton3.Parent.h)
'         ToggleButton3.Parent.h = ToggleButton3.H
'     Else
'
'         ToggleButton3.Parent.h = CInt(ToggleButton3.tag)
'     End If
'
' End
'
' Public Sub ToggleButton4_Click()
'
'     If Not ToggleButton4.Value Then
'         ToggleButton4.Tag = CStr(ToggleButton4.Parent.h)
'         ToggleButton4.Parent.h = ToggleButton4.H
'     Else
'
'         ToggleButton4.Parent.h = CInt(ToggleButton4.tag)
'     End If
'
' End

' Public Sub tmrAutosave_Timer()
'
'     ' el autosave funciona solo si guarde antes, o sea si el dibujo tiene nombre
'     ' ademas se guarda solo en formato dxf, para acelerar el proceso
'
'     If Not gcd.Drawing.RequiresFileRename Then
'         If gcd.Drawing.RequiresSaving Then
'             If Dxf.SaveFile(gcd.Drawing.FileName & ".Autosave", gcd.Drawing.cModel) < 0 Then
'                 Print "Autosave error"
'             Else
'                 Print ("Autosaved to ") & gcd.Drawing.FileName & ".Autosave"
'             Endif
'         End If
'     End If
'
' End

' Public Sub tbnInspector_MouseUp()
'
'     If Mouse.Left Then
'
'         Config.TrackShowInspector = Not Config.TrackShowInspector
'         tbnInspector.Value = Config.TrackShowInspector
'         If Not Config.TrackShowInspector Then
'             Try fInspector.Close
'         Endif
'
'     Else If Mouse.Right Then
'
'         fDetectOptions.Show()
'
'     Endif
'
' End

Public Sub tbnOrtho2_Click()

    gcd.DrawBounds = Not gcd.DrawBounds
    Me.redraw

End

Public Function UpdatDimTypeTypeCombo()

    Dim oDimStyle As DimStyle
    Dim i As Integer

    If IsNull(gcd.Drawing.CurrDimStyle) Then gcd.Drawing.CurrDimStyle = gcd.Drawing.DimStyles[gcd.Drawing.DimStyles.First]
    fMain.cmbDimStyle.Clear
    For Each oDimStyle In gcd.Drawing.DimStyles
        fMain.cmbDimStyle.Add(oDimStyle.name)

        If gcd.Drawing.CurrDimStyle.name = oDimStyle.name Then i = fMain.cmbDimStyle.Count
    Next
    If i = 0 Then i = 1
    If fMain.cmbDimStyle.Count > 0 Then fMain.cmbDimStyle.Index = i - 1

End
'' Transfer layers to main windows ComboBox

Public Sub UpdateLayersCombo()

    Dim i As Integer
    Dim sName As String = "_menuLay"
    Dim mLayer As New Menu(fMain), m2 As Menu
    Dim aLayer As Layer

    For i = 0 To fMain.Menus.Count - 1
        If fMain.Menus[i].Name = sName Then
            fMain.Menus[i].Delete
            Break
        End If
    Next
    mLayer.Name = sName
    For Each aLayer In gcd.Drawing.Layers
        If aLayer.Hidden Then Continue
        m2 = New Menu(mLayer)
        m2.Text = aLayer.Name
        m2.Picture = paintPlus.picCirculito(8, gcd.GetGBColor(aLayer.Colour), Color.ButtonForeground)
        m2.Action = "layer_change_" & aLayer.Name
    Next
    ' fMain.mbtLayers.Menu = sName
    ' fMain.mbtLayers.Text = mLayer.Children[0].Text
    ' fMain.mbtLayers.Picture = mLayer.Children[0].Picture
    If Not gcd.Drawing.CurrLayer Then gcd.Drawing.CurrLayer = gcd.Drawing.Layers[gcd.Drawing.Layers.First]

    fMain.grdLayers[0.0, 0.0].Picture = mLayer.Children[0].Picture
    fMain.grdLayers[0, 4].Text = gcd.Drawing.CurrLayer.Name
    fMain.grdLayers[0, 1].Picture = IIf(gcd.Drawing.CurrLayer.Visible, fLayersOnScreen.picVisibleOn, fLayersOnScreen.picVisibleOff)
    fMain.grdLayers[0, 2].Picture = IIf(gcd.Drawing.CurrLayer.Frozen, fLayersOnScreen.picFrozenOn, fLayersOnScreen.picFrozenOff)
    fMain.grdLayers[0, 3].Picture = IIf(gcd.Drawing.CurrLayer.Locked, fLayersOnScreen.picLockedOn, fLayersOnScreen.picLockedOff)

    ' fMain.tbnLayersOnScreen.Picture = paintPlus.picTexto(gcd.Drawing.arrLayers.First.Name, fMain.Font.H, fMain.tbnLayersOnScreen.w, fMain.tbnLayersOnScreen.h, Color.ButtonForeground, Color.ButtonBackground, Align.Left)

    Return

End

'' Should be called after updating layers
Public Sub UpdateLineWtCombo()

    Dim imagen As Image

    Dim LW As Float
    Dim f As Float

    ' lo vacio

    fMain.tblLineWt.tbnChilds.Clear

    ' primero agregamos la correspondiente a ByLayer
    imagen = New Image(fMain.tblLineWt.w * 0.9, fMain.tblLineWt.h * 0.9, fMain.tblLineWt.Background)

    Paint.Begin(imagen)
    '  +------------------------------------+
    '  +   ---------------------  0.00mm    +
    '  +------------------------------------+
    Paint.MoveTo(0, imagen.h / 2)
    lw = gcd.Drawing.CurrLayer.LineWt '][dxf.codLWht] / 100 * 3
    Paint.LineWidth = lw
    If Paint.LineWidth < 1 Then Paint.LineWidth = 1
    Paint.RelLineTo(imagen.w / 2, 0)
    Paint.Stroke
    Paint.MoveTo(imagen.w / 10 * 5.5, imagen.h * 0.1)
    Paint.LineWidth = 1
    Paint.Text("ByLayer",,,, imagen.h * 0.6, Align.Left)
    Paint.Fill
    Paint.End

    fMain.tblLineWt.AddToolButton("tbnLineWtByLayer",, imagen.Picture, "linewt_change_" & CStr(lw * 100))

    ' ahora espesores especificos
    For f = 0.1 To 1.2 Step 0.1
        ' primero agregamos la correspondiente a ByLayer
        imagen = New Image(fMain.tblLineWt.w * 0.9, fMain.tblLineWt.h * 0.9, fMain.tblLineWt.Background)

        Paint.Begin(imagen)
        Paint.AntiAlias = True
        '  +------------------------------------+
        '  +   ---------------------  0.00mm    +
        '  +------------------------------------+
        Paint.MoveTo(0, imagen.h / 2)
        lw = f * 3
        Paint.LineWidth = lw
        If Paint.LineWidth < 1 Then Paint.LineWidth = 1
        Paint.RelLineTo(imagen.w / 2, 0)
        Paint.Stroke
        Paint.MoveTo(imagen.w / 10 * 5.5, imagen.h * 0.1)
        Paint.LineWidth = 1
        Paint.Text(Format(f, "0.00mm"),,,, imagen.h * 0.6, Align.Left)
        Paint.Fill
        Paint.End

        fMain.tblLineWt.AddToolButton("tbnLineWt" & CStr(f),, imagen.Picture, "linewt_change_" & CStr(lw * 100))

    Next

    '   test id[mm]
    ' # ¡DIV/0!	0	0
    ' 0, 05 1 0, 05
    ' 0, 09 2 0, 09
    ' 0, 1 3 0, 1
    ' 0, 13 4 0, 13
    ' 0, 15 5 0, 15
    ' 0, 18 6 0, 18
    ' 0, 2 7 0, 2
    ' 0, 25 8 0, 25
    ' 0, 3 9 0, 3
    ' 0, 35 10 0, 35
    ' 0, 4 11 0, 4
    ' 0, 45 12 0, 45
    ' 0, 5 13 0, 5
    ' 0, 53 14 0, 53
    ' 0, 6 15 0, 6
    ' 0, 65 16 0, 65
    ' 0, 7 17 0, 7
    ' 0, 8 18 0, 8
    ' 0, 9 19 0, 9
    ' 1 20 1
    ' 0, 4761904761905 21 1, 06
    ' 0, 9090909090909 22 1, 2
    ' 1, 304347826087 23 1, 4
    ' 1, 6666666666667 24 1, 58
    ' 2 25 2
    ' 	26 2, 11
    ' 	27
    ' 	28
    ' ByLayer 29
    ' ByBlock 30
    ' Default 31

End

Public Sub UpdateLineTypeCombo()

    ' se define en DXF con los codigos:
    ' 40 = largo total por tramo ( = suma de Abs(code 49) )
    ' 73 = numero de elementos (linea,espacio, punto) = 0 si es continua
    ' 49 = largo de cada elemento: 0 = dot, negativo = espacio, positivo = linea
    Dim imagen As Image
    Dim i As Integer
    Dim lty As LineType
    Dim d As Float

    '  +------------------------------------+
    '  + Phantom                            +
    '  + -- - -- - -- - -- - -- - -- - --   +
    '  +------------------------------------+

    fMain.tblLTypes.tbnChilds.Clear

    ' ahora espesores especificos
    For Each lty In gcd.Drawing.LineTypes
        Inc i
        For Each d In lty.TrameLength
            d = Abs(d)
        Next

        ' primero agregamos la correspondiente a ByLayer
        imagen = New Image(fMain.tblLTypes.w * 0.9, fMain.tblLTypes.h * 0.9, fMain.tblLTypes.Background)

        Paint.Begin(imagen)
        Paint.AntiAlias = True
        Paint.MoveTo(0, imagen.h * 0.8)
        Paint.LineWidth = 1
        Paint.Dash = lty.TrameLength
        Paint.RelLineTo(imagen.w, 0)
        Paint.Stroke
        Paint.Dash = Null
        ' Texto
        Paint.MoveTo(0, 0)
        Paint.LineWidth = 1
        Paint.Text(lty.Name,,,, imagen.h * 0.5, Align.topLeft)
        Paint.Fill
        Paint.End

        fMain.tblLTypes.AddToolButton("tbnLType" & CStr(i),, imagen.Picture, "ltype_change_" & lty.Name)

    Next
    gcd.Drawing.CurrLineType = gcd.Drawing.LineTypes[gcd.Drawing.LineTypes.First]

End

Public Sub tabDrawings_Click()

    gcd.Drawing = tabDrawings[tabDrawings.Index].Tag
    If gcd.Drawing Then FillBlocks
    Try Me.GLArea1 = gcd.Drawing.GLAreaInUse

End

Public Sub tabViews_Click()

    If InUse Then Return

    If Last.current.tag Then
        gcd.Drawing.LastLayer = gcd.Drawing.CurrLayer
        gcd.Drawing.Sheet = gcd.Drawing.Sheets[Last.current.tag]
        gcd.Drawing.GLAreaInUse = gcd.Drawing.Sheet.GLSheet

        ' si es una Sheet, no hay layers, sino una unica capa donde se enserta todo
        '     'Try Me.GLArea1 = gcd.Drawing.GLAreaInUse
        ' Else
        '     gcd.Drawing.CurrSheet = Null
        '     gcd.Drawing.CurrLayer = gcd.Drawing.LastLayer
        '     gcd.Drawing.CurrViewport = gcd.Drawing.ModelViewport
    End If
    'End If
    'gcd.Drawing.GLAreaInUSe.Resize(gcd.Drawing.CurrSheet.GLSheet.W, gcd.Drawing.CurrSheet.GLSheet.h)
    If gcd.Drawing.GLAreaInUSe Then clsEntities.CollectVisibleEntities

End

'' Crea una nueva Tab para alojar un nuevo grafico
Public Function NewTabForDrawing(nDrawing As Drawing)

    Dim i As Integer
    Dim s As Sheet

    NDrawing.iEntity.Insert([0, 0, 0, 0])
    NDrawing.Sheet.ScaleZoom = gcd.ScreenDensity

    Me.tabDrawings.Count += 1
    i = Me.tabDrawings.Count - 1
    Me.tabDrawings[i].Text = Left(Utils.FileFromPath(nDrawing.FileName), 12)
    'Me.tabDrawings[i].Tooltip = sName
    Me.tabDrawings[i].Expand = True
    Me.tabDrawings[i].tag = nDrawing
    Me.tabDrawings.Index = i
    Dim tabFileNew As New TabPanel(Me.tabDrawings[i]) As "tabViews"
    tabFileNew.Expand = True
    tabFileNew.Arrangement = Arrange.Fill
    tabFileNew.Orientation = Align.Bottom
    Object.Attach(tabFileNew, Me, "tabViews")
    For Each s In nDrawing.Sheets
        NewSheet(tabFileNew, s)

    Next
    gcd.Drawing.GLAreaInUse = nDrawing.Model.GLSheet
    fmain.GLArea1 = gcd.Drawing.GLAreaInUse

    gcd.setdashes
    DrawingAids.RebuildGrid

    Me.Refresh

    Return

End

'' Crea una nueva Tab para alojar una nueva hoja
Public Function NewSheet(tabSheets As TabPanel, s As Sheet)

    Dim i As Integer

    InUse = True

    If Not s.IsModel Then tabSheets.Count += 1

    tabSheets[tabSheets.Count - 1].Text = s.Name

    Dim glaFile2 As New GLArea(tabSheets[tabSheets.Count - 1])
    glaFile2.Background = Config.BackgroundColor
    glaFile2.Expand = True
    glaFile2.Tracking = True
    Object.Attach(glaFile2, Me, "GLArea1")
    s.GLSheet = glaFile2
    tabSheets[tabSheets.Count - 1].Tag = s.Handle
    gcd.Drawing.GLAreaInUse = glaFile2

    InUse = False

End

Public Sub tabDrawings_Close(Index As Integer)

    Dim c, c2 As Control
    Dim childs As Integer
    ' tengo q elminar todos los controles que tiene adentro antes de eliminar el tab
    For Each c In tabDrawings[tabDrawings.Index].Children
        childs = 0

        Try childs = c.Children.count
        If childs = 0 Then
            c.Delete
        Else
            For Each c2 In c.Children
                c2.Delete
            Next
            c.Delete
        End If

        tabDrawings[tabDrawings.Index].Delete
    Next

    tabDrawings.Index = tabDrawings.Count - 1
    tabDrawings_Click

End

Public Sub tabDrawings_CloseAll()

    Dim i As Integer

    For i = tabDrawings.Count - 1 To 0 Step -1
        tabDrawings_Close(i)
    Next

End

Public Sub tbnNewSheet_Click()

    fSheet.ShowModal()

    GLArea1.Refresh

End

' Public Sub txtDebug_KeyPress()
'
'     txtDebug.Text &= Key.Text
'
' End

Public Sub LoadButtons(Optional iSize As Integer = 32, iColumns As Integer = 2)

    Dim tb As ToolButton
    Dim iBorder As Integer = 15

    panEntities.W = iSize * iColumns + iBorder
    panDimensions.W = iSize * iColumns + iBorder
    panBlocks.W = iSize * iColumns + iBorder
    panTools.W = iSize * iColumns + iBorder
    panInquiry.W = iSize * iColumns + iBorder

    ' Entidades
    Utils.TBNCreator(panEntities, "tbnLine", "cadLine")
    Utils.TBNCreator(panEntities, "tbnRay", "cadRay")
    Utils.TBNCreator(panEntities, "tbnCircle", "cadCircle")
    Utils.TBNCreator(panEntities, "tbnArc", "cadArc")
    Utils.TBNCreator(panEntities, "tbnlwpolyline", "cadLWPolyline")
    Utils.TBNCreator(panEntities, "tbnEllipse", "cadEllipse")
    Utils.TBNCreator(panEntities, "tbnText", "cadText")
    Utils.TBNCreator(panEntities, "tbnMtext", "cadMtext")
    Utils.TBNCreator(panEntities, "tbnLeader", "cadLeader")
    Utils.TBNCreator(panEntities, "tbnSPLine", "cadSPline")
    Utils.TBNCreator(panEntities, "tbnRectangle", "cadRectangle")
    Utils.TBNCreator(panEntities, "tbnPolygon", "cadPolygon")
    Utils.TBNCreator(panEntities, "tbnPoint", "cadPoint")
    Utils.TBNCreator(panEntities, "tbnSolid", "cadSolid")

    'Dimensiones
    Utils.tbnCreator(panDimensions, "tbnDimension_linear", "cadDimension_Linear")
    Utils.tbnCreator(panDimensions, "tbndimension_aligned", "caddimension_aligned")
    Utils.tbnCreator(panDimensions, "tbndimension_ang3pt", "caddimension_ang3pt")
    Utils.tbnCreator(panDimensions, "tbndimension_diameter", "caddimension_diameter")
    Utils.tbnCreator(panDimensions, "tbndimension_radius", "caddimension_radius")
    Utils.tbnCreator(panDimensions, "tbndimension_ordinate", "caddimension_ordinate")
    Utils.tbnCreator(panDimensions, "tbnArc_dimension", "cadArc_dimension")
    Utils.tbnCreator(panDimensions, "tbndimension_linear_horizontal", "cadDimension_Linear&1")
    Utils.tbnCreator(panDimensions, "tbndimension_linear_vertical", "cadDimension_Linear&2")
    Utils.tbnCreator(panDimensions, "tbndimension_baseline", "cadDimension_linear&20")
    Utils.tbnCreator(panDimensions, "tbndimension_continue", "cadDimension_linear&10")

    ' Bloques
    Utils.tbnCreator(panBlocks, "tbnBlocks", "cadblocks")
    Utils.tbnCreator(panBlocks, "tbnHatch", "cadhatch")
    Utils.tbnCreator(panBlocks, "tbnNewSheet", "new_sheet",, "icon:/32/page")
    Utils.tbnCreator(panBlocks, "tbnViewport", "cadViewport",, "icon:/32/draw-rectangle")

    'Tools
    Utils.tbnCreator(panTools, "tbnCopy", "cadcopy")
    Utils.tbnCreator(panTools, "tbnMove", "cadmove")
    Utils.tbnCreator(panTools, "tbnErase", "caderase")
    Utils.tbnCreator(panTools, "tbnRotate", "cadrotate")
    Utils.tbnCreator(panTools, "tbnStretch", "cadstretch")
    Utils.tbnCreator(panTools, "tbnScale", "cadscale")
    Utils.tbnCreator(panTools, "tbnFillet", "cadfillet")
    Utils.tbnCreator(panTools, "tbnChamfer", "cadchamfer")
    Utils.tbnCreator(panTools, "tbnExplode", "cadExplode")
    Utils.tbnCreator(panTools, "tbnTrim", "cadtrim")
    Utils.tbnCreator(panTools, "tbnArray", "cadarray")
    Utils.tbnCreator(panTools, "tbnBreak", "cadbreak")
    Utils.tbnCreator(panTools, "tbnDivide", "caddivide")
    Utils.tbnCreator(panTools, "tbnMirror", "cadMirror")
    Utils.tbnCreator(panTools, "tbnOffset", "cadoffset")

    ' Info
    Utils.tbnCreator(panInquiry, "tbnRuler", "cadRuler")
    Utils.tbnCreator(panInquiry, "tbnProtractor", "cadProtractor")
    Utils.tbnCreator(panInquiry, "tbnArea", "cadArea")
    Utils.tbnCreator(panInquiry, "tbnProperties", "properties")

End

Public Sub FillBlocks()

    Dim sFilename As String
    Dim imgPreview As Image
    Dim entScale As Float
    Dim entidad As Entity
    Dim sFActor As Float = 1.5
    Dim b As Block
    Dim iSize As Integer = 40
    Dim i, iRow, iCol As Integer

    GridView1.Clear
    GridView1.Columns.Count = (GridView1.W) / iSize ' deberia poder conocer el ancho del scrollview
    For i = 0 To GridView1.Columns.Count - 1
        GridView1.Columns[i].W = iSize
    Next
    GridView1.rows.Count = CInt(gcd.Drawing.Blocks.Count / GridView1.Columns.Count) + 1
    For i = 0 To GridView1.rows.Count - 1
        GridView1.rows[i].h = iSize
    Next

    'ListView1.Clear

    'ListView1.GridSize = iSize

    i = 0
    For Each b In gcd.Drawing.Blocks
        If Left(b.name, 1) = "_" Or Left(b.name, 1) = "*" Then Continue

        iRow = Int(i / GridView1.Columns.Count)
        iCol = i Mod GridView1.Columns.Count
        i += 1
        imgPreview = New Image(iSize, iSize, Color.Black)

        gcd.FitEntitiesToImage(b.entities, imgPreview, Config.WhiteAndBlack, 0)
        GridView1.Row = iRow
        GridView1.Column = iCol
        GridView1.Current.Picture = imgPreview.Picture
        GridView1.Current.Tag = b.handle
        'ListView1.Add(b.handle, "", imgPreview.Picture)

    Next

End

Public Sub togSnap_MouseDown()

    If Mouse.Right Then fPoiOptions.show

End

Public Sub GridView1_MouseWheel()

    GridView1.ScrollY += Mouse.Delta * 40
    'GridView1.Scroll(0, GridView1.ScrollYMouse.Delta * 40)

End


'' Llena la tabla de propiedades
Public Sub FillProperties(cEntities As Collection, Optional sFilter As String = "")


    Dim cTypes As New Collection
    Dim cProperties As New Collection
    'Dim cmbLayers As New ComboBox()
    Dim e As Entity
    Dim l As Layer, LastLayer As String
    Dim sv As String = "<< " & ("varies") & " >>"
    Dim sProp As Variant
    Dim i As Integer

    If cEntities.Count = 0 Then
        tblProperties.Clear
        Return
    Endif
    ' cmbLayers.Insert(sv)
    ' For Each l In gcd.Drawing.Layers
    '     cmbLayers.Insert(l.Name)
    ' Next



    sFilter = UCase(sFilter)

    ' RECOLECTO LAS PROPIEDADES EN UNA COLECCION
    For Each e In cEntities
        If sFilter <> "" And (sFilter <> e.Gender) Then Continue

        ' veo el tipo
        If Not cTypes.Exist(e.Gender) Then cTypes.Add(e.Gender, e.Gender)

        ' GENERAL
        AddPropToCol(cProperties, "layer", e.pLayer.Name)                               'LAYER
        AddPropToCol(cProperties, "color", e.Colour)                                    'COLOR
        AddPropToCol(cProperties, "linetype", e.LineType.Name)                          'LINETYPE
        AddPropToCol(cProperties, "linewidth", e.LineWidth)                             'LINEWIDTH

        ' GEOMETRY
        Select Case E.Gender
            Case "LINE", "LWPOLYLINE", "SOLID", "POLYLINE", "POLYLINE_2D", "SPLINE", "POINT", "RAY", "VERTEX", "VERTEX_2D"
                AddPropToCol(cProperties, "points", Utils.FloatToString(e.p))                                 'POINTS
            Case "CIRCLE", "ARC", "ELLIPSE"
                AddPropToCol(cProperties, "center", Utils.FloatToString(e.p))                                 'CENTER
                AddPropToCol(cProperties, "radius", e.fParam[0])                         'radius
                If e.Gender = "ARC" Then
                    AddPropToCol(cProperties, "start", e.fParam[1])                       'start
                    AddPropToCol(cProperties, "end", e.fParam[2])                         'end
                Endif
            Case "INSERT", "TEXT", "MTEXT"
                AddPropToCol(cProperties, "base point", Utils.FloatToString(e.p))                              'BASE POINTS
                If e.Gender = "INSERT" Then
                    AddPropToCol(cProperties, "scaleX", e.fParam[cadInsert.ipaEscX])
                    AddPropToCol(cProperties, "scaleY", e.fParam[cadInsert.ipaEscY])
                    AddPropToCol(cProperties, "rotation", e.fParam[cadInsert.ipaRotacion])
                Endif
            Case Like "*DIM"
                AddPropToCol(cProperties, "base point", Utils.FloatToString(e.p))                              'BASE POINTS
        End Select

        'CONTENTS
        Select Case E.Gender
            Case "TEXT"
                AddPropToCol(cProperties, "text", e.sParam[cadText.sdaText])               'TEXT
                AddPropToCol(cProperties, "style", e.sParam[cadText.sdaStyle])             'STYLE
            Case "MTEXT"
                AddPropToCol(cProperties, "text", e.sParam[cadmText.sdaText])               'TEXT
                AddPropToCol(cProperties, "style", e.sParam[cadMText.sdaStyle])             'STYLE
            Case "INSERT"
                AddPropToCol(cProperties, "block", e.pBlock.name)               'TEXT
        End Select

        ' FORMAT
        Select Case E.Gender
            Case "TEXT"
                AddPropToCol(cProperties, "vertical justification", e.fParam[cadText.ipaVertJustif])
                AddPropToCol(cProperties, "alignment", e.fParam[cadText.ipaAttchmPoint])
                AddPropToCol(cProperties, "style", e.sParam[cadText.sdaStyle])
            Case "MTEXT"
                AddPropToCol(cProperties, "text", e.sParam[cadmText.sdaText])               'TEXT
                AddPropToCol(cProperties, "style", e.sParam[cadMText.sdaStyle])             'STYLE
            Case "INSERT"
                AddPropToCol(cProperties, "block", e.pBlock.name)               'TEXT
        End Select




    Next

    cmbEntityType.Clear
    cmbEntityType.Add(("All types"))
    For Each sProp In cTypes
        cmbEntityType.Add(sProp)
    Next



    ' ARMO LA TABLA DE PROPIEDADES
    tblProperties.Rows.Count = cProperties.Count
    tblProperties.Columns.Count = 2
    For Each sProp In cProperties

        tblProperties[i, 0].Text = UCase$(Left(cProperties.Key, 1)) & Mid(cProperties.Key, 2)

        If TypeOf(sProp) = gb.String Then
            tblProperties[i, 1].Text = sProp
        Else If TypeOf(sProp) = gb.Float Then
            tblProperties[i, 1].Text = sProp
        Else If TypeOf(sProp) = gb.Object Then
            tblProperties[i, 1].Text = Utils.FloatToString(sProp)
        Else
            tblProperties[i, 1].Text = sProp

        End If


        tblProperties[i, 1].Font.Bold = True
        Inc i
    Next

    Return

End

'' agrego la propiedad a la coleccion si es que no existe (retorna True en este caso)
Public Function AddPropToCol(cProperties As Collection, sPropName As String, sValue As Variant, Optional sVariesText As String = "<< " & ("varies") & " >>") As Boolean

    If cProperties.Exist(sPropName) Then
        If sValue <> cProperties[sPropName] Then
            cProperties[sPropName] = sVariesText
            Return False
        End If
    Else
        cProperties.Add(sValue, sPropName)
        Return True

    Endif


End

Public Sub cmbEntityType_Click()

    If cmbEntityType.Index > 0 Then
        FillProperties(gcd.Drawing.SelectedEntities, cmbEntityType.Text)
    Else
        FillProperties(gcd.Drawing.SelectedEntities)
    End If

End

Public Sub tblProperties_Click()

    Dim s, sProp As String, iProp As Integer
    Dim sLayers, sLinetypes, sStyles, sDimStyles As New String[]
    Dim lay As Layer, lty As LineType, dst As DimStyle, sty As TextStyle
    Dim flxPoints As Float[]

    If tblProperties.Column = 0 Then tblProperties.Column = 1

    sProp = LCase(tblProperties[tblProperties.Row, 0].Text)

    ' lleno los combos de edicion
    For Each lay In gcd.Drawing.Layers
        sLayers.Add(lay.Name)
    Next

    For Each lty In gcd.Drawing.LineTypes
        sLinetypes.Add(lty.Name)
    Next

    For Each dst In gcd.Drawing.DimStyles
        sDimStyles.Add(dst.Name)
    Next
    For Each sty In gcd.Drawing.TextStyles
        sStyles.Add(sty.Name)
    Next


    Select Case sProp
        Case "color"
            iProp = fColors.ShowModal()
            If iprop >= 0 Then
                tblProperties[tblProperties.Row, 1].Text = iProp
                tblProperties[tblProperties.Row, 1].Tag = True
            End If

        Case "layer"
            tblProperties.Edit(sLayers, True)
        Case "linetype"
            tblProperties.Edit(sLinetypes, True)
        Case "dimstyle"
            tblProperties.Edit(sDimStyles, True)
        Case "style"
            tblProperties.Edit(sStyles, True)
        Case "points", "center", "base point"
            flxPoints = Utils.StringToFloatArray(tblProperties[tblProperties.Row, 1].Text)

            tblProperties[tblProperties.Row, 1].Tag = fPointsEdit.EditPoints(flxPoints)
        Case Else
            tblProperties.Edit()

    End Select


End

Public Sub tblProperties_Save(Row As Integer, Column As Integer, Value As String)

    Dim s, sProp As String

    sProp = LCase(tblProperties[Row, 0].Text)

    Select Case sProp




        Case Else
            tblProperties[row, Column].Text = value
            tblProperties[row, Column].Tag = value

    End Select



End



Public Sub splitterV_Resize()


    Config.SplitterV = splitterV.Layout


End

Public Sub splitterH_Resize()

    Config.SplitterH = splitterH.Layout

End

