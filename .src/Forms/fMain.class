' Gambas class file

'------------------------------------------------------------------------------

'Variables del formulario

Public CurrentFile As String

Public CursorX As Integer
Public CursorY As Integer

Public KeysAccumulator As String
Public TmrTicks As Integer

'Public SelectedWidth As Boolean

'Private PropertiesFlag As Boolean = False
Private PropertiesFlag As Boolean = True
Private RawFlag As Boolean = False

'variables de ambiente
Public flgShowInspector As Boolean = False
Public flgSearchingEntity As Boolean = False  ' impide cuellos de botellla
Public flgSearchingPOI As Boolean
Public flgShowingLayers As Boolean
Public flgNewPosition As Boolean        ' seteada cuando hay un cambio en pan o zoom

Public flgWheelCounter As Integer

Public $hDrawTimer As New Timer As "DrawTimer"
' Block insertion vars
Public fBlockScaleX As Float = 1
Public fBlockScaleY As Float = 1
Public fBlockDegRotation As Float = 0

Public GridSpacing As Float = 0.5
Public GridActive As Boolean           ' use with F7: 0 = no grid, 1 = dots, 2 = lines

Public Sub DrawTimer_Timer()

    Dim dx As Single, dy As Single
    Dim EjeX As Single, ejeY As Single, ejeZ As Single

    ' If mouDown Then
    '     If paneando Then
    '
    '         With modGraphics
    '             'ademas intento un zoom dinamico, si el mouse esta lejos del centro, atrae los graficos hacia el
    '             GLCam.StrafeRight((mouDownX - MouseX) * 0.001 * modgraphics.maxmax)
    '             GLCam.MoveUpward(-(mouDownY - Mousey) * 0.001 * modgraphics.maxmax)
    '             'Debug .pan.x, .pan.y, .escala
    '         End With
    '     Else If rotando Then
    '
    '         'veo para donde mueve el mouse con respenco a la posicion 2D del CG
    '
    '         dy = -(mouDownX - MouseX) * 0.075 '* mouDownXCG
    '         dx = -(mouDownY - MouseY) * 0.075 '* mouDownYCG
    '
    '         ' con esto la rotacion se hace de un eje a la vez
    '         If Abs(dy) > Abs(dx) Then
    '
    '             GLCam.RotateY(dy)
    '
    '         Else
    '
    '             GLCam.RotateX(dx)
    '
    '         End If
    '
    '     End If
    '
    '     'modGraphics.dibujar_estructura3D
    '
    '     mouDownX = Mouse.x
    '     mouDownY = Mouse.y
    '
    ' Else If mouWheel Then
    '
    '     GLCam.moveforward(mouDelta * modgraphics.maxmax / 20)
    '
    '     mouDelta = 0
    '     mouWheel = False
    '
    ' End If

    glarea1.Refresh
    If flgNewPosition Then
        clsEntities.CollectVisibleEntities
        flgNewPosition = False
    End If

End Sub

Public Sub Run() As Boolean

    ' acomodo el tamanio de los controles

    Me.tblLineWt.w = 128
    Me.tblLTypes.w = 128
    Me.mbtColors.w = 128
    'Me.mbtLayers.w = 128
    Me.cmbDimStyle.w = 128
    Me.grdLayers.w = 146
    'Me.tbnLayersOnScreen.w = 96

    PanelBlockFit.Visible = False 'ag = CStr(PanelBlockFit.h)
    'PanelBlockFit.h = 0

    fMain.grdLayers.Rows.Count = 1
    fMain.grdLayers.Columns.Count = 5
    'fMain.grdLayers.Rows[0].Height = 32
    fMain.grdLayers.Rows.Height = 28
    fMain.grdLayers[0, 1].Alignment = Align.Left
    fMain.grdLayers[0, 2].Alignment = Align.Left
    fMain.grdLayers[0, 3].Alignment = Align.Left
    fMain.grdLayers[0, 4].Alignment = Align.Left
    fMain.grdLayers.Columns[0].w = 18 ' color
    fMain.grdLayers.Columns[1].w = 18 ' color
    fMain.grdLayers.Columns[2].w = 18 ' color
    fMain.grdLayers.Columns[3].w = 18 ' color
    fMain.grdLayers.Columns[4].w = 72 ' color

    fLayersOnScreen.Move(Me.grdLayers.x, Me.grdLayers.y + Me.grdLayers.h + 1)

    ' tblLines.AddToolButton("tblLine",, Picture.Load(main.Params["Dirs/PNG", Application.Path &/ "png/48x48"] &/ "line.png"), "cadLine")
    ' tblLines.AddToolButton("tblLWPolyline",, Picture.Load(main.Params["Dirs/PNG", Application.Path &/ "png/48x48"] &/ "hexagon.png"), "cadlwpolyline")
    '
    ' tblLines.AddToolButton("tblText",, Picture.Load(main.Params["Dirs/PNG", Application.Path &/ "png/"] &/ "Copy.png"), "cadText")
    '
    ' ' Armo la barra Inquiry
    '
    ' tblInquiry.AddToolButton("tblArea", "A",, "cadarea")
    ' tblInquiry.AddToolButton("tblRuler", "R",, "cadruler")
    ' tblInquiry.AddToolButton("tblProtracto", "P",, "cadprotractor")

    Action_Activate("file_new")

    tmrAutosave.Delay = main.Params["/AutoSaveDelayMin", 15] * 1000 * 60
    tmrAutosave.Enabled = True

    Me.Show()
    gcd.DrawingReady = True

End

Public Function Action_Activate(sAction As String) As Boolean
    ' Acciones de los botones y los menús (para no repetir código)
    ' El string de la acción es una propiedad de cada botón o menú
    ' El código que se ejecuta lo hace dentro de la rutina llamada, nunca dentro de este mismo evento.

    Dim NewDrawing As Drawing
    Dim f, fDxf, fBak As String
    Dim fMinimal As String = "./minimal/minimal-2010.dxf"
    Dim fx As String[]
    Dim fbas As String
    Dim t As String
    Dim iColor, i As Integer
    Dim imgCirculito As Image
    Dim clsJob As String
    Dim d As Drawing
    Dim sActionParams As String[]

    Try Print Last.name

    Select Case LCase(sAction)

        Case "undo"
            gcd.CurrDrawing.uUndo.DoUndo()
            Regen
        Case "redo"
            gcd.CurrDrawing.uUndo.DoRedo()
            Regen
        Case "window_close"
            For i = 0 To gcd.Drawings.Count
                If gcd.Drawings[i] = gcd.CurrDrawing Then
                    gcd.Drawings.Remove(i)
                    If gcd.Drawings.Count > 0 Then
                        gcd.CurrDrawing = gcd.Drawings[0]
                        Redraw
                    Else

                        Action_Activate("file_new")
                    Endif
                    Break
                End If

            Next

        Case "window_closeall"
            gcd.Drawings.Clear
            Action_Activate("file_new")

        Case Like "windowchange_*"

            Dim sWName As String

            sWName = Mid(sAction, 14)

            For Each d In gcd.Drawings
                If sWName = d.FileName Then
                    gcd.CurrDrawing = d
                    gcd.UpdateLayersCombo
                    gcd.UpdateLineWtCombo
                    gcd.UpdateLineTypeCombo
                    gcd.UpdatDimTypeTypeCombo
                    Me.redraw
                    Me.Text = f

                    FillWindowMenu
                    Break
                Endif
            Next

        Case "file_quit"

            Me.Close
            Quit

        Case "file_new"

            NewDrawing = New Drawing
            gcd.Drawings.Add(NewDrawing)
            gcd.CurrDrawing = gcd.Drawings.Last
            gcd.CurrDrawing.FileName = main.dirTemplates &/ "drawing1.dxf"
            dxf.LoadFile(fMinimal, gcd.CurrDrawing.cModel)
            gcd.CurrDrawing.cEntities = gcd.CurrDrawing.cModel["ENTITIES"]
            gcd.CurrDrawing.cBlocks = gcd.CurrDrawing.cModel["BLOCKS"]
            gcd.CurrDrawing.cHeader = gcd.CurrDrawing.cModel["HEADER"]
            gcd.CurrDrawing.cLayers = gcd.CurrDrawing.cModel["TABLES"]["LAYER"]
            gcd.CurrDrawing.cLtypes = gcd.CurrDrawing.cModel["TABLES"]["LTYPE"]
            gcd.CurrDrawing.HandSeed = gcd.iHeader("$HANDSEED")
            gcd.ReadLTypes
            gcd.ReadLayers
            gcd.ReadStyles
            gcd.UpdateLayersCombo
            gcd.UpdateLineWtCombo
            gcd.UpdateLineTypeCombo
            gcd.UpdatDimTypeTypeCombo
            gcd.UpdateGraphics

            Me.Text = f

            FillWindowMenu

            ' Print Last.name
        Case "file_open"

            Dialog.Title = ("Select File")
            Dialog.Filter = ["*.dxf", "DXF Drawing exchange 2010", "*.dwg", "DWG AutoCAD Drawing file 2010"]
            Dialog.OpenFile(False)
            f = Dialog.Path


            'f = "/home/martin/GAUCHO-TESTING-V2000-online converter.dxf"

            If Exist(f) Then
                If Stat(f).Type = gb.File Then
                    Select Lower(File.Ext(f))
                        Case "dwg"

                            NewDrawing = New Drawing
                            gcd.Drawings.Add(NewDrawing)
                            gcd.CurrDrawing = gcd.Drawings.Last
                            gcd.CurrDrawing.FileName = f
                            dxf.LoadFile(fMinimal, gcd.CurrDrawing.cModel)

                            fMain.Mouse = Mouse.Wait
                            Application.Busy = 1
                            'fDxf = dxf.DWGtoDXF(f)
                            fDxf = gcd.ODA_DWGtoDXF(f)
                            gcd.CurrDrawing.RequiresFileRename = True

                            dxf.LoadFile(fDxf, gcd.CurrDrawing.cModel, False, False, False)
                            gcd.CurrDrawing.cEntities = gcd.CurrDrawing.cModel["ENTITIES"]
                            gcd.CurrDrawing.cBlocks = gcd.CurrDrawing.cModel["BLOCKS"]
                            gcd.CurrDrawing.cHeader = gcd.CurrDrawing.cModel["HEADER"]
                            gcd.CurrDrawing.cLayers = gcd.CurrDrawing.cModel["TABLES"]["LAYER"]
                            gcd.CurrDrawing.cLtypes = gcd.CurrDrawing.cModel["TABLES"]["LTYPE"]
                            gcd.CurrDrawing.HandSeed = gcd.iHeader("$HANDSEED")
                            gcd.ReadVars
                            gcd.ReadLTypes
                            gcd.ReadLayers
                            gcd.ReadStyles
                            gcd.UpdateLayersCombo
                            gcd.UpdateLineWtCombo
                            gcd.UpdateLineTypeCombo
                            gcd.UpdatDimTypeTypeCombo
                            gcd.UpdateGraphics

                            ' modelo recien cargado
                            cadZoomE.Start()                                ' por ahora mostramos el dibujo centrado, hasta q leamos el estado anterior

                            Me.Text = f

                            Application.Busy = 0
                            fMain.Mouse = Mouse.Arrow
                        Case "dxf"

                            NewDrawing = New Drawing
                            gcd.Drawings.Add(NewDrawing)
                            gcd.CurrDrawing = gcd.Drawings.Last
                            dxf.LoadFile(fMinimal, gcd.CurrDrawing.cModel)

                            gcd.CurrDrawing.FileName = f

                            gcd.CurrDrawing.RequiresFileRename = False

                            dxf.LoadFile(f, gcd.CurrDrawing.cModel, False, False, False)
                            gcd.CurrDrawing.cEntities = gcd.CurrDrawing.cModel["ENTITIES"]
                            gcd.CurrDrawing.cBlocks = gcd.CurrDrawing.cModel["BLOCKS"]
                            gcd.CurrDrawing.cHeader = gcd.CurrDrawing.cModel["HEADER"]
                            gcd.CurrDrawing.cLayers = gcd.CurrDrawing.cModel["TABLES"]["LAYER"]
                            gcd.CurrDrawing.cLtypes = gcd.CurrDrawing.cModel["TABLES"]["LTYPE"]
                            gcd.CurrDrawing.HandSeed = gcd.iHeader("$HANDSEED")
                            gcd.ReadVars
                            gcd.ReadLTypes
                            gcd.ReadLayers
                            gcd.ReadStyles
                            gcd.UpdateLayersCombo
                            gcd.UpdateLineWtCombo
                            gcd.UpdateLineTypeCombo
                            gcd.UpdateGraphics

                            cadZoomE.Start()                                ' por ahora mostramos el dibujo centrado, hasta q leamos el estado anterior

                            Me.Text = f

                    End Select
                Endif
            Endif

            FillWindowMenu

        Case "file_save"

            f = gcd.CurrDrawing.FileName

            fbas = File.Dir(f) &/ File.BaseName(f)
            fBak = "'" & fbas & ".bak'"
            If gcd.CurrDrawing.RequiresFileRename Then
                Me.Action_Activate("file_saveas")
                Return
            Else
                If Exist(f) Then
                    If Exist(fBak) Then Shell "rm " & fBak Wait
                    Shell "mv '" & f & "' '" & fbas & ".bak'" Wait
                End If

                If File.Ext(f) = "dxf" Then
                    Dxf.SaveFile(f, gcd.CurrDrawing.cModel)
                Else If File.Ext(f) = "dwg" Then
                    ' guardamos la version DXF en el dir adecuado, con el nombre elegido
                    't = main.dirDxfOut &/ Utils.FileWithoutExtension(Utils.FileFromPath(f)) & ".dxf"
                    t = Temp & ".dxf"
                    Dxf.SaveFile(t, gcd.CurrDrawing.cModel)
                    t = gcd.oda_dxftodwg(t)
                    ' como el proceso de grabado pudo resultar en error, chequeo la existencia primero

                    If Exist(t) Then Move t To f

                End If

            Endif

        Case "file_saveas"

            f = gcd.CurrDrawing.FileName
            fbas = File.Dir(f) &/ File.BaseName(f)
            fBak = "'" & fbas & ".bak'"

            Dialog.AutoExt = True
            Dialog.Filter = ["*.dxf", "DXF Drawing exchange 2010", "*.dwg", "DWG AutoCAD Drawing file 2010"]
            If Dialog.SaveFile() Then Return ' cancel saving

            f = Dialog.Path

            If Exist(f) Then
                If Message.Question(("The file exist"), ("Replace"), ("Cancel")) = 2 Then
                    f = ""
                Endif
            Endif

            If f = "" Then
                Print "Cancel"
            Else

                'If LCase(File.Ext(f)) <> "dxf" Then f &= ".dxf"
                If Exist(f) Then
                    If Exist(fBak) Then Shell "rm " & fBak Wait
                    Shell "mv '" & f & "' '" & fbas & ".bak'" Wait
                End If

                gcd.CurrDrawing.FileName = f
                gcd.CurrDrawing.RequiresFileRename = False
                Action_Activate("file_save")

                Me.Text = f

            Endif

        Case Like "color_*"

            iColor = CInt(Mid(sAction, 7))
            mbtColors.Text = "Color " & CStr(iColor) 'Me.mbtColors.Children[iColor].Text
            If iColor = 256 Then mbtColors.Text = "ByLayer"
            If iColor = 257 Then mbtColors.Text = "ByBlock"

            mbtColors.Picture = paintPlus.picCirculito(8, gcd.gColor[iColor], Color.ButtonForeground)

            gcd.CurrDrawing.CurrColor = iColor

            ' si tengo algo seleccionado, debo cambiar su color a este
            gcd.EditEntities("color", iColor)
            clsEntities.DeSelection()

        Case Like "cad*"

            ' actions, with & for additional parameters
            ' cadDimension_Linear&horizontal

            Dim o As Object, sRunWith As String, iParam As Integer, c As Class

            sActionParams = Split(sAction, "&")
            sRunWith = sActionParams[0]
            Try iParam = CInt(sActionParams[1])
            gcd.clsJobPrevious = gcd.clsJob

            o = Object.New(sRunWith)

            ' check if the class needs to be run trough other class
            If o.usewith = "" Then                        ' its a tool
                gcd.clsJob = o
                gcd.clsJob.start(iParam)

            Else                                           ' its propably an eentity

                gcd.clsJob = Object.New(o.usewith)
                gcd.clsJob.start(o, iParam)

            End If

        Case Like "layer_change_*"

            Dim sLayerName As String

            sLayerName = Mid(sAction, 14)

            ' mbtLayers.Text = sLayerName
            ' iColor = gcd.CurrDrawing.cLayers[sLayerName][dxf.codColor]
            ' mbtLayers.Picture = paintPlus.picCirculito(8, gcd.gColor[iColor], Color.ButtonForeground)

            ' informamos
            gcd.CurrDrawing.CurrLayer = gcd.GetLayer(sLayerName)

            ' si tengo algo seleccionado, debo cambiar su color a este
            gcd.EditEntities("layer", gcd.CurrDrawing.CurrLayer)
            clsEntities.DeSelection()

        Case Like "linewt_change_*"

            gcd.CurrDrawing.CurrLineWt = CInt(Mid(sAction, 15)) / 100

            ' si tengo algo seleccionado, debo cambiar su color a este
            gcd.EditEntities("linewt", gcd.CurrDrawing.CurrLineWt)
            clsEntities.DeSelection()

        Case Like "ltype_change_*"

            gcd.CurrDrawing.CurrLineType = gcd.FindLineType(Mid(sAction, 14))

            ' si tengo algo seleccionado, debo cambiar su color a este
            gcd.EditEntities("linetype", gcd.CurrDrawing.CurrLineType)
            clsEntities.DeSelection()

    End Select

End

Public Sub Form_Activate()

    GLplus.Init(glarea1)

End

Public Sub LeerRecientes()

    'TODO esto deberia estar en un ini
    ' obtengo los lastopen

    main.setting.lastopen1 = main.params["Files/LastOpen1", ""]
    main.setting.lastopen2 = main.params["Files/LastOpen2", ""]
    main.setting.lastopen3 = main.params["Files/LastOpen3", ""]
    main.setting.lastopen4 = main.params["Files/LastOpen4", ""]
    main.setting.lastopen5 = main.params["Files/LastOpen5", ""]

    If Exist(main.setting.lastopen1) Then

        mnuReciente1.Text = main.setting.lastopen1
        mnuReciente1.Visible = True
        'sep4.Visible = True

    Else
        mnuReciente1.Visible = 0
        'sep4.Visible = 0
        main.setting.lastopen1 = ""
    End If
    If Exist(main.setting.lastopen2) Then
        mnuReciente2.Text = main.setting.lastopen2
        mnuReciente2.Visible = True

    Else
        mnuReciente2.Visible = 0
        main.setting.lastopen2 = ""

    End If
    If Exist(main.setting.lastopen3) Then
        mnuReciente3.Text = main.setting.lastopen3
        mnuReciente3.Visible = True

    Else
        mnuReciente3.Visible = 0
        main.setting.lastopen3 = ""

    End If

    If Exist(main.setting.lastopen4) Then
        mnuReciente4.Text = main.setting.lastopen4
        mnuReciente4.Visible = True

    Else
        mnuReciente4.Visible = 0
        main.setting.lastopen4 = ""

    End If

    If Exist(main.setting.lastopen5) Then
        mnuReciente5.Text = main.setting.lastopen5
        mnuReciente5.Visible = True

    Else
        mnuReciente5.Visible = 0
        main.setting.lastopen5 = ""

    End If

End

Public Sub GuardarParametros()

    If main.setting.lastopen1 <> "" Then main.params["Files/LastOpen1"] = main.setting.lastopen1
    If main.setting.lastopen2 <> "" Then main.params["Files/LastOpen2"] = main.setting.lastopen2
    If main.setting.lastopen3 <> "" Then main.params["Files/LastOpen3"] = main.setting.lastopen3
    If main.setting.lastopen4 <> "" Then main.params["Files/LastOpen4"] = main.setting.lastopen4
    If main.setting.lastopen5 <> "" Then main.params["Files/LastOpen5"] = main.setting.lastopen5

End

Public Sub VerifLastOpen(sA_Abrir As String)

    Dim loTengo As Integer
    ' reacomodo los Recientes, de maanera SIMPLE

    ' primero veo si lo tengo
    loTengo = False
    If sA_Abrir = mnuReciente1.text Then loTengo = 1
    If sA_Abrir = mnuReciente2.text Then loTengo = 2
    If sA_Abrir = mnuReciente3.text Then loTengo = 3
    If sA_Abrir = mnuReciente4.text Then loTengo = 4
    If sA_Abrir = mnuReciente5.text Then loTengo = 5

    If Not lotengo Then
        ' desplazo todos los recientes hacia abajo
        main.setting.lastopen5 = main.setting.lastopen4
        main.setting.lastopen4 = main.setting.lastopen3
        main.setting.lastopen3 = main.setting.lastopen2
        main.setting.lastopen2 = main.setting.lastopen1
        main.setting.lastopen1 = sA_Abrir

        GuardarParametros
        LeerRecientes

    End If
    sA_Abrir = ""

End

Public Sub form_Close()

    Me.Close

    main.Terminate

End

Public Sub glarea1_Resize()

    GLplus.Resize(glarea1)

End

Public Sub GLArea1_draw()

    Dim iParent As Integer
    Dim i As Integer

    If Not gcd.DrawingReady Then Return

    gcd.drwDrawingClass = gcd.drwOpenGLClass

    gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)

    gl.LoadIdentity

    gl.Translatef(gcd.CurrDrawing.PanX, gcd.CurrDrawing.PanY, 0)

    gl.Scalef(gcd.CurrDrawing.ScaleZoom, gcd.CurrDrawing.ScaleZoom, 1)

    ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja primero

    ' Primero la grid
    ' DrawingAids.DrawGrid

    ' TEST
    Dim fArcParams As Float[]

    ' aqui podria usar una rutina de arco entre 3 puntos
    fArcParams = puntos.Arc3Point(0, 0, -100, 50, -300, 20)
    ' traslado el centro
    gl.Translatef(fArcParams[0], fArcParams[1], 0)
    glPlus.Arc(fArcParams[2], fArcParams[3], fArcParams[4] - fArcParams[3], Color.Blue, 1, 0)
    gl.Translatef(-fArcParams[0], -fArcParams[1], 0)
    fArcParams = Null


    If gcd.DrawBounds Then DrawingAids.DrawPolygons

    ' entidad resaltada
    If gcd.CurrDrawing.iEntity[3] >= 0 And gcd.CurrDrawing.iEntity[3] < gcd.CurrDrawing.arrEntities.Count Then

        ' si no esta seleccionada, la resalto
        'If Not arrEntities[iEntity[3]].Selected Then
        'iParent = clsEntities.GetParentBlock(gcd.CurrDrawing.iEntity[3]) ' esto verifica si tiene que resaltar el bloque completo
        iParent = gcd.CurrDrawing.iEntity[3]
        gcd.CurrDrawing.arrEntities[iParent].ClassHandler.DrawRemark(gcd.CurrDrawing.arrEntities[iParent])
        'End If

    End If
    DrawingAids.DrawCoordenadas

    DrawingAids.DibujaHelper

    For i = 0 To gcd.CurrDrawing.arrLayers.Max
        If gcd.CurrDrawing.arrLayers[i].Visible Then gl.CallList(gcd.CurrDrawing.arrLayers[i].glList)
    Next

    'gl.CallList(gcd.CurrDrawing.GlListAllEntities)

    ' POI dinamicos
    If gcd.CurrDrawing.flgShowPOIinfo Then

        Select gcd.CurrDrawing.iEntity[2]
            Case gcd.poiMidPoint
                glPlus.PolygonFilled([gcd.CurrDrawing.iEntity[0] - Metros(4), gcd.CurrDrawing.iEntity[1], gcd.CurrDrawing.iEntity[0], gcd.CurrDrawing.iEntity[1] + Metros(4), gcd.CurrDrawing.iEntity[0] + Metros(4), gcd.CurrDrawing.iEntity[1], gcd.CurrDrawing.iEntity[0], gcd.CurrDrawing.iEntity[1] - Metros(4)], Color.Blue, Color.Green)
            Case gcd.poiQuadrant
                glPlus.PolygonFilled([gcd.CurrDrawing.iEntity[0] - Metros(6), gcd.CurrDrawing.iEntity[1], gcd.CurrDrawing.iEntity[0], gcd.CurrDrawing.iEntity[1] + Metros(6), gcd.CurrDrawing.iEntity[0] + Metros(6), gcd.CurrDrawing.iEntity[1], gcd.CurrDrawing.iEntity[0], gcd.CurrDrawing.iEntity[1] - Metros(6)], Color.Cyan, Color.Cyan)

            Case -1
                ' nada
            Case gcd.poiCenter, gcd.poiBasePoint

                glPlus.Circle([gcd.CurrDrawing.iEntity[0], gcd.CurrDrawing.iEntity[1]], Metros(4), Color.Cyan, True, False)
                'glPlus.Rectangle2D(gcd.CurrDrawing.iEntity[0] - Metros(4), gcd.CurrDrawing.iEntity[1] - Metros(4), Metros(8), Metros(8), Color.Blue,,,, Color.Blue, 1, 1)

            Case Else
                glPlus.Rectangle2D(gcd.CurrDrawing.iEntity[0] - Metros(4), gcd.CurrDrawing.iEntity[1] - Metros(4), Metros(8), Metros(8), Color.Blue,,,, Color.Blue, 1, 1)

        End Select

    Endif

    gcd.clsJob.Draw()

    ' Debug "redraw"

End

' Protocolo del Mouse
'--------------------

' Rigth Clicks  ---> No son enviados a las clases herramienta/entidad; son procesados por FCAD como accion es que terminan o empiezan algo. Tanto MouseDown/Up
'   MouseDown ---------> Lo ignoro
'   MouseUp -----------> A-Trabajo activo? Mando señal de Finalizar/Cancelar ya mismo
'                        B- Click en objeto: muestro las propiedades frmPropiedades (aun no implementado)
'                           Click en el aire: Equivale a <enter> que repite el trabajo anterior, si lo hubo.

' Wheel -----------> Es utilizado como zoom. No es enviado a las clases.

' MouseMove--------> 1-Trabajo activo? --> Se envia el evento
'                    2-Paneando? Se actualizan los valores de PanX/Y y se refresca la pantalla

' Left Clicks
'   MouseDown------> 1- Trabajo activo? -> Se envia a la clase que trabaja gcd.clsJobs si hay una activa. Sino se analziza donde fue el click.
'                    2- no hay trabajos:
'                           2.a- Click en el aire  --> o Paneo, segun el boton que este presionado.
'                           2.b- Click en objeto   --> De/selecciono el objeto
'
'
'
'   MouseUp-------->1-Trabajo activo: ---> envio evento
'
'

Public Sub GLArea1_MouseDown()

    If Mouse.Right Then Return  'handled in MouseUp

    If Mouse.Middle Then Return  'handled in MouseUp

    Select gcd.clsJob.gender

        Case "Default"                                                  ' 1. Seleccionando

            gcd.clsJob.mouseDown(mouse.x, mouse.y)                               '    -> envio el evento a la clase default

        Case "Builder"                                                  ' 2.Construyendo una entidad

            gcd.clsJob.mouseDown(mouse.x, mouse.y)                                   '      y envio el evento a la clase

        Case Else

            gcd.clsJob.mouseDown(mouse.x, mouse.y)                                   ' dispatch event to the Job

    End Select

    redraw

End

Public Sub GLArea1_DblClick()

    Dim k As Single
    Dim e As Entity
    Dim te As Entity

    CursorX = mouse.x
    CursorY = mouse.y

    Select gcd.clsJob.gender

        Case "Default"                                                  ' 1. Seleccionando

            If Not Me.flgSearchingPOI Then
                gcd.CurrDrawing.iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
            Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

                gcd.CurrDrawing.iEntity[0] = Xreal(mouse.x)
                gcd.CurrDrawing.iEntity[1] = Yreal(mouse.y)
                gcd.CurrDrawing.iEntity[2] = -1                 ' POI type
                gcd.CurrDrawing.iEntity[3] = -1                 ' Hooked entity

            End If

            If gcd.CurrDrawing.iEntity[3] >= 0 Then

                'Stop
                ' I comment the abobe line because its stop my tool also. What is the idea whit stop?
                ' TINCHO aca podes lanzar tu editor de texto u otras propiedades
                k = gcd.CurrDrawing.iEntity[3]
                e = gcd.CurrDrawing.arrEntities[k]

                Select e.Gender
                    Case "Text"

                End Select
            Endif
            '======================= otra Tool
        Case Else

    End Select

End

Public Sub GLArea1_MouseMove()

    'Debug "Pan", gcd.CurrDrawing.PanX, gcd.CurrDrawing.Pany
    'Debug "MouseMove event", Rnd(0, 1000)
    CursorX = mouse.x
    CursorY = mouse.y
    'Me.flgSearchingEntity = True ' FIXME: poner en false despues de reparar
    'Me.flgSearchingPOI = True

    Select gcd.clsJob.gender

        Case "Default"                                                  ' 1. Seleccionando
            gcd.clsJob.MouseMove(mouse.x, mouse.y) ' dispatch event to the Job
            If gcd.clsJob.poichecking Then
                If gcd.clsJob.iEntityForEdit < 0 Then
                    If Not Me.flgSearchingEntity Then
                        gcd.CurrDrawing.iEntity[2] = -1
                        gcd.CurrDrawing.iEntity[3] = clsMouseTracking.CheckAboveEntity(Xreal(mouse.x), Yreal(mouse.Y), Metros(8))
                        If gcd.CurrDrawing.iEntity[3] <> gcd.CurrDrawing.iLastEntity Then
                            gcd.CurrDrawing.iLastEntity = gcd.CurrDrawing.iEntity[3]

                        End If

                    Else
                        'Debug "No puedo buscar entidades"
                    End If
                Else
                    If Not Me.flgSearchingPOI Then
                        gcd.CurrDrawing.iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
                    Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

                        gcd.CurrDrawing.iEntity[0] = Xreal(mouse.x)
                        gcd.CurrDrawing.iEntity[1] = Yreal(mouse.y)
                        gcd.CurrDrawing.iEntity[2] = -1                 ' POI type
                        gcd.CurrDrawing.iEntity[3] = -1                 ' Hooked entity

                    End If
                End If
            End If

            If flgShowInspector Then

                If gcd.CurrDrawing.iEntity[3] >= 0 Then

                    FInspector.Run(gcd.CurrDrawing.arrEntities[gcd.CurrDrawing.iEntity[3]])
                Else
                    FInspector.Close

                Endif
            End If

            '======================= otra Tool
        Case Else

            If gcd.clsJob.poichecking Then
                If Not Me.flgSearchingPOI Then
                    gcd.CurrDrawing.iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
                Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

                    gcd.CurrDrawing.iEntity[0] = Xreal(mouse.x)
                    gcd.CurrDrawing.iEntity[1] = Yreal(mouse.y)
                    gcd.CurrDrawing.iEntity[2] = -1                 ' POI type
                    gcd.CurrDrawing.iEntity[3] = -1                 ' Hooked entity

                End If

            End If

            If gcd.clsJob.EntityChecking Then
                If Not Me.flgSearchingEntity Then
                    gcd.CurrDrawing.iEntity[3] = clsMouseTracking.CheckAboveEntity(Xreal(mouse.x), Yreal(mouse.Y), Metros(8))
                End If
            End If

            gcd.CurrDrawing.flgShowPOIinfo = True

            DrawingAids.Helper.dX = 15
            DrawingAids.Helper.dY = 15
            DrawingAids.Helper.fColor = Color.DarkBlue
            gcd.clsJob.MouseMove(mouse.x, mouse.y) ' dispatch event to the Job

    End Select

    Redraw

End

Public Sub GLArea1_MouseUp()
    ' ex Public Sub drwArea_MouseUp()

    ' "Los IF son mas rapidos" - Autor Anonimo

    ' los rigth clicks se manejan en FCAD , ni las herramientas ni las entidades los necesitan
    If Mouse.Right Then                ' rigth clicks means finish what you're doing rigth now and go back to the previous Job
        ' the Finish() sub will do this in a good manner
        If gcd.clsJob.gender = "Builder" Then

            gcd.clsJob.KeyText("U")

        Else If gcd.clsJob.gender = "Default" Then

            gcd.clsJob = gcd.clsJobPrevious
            gcd.clsJob.Start()

        Else    ' es una tool

            gcd.clsJob.finish
            gcd.clsJobPrevious = gcd.clsJob
            gcd.clsJob = clsDefaultJob

        Endif

    Else If Mouse.Left Then

        gcd.clsJob.MouseUp(mouse.x, mouse.y)

    Else If Mouse.Middle Then

        If gcd.clsJob.gender <> "Pan" Then
            gcd.clsJobPreZoom = gcd.clsJob
            gcd.clsJob = cadPan
            gcd.clsJob.Start()

        Else

            gcd.clsJob = gcd.clsJobPreZoom

        End If

    End If

    redraw

End

Public Function Xreal(ScreenX As Float) As Float

    Return Metros((screenx - glarea1.w / 2 - gcd.CurrDrawing.PanX))

End

Public Function Yreal(ScreenY As Float) As Float

    Return Metros((-ScreenY + glarea1.h / 2 - gcd.CurrDrawing.PanY))

End

Public Function XPix(X As Float) As Float

    'Return Metros((screenx - glarea1.w / 2 - gcd.CurrDrawing.PanX))
    Return Me.Pixels(X) + glarea1.w / 2 + gcd.CurrDrawing.PanX

End

Public Function YPix(Y As Float) As Float

    'Return Metros((-ScreenY + glarea1.h / 2 - gcd.CurrDrawing.PanY))
    Return -(Me.Pixels(Y) - glarea1.h / 2 + gcd.CurrDrawing.PanY)

End

Public Function Pixels(distancia As Float) As Float  ' converts meters to pixels
    ' transforma Metros en Pixeles sin tener en cuenta el Pan

    Return distancia * gcd.CurrDrawing.ScaleZoom

End

Public Function Metros(pixeles As Integer) As Float  ' converts pixels to meters

    Return pixeles / gcd.CurrDrawing.ScaleZoom

End

Public Function Near(xyzReal As Float) As Float
    ' return the nearest point to the grid
    ' this is a world to world points (not pixels)

    ' Example:
    ' if                    GridSpacing = 0.2
    ' we pass               xyzReal = 1.35
    ' function will give    NearReal = 1.40

    Dim n As Integer, r As Float

    If Not Gridactive Then Return xyzReal

    r = xyzReal / GridSpacing
    n = Int(r)
    r = r - Int(r)

    If r > 0.5 Then n += 1

    Return n * GridSpacing

End

' El objetivo es que el zoom dinamico se haga manteniendo el dibujo que esta en la pos del mouse
Public Sub GLArea1_MouseWheel()

    Dim px, py, dx, dy, factor As Float
    ' chequeamos si vale la pena seguir dibujando la grid, o sea, menos de 3 pixels
    ' Inc flgWheelCounter
    ' Debug "Mouse weel", flgWheelCounter

    If Pixels(fmain.GridSpacing) < 5 Then fmain.GridActive = False Else fmain.GridActive = True

    px = Xreal(Mouse.x) ' posicion real en donde esta el mouse, previo al zoom
    py = Yreal(Mouse.y)

    ' TODO: , redondear para que la escala sea 1:100 1:75 1:50 etc

    factor = (1 + 0.075 * Mouse.Delta)

    gcd.CurrDrawing.ScaleZoom = gcd.CurrDrawing.ScaleZoom * factor

    dx = Xreal(Mouse.x) ' posicion real en donde esta el mouse, posterior al zoom
    dy = Yreal(Mouse.y)

    ' pero con ciertos limites TODO: imponer
    ' If ScaleZoom < 0.001 Then ScaleZoom = 0.001
    ' If ScaleZoom > 50 Then ScaleZoom = 50

    ' nuevo metodo (el Pan esta en pixels)
    gcd.CurrDrawing.PanX += pixels(dx - px)
    gcd.CurrDrawing.PanY += pixels(dy - py)

    flgNewPosition = True

    redraw 'glarea1.Refresh

    ' despues de actualizar la pantalla, recolectamos las entidades visibles

    ' Dec flgWheelCounter

End

Public Sub redraw()

    $hDrawTimer.Trigger
    Wait 0.001

End

'' Regenera las listas de OpenGL
Public Sub Regen()

    'clsEntities.glGenDrawListLAyers2
    clsEntities.glGenDrawList
    clsEntities.glGenDrawListSel
    redraw

End

Public Sub Form_KeyPress()

    Dim com As Variant
    Dim umx As Integer     '' Index in undo array
    Dim uEnty As Entity    '' Undo entity
    Dim aEnty As Entity    '' Actual entity
    Dim imx As Integer     '' Index in Entities array
    Dim SelectMode As Boolean

    ' Print Key.Code
    Dim t As Float = Timer

    Select Key.Code

        Case Key.Enter, Key.Return
            Debug KeysAccumulator

            Form_Activate()

            gcd.clsJob.KeyText(KeysAccumulator)
            KeysAccumulator = ""

        Case Key.f2
            Stop

        Case Key.f6

            If gcd.DrawBounds = True Then
                gcd.DrawBounds = False
            Else
                gcd.DrawBounds = True
            Endif
            ' btnBounds.Value = gcd.DrawBounds

        Case Key.BackSpace

            KeysAccumulator = Left(KeysAccumulator, -1)

        Case Key.f8

            Debug "Entidades transferidas en  ", Timer - t

            ' If btnOrtho.Value = False Then
            '   gcd.Orthogonal = True
            ' Else
            '   gcd.Orthogonal = False
            ' Endif

            ' btnOrtho.Value = gcd.Orthogonal

        Case Key.f7
            ' If btnGrid.Value = False Then
            '   puntos.Gridactive = True
            ' Else
            '   puntos.Gridactive = False
            ' Endif
            ' btnGrid.Value = puntos.Gridactive

        Case Key.F11

        Case Key.Esc

            If gcd.clsJob.gender = "Builder" Then

                gcd.clsJob.KeyText("U")

            Else If gcd.clsJob.gender = "Default" Then

                gcd.clsJob = gcd.clsJobPrevious
                gcd.clsJob.Start()

            Else    ' es una tool

                gcd.clsJob.finish
                gcd.clsJobPrevious = gcd.clsJob
                gcd.clsJob = clsDefaultJob

            Endif

            ' SelectionRefresh()

        Case Key.Space
            Stop Event

        Case Key.Del
            gcd.clsJob.KeyText("Erase")

        Case Key.ControlKey
            KeysAccumulator = "Function"

        Case Else
            ' A GOOD KEY
            If InStr(KeysAccumulator, "Function") > 0 Then

                ' Select Key.Code
                '   Case Asc("1") ' Properties
                '
                '     Select PropertiesFlag
                '       Case 1 ' Tools
                '         PropertiesFlag = 2
                '         pnlProperties.Visible = True
                '         pnlIcons.Visible = False
                '         'btnSelectionMode.Value = False
                '       Case 2 ' Props
                '         PropertiesFlag = 0
                '         pnlProperties.Visible = False
                '         pnlIcons.Visible = False
                '         'btnSelectionMode.Value = True
                '
                '       Case Else ' Invisible
                '         PropertiesFlag = 1
                '         pnlProperties.Visible = False
                '         pnlIcons.Visible = True
                '
                '     End Select
                '
                '     If PropertiesFlag = False Then
                '       pnlProperties.Visible = True
                '       PropertiesFlag = True
                '       pnlIcons.Visible = False
                '       btnSelectionMode.Value = False
                '     Else
                '       pnlProperties.Visible = False
                '       PropertiesFlag = False
                '       pnlIcons.Visible = True
                '       btnSelectionMode.Value = True
                '     Endif
                '
                '   Case Asc("2") ' Layers
                '
                '     'Case Asc("3") ' Blocks
                '
                '     'Case Asc("4...") ' More...
                '     'KeysAccumulator &= "-" & Key.Text
                '     'Case Else
                '     '    KeysAccumulator = ""
                '     'pnlProperties.Visible = False
                '     'pnlDebug.Visible = False
                '
                '   Case Asc("3") ' Raw properties for debuging
                '     If RawFlag = False Then
                '       pnlRaw.Visible = True
                '       RawFlag = True
                '     Else
                '       pnlRaw.Visible = False
                '       RawFlag = False
                '     Endif
                '
                '   Case Asc("a"), Asc("A") ' Select/Unselect All
                '     SelectMode = True
                '     For Each aEnty In gcd.CurrDrawing.arrEntities
                '       If aEnty.Selected Then
                '         SelectMode = False
                '         Break
                '       Endif
                '     Next
                '
                '     If SelectMode Then
                '       For Each aEnty In gcd.CurrDrawing.arrEntities
                '         If aEnty.Selected = False Then
                '           aEnty.Selected = True
                '         Endif
                '       Next
                '     Else
                '       For Each aEnty In gcd.CurrDrawing.arrEntities
                '         If aEnty.Selected Then
                '           aEnty.Selected = False
                '         Endif
                '       Next
                '     Endif
                '     fMain.regen
                '
                '   Case Asc("z"), Asc("Z") ' Undo
                '
                '     If gcd.CurrDrawing.arrUndo.Count > 0 Then
                '       umx = gcd.CurrDrawing.arrUndo.Max
                '
                '       uEnty = gcd.CurrDrawing.arrUndo[umx]
                '       For Each aEnty In gcd.CurrDrawing.arrEntities
                '         If aEnty.Handle = uEnty.Handle Then
                '           gcd.CurrDrawing.arrEntities.Remove(imx, 1)
                '           gcd.CurrDrawing.arrEntities.Add(uEnty, imx)
                '           gcd.CurrDrawing.arrUndo.Remove(umx, 1)
                '           fMain.regen
                '           'gcd.Redraw
                '           Break
                '         Endif
                '         Inc imx
                '       Next
                '
                '     Endif
                '   Case Else
                '     KeysAccumulator = ""
                '
                ' End Select

            Else
                KeysAccumulator &= Key.Text
                DrawingAids.ErrorMessage = ""
            Endif

    End Select

    DrawingAids.DibujaHelper

End

Public Sub tbnOrtho_Click()

    gcd.Orthogonal = tbnOrtho.value
    If tbnOrtho.Value Then
        tbnOrtho.foreground = Color.Blue
        tbnOrtho.Font.Bold = True
    Else
        tbnOrtho.foreground = Color.Buttonforeground
        tbnOrtho.Font.Bold = False
    Endif

End

Public Sub tbnSnap_Click()

    If tbnSnap.Value Then
        gcd.SnapMode = gcd.SnapModePrev
        tbnSnap.foreground = Color.DarkGreen
        tbnSnap.Font.Bold = True
    Else
        gcd.SnapModePrev = gcd.SnapMode
        gcd.SnapMode = -1
        tbnSnap.foreground = Color.Buttonforeground
        tbnSnap.Font.Bold = False
    Endif

End

Public Sub tbnGrid_Click()

    If tbnGrid.Value Then
        gcd.GridMode = gcd.GridModePrev
        tbnGrid.foreground = Color.DarkGray
        tbnGrid.Font.Bold = True
    Else
        gcd.GridModePrev = gcd.GridMode
        gcd.GridMode = -1
        tbnGrid.foreground = Color.Buttonforeground
        tbnGrid.Font.Bold = False
    Endif

End

Public Sub lblCommand_KeyPress()

    ' las teclas que no procese fMain sera procesadas aqui
    KeysAccumulator &= Key.Text

    lblCommand.Text = ""

End

' Public Sub tbLayerForm_Click()
'
'     fLayersOnScreen.Move(tbLayerForm.ScreenX, tbLayerForm.ScreenY + tbLayerForm.h)
'     fLayersOnScreen.Show()
'
' End

Public Sub tbnOrtho4_Click()

    Me.flgShowInspector = tbnOrtho4.Value
    If Me.flgShowInspector = False Then
        Try fInspector.Close
    Endif

End

Public Sub grdLayers_Click()

    If flgShowingLayers Then
        fLayersOnScreen.Hide
        flgShowingLayers = False

    Else
        If grdLayers.Column = 1 Then ' Visibility
            gcd.CurrDrawing.CurrLayer.Visible = Not gcd.CurrDrawing.CurrLayer.Visible

            If gcd.CurrDrawing.CurrLayer.Visible Then grdLayers[0, 1].Picture = fLayersOnScreen.picVisibleOn Else grdLayers[0, 1].Picture = fLayersOnScreen.picVisibleOff

        Else If grdLayers.Column = 2 Then ' frozen
            gcd.CurrDrawing.CurrLayer.Frozen = Not gcd.CurrDrawing.CurrLayer.Frozen

            If gcd.CurrDrawing.CurrLayer.Frozen Then grdLayers[0, 2].Picture = fLayersOnScreen.picFrozenOn Else grdLayers[0, 2].Picture = fLayersOnScreen.picFrozenOff

        Else If grdLayers.Column = 3 Then ' lock
            gcd.CurrDrawing.CurrLayer.Locked = Not gcd.CurrDrawing.CurrLayer.Locked

            If gcd.CurrDrawing.CurrLayer.Locked Then grdLayers[0, 3].Picture = fLayersOnScreen.picLockedOn Else grdLayers[0, 3].Picture = fLayersOnScreen.picLockedOff

        Else
            fLayersOnScreen.Move(grdLayers.ScreenX, grdLayers.ScreenY + grdLayers.h + 1)
            flgShowingLayers = True
            fLayersOnScreen.Show()
        End If
    End If

End

Public Sub FillWindowMenu()

    Dim d As Drawing
    Dim mItem As Menu

    mnuWindow.Children.Clear

    For Each d In gcd.Drawings
        mItem = New Menu(mnuWindow)
        mItem.Text = d.FileName
        If d = gcd.CurrDrawing Then mItem.Checked = True Else mItem.Checked = False
        mItem.Action = "windowchange_" & d.FileName
    Next

    mItem = New Menu(mnuWindow)
    mItem.Text = "" ' separador

    ' y ahora agrego dos
    mItem = New Menu(mnuWindow)
    mItem.Text = ("Close")
    mItem.Action = "window_close"

    mItem = New Menu(mnuWindow)
    mItem.Text = ("Close all")
    mItem.Action = "window_closeall"

End

Public Sub cmbDimStyle_Click()

    gcd.CurrDrawing.CurrDimStyle = gcd.FindStyle(cmbDimStyle.Text)

End

Public Sub ToggleButton2_Click()

    If Not ToggleButton2.Value Then
        ToggleButton2.Tag = CStr(ToggleButton2.Parent.h)
        ToggleButton2.Parent.h = ToggleButton2.H
    Else

        ToggleButton2.Parent.h = CInt(ToggleButton2.tag)
    End If

End

Public Sub ToggleButton1_Click()

    If Not ToggleButton1.Value Then
        ToggleButton1.Tag = CStr(ToggleButton1.Parent.h)
        ToggleButton1.Parent.h = ToggleButton1.H
    Else

        ToggleButton1.Parent.h = CInt(ToggleButton1.tag)
    End If

End

Public Sub ToggleButton3_Click()

    If Not ToggleButton3.Value Then
        ToggleButton3.Tag = CStr(ToggleButton3.Parent.h)
        ToggleButton3.Parent.h = ToggleButton3.H
    Else

        ToggleButton3.Parent.h = CInt(ToggleButton3.tag)
    End If

End

Public Sub Panel10_MouseDown()

End

Public Sub ToggleButton4_Click()

    If Not ToggleButton4.Value Then
        ToggleButton4.Tag = CStr(ToggleButton4.Parent.h)
        ToggleButton4.Parent.h = ToggleButton4.H
    Else

        ToggleButton4.Parent.h = CInt(ToggleButton4.tag)
    End If

End

Public Sub ListView1_Click()

End

Public Sub DirView1_Click()

    Dim sFilename As String
    Dim imgPreview As Image
    Dim cModelPreview As Collection
    Dim entyBlock As New Entity[]
    Dim flxLimits As New Float[]
    Dim entScale As Float
    Dim entidad As Entity
    Dim sFActor As Float = 1.5

    ListView1.Clear
    For Each sFilename In Dir(DirView1.Current, "*.dxf")
        imgPreview = New Image(80, 80, Color.Black)
        cModelPreview = New Collection
        entyBlock.Clear
        entyBlock = New Entity[]
        Dxf.LoadFile(DirView1.Current &/ sFilename, cModelPreview, True, True, True)         ' cargo la entidad

        gcd.ImpEnty6(cModelPreview["ENTITIES"], entyBlock)
        For Each entidad In entyBlock
            entidad.pLayer = gcd.CurrDrawing.CurrLayer
        Next
        clsEntities.BuildPoi(entyBlock)
        If entyBlock.Count > 0 Then
            flxLimits = clsEntities.ComputeLimits(entyBlock)                    ' computo el tamaño de la entidad, y luego determino la escala

            If Abs(flxLimits[2] - flxLimits[0]) > Abs(flxLimits[3] - flxLimits[1]) Then

                entScale = imgPreview.w / Abs(flxLimits[2] - flxLimits[0]) / sFActor
                'entScale = Abs(flxLimits[2] - flxLimits[0]) / imgPreview.h '/ 1.5

            Else

                entScale = imgPreview.h / Abs(flxLimits[3] - flxLimits[1]) / sFActor
                'entScale = Abs(flxLimits[3] - flxLimits[1]) / imgPreview.w '/ 1.5

            Endif

            Paint.Begin(imgPreview)

            Paint.Translate(imgPreview.w / 2 - (flxLimits[2] + flxLimits[0]) / 2 / entScale * sFActor, imgPreview.h / 2 + (flxLimits[3] + flxLimits[1]) / 2 / entScale * sFActor)
            'Paint.Translate(0, -flxLimits[3])
            Paint.Scale(entScale, -entScale)
            For Each entidad In entyBlock
                entidad.ColorToPaint = gcd.flgWhiteAndBlack
                entidad.LineWidth = 1 / entscale '* imgPreview.w / 10

                entidad.LineType = gcd.CurrDrawing.CurrLineType
                entidad.ClassHandler.draw2(entidad)
            Next
            Paint.End

        End If

        ListView1.Add(Left$(sFilename, -4), Left$(sFilename, -4), imgPreview.Picture)

    Next

End

Public Sub ListView1_DblClick()

    Dim sFilename As String
    Dim imgPreview As Image

    Dim entyBlock As New Entity[]
    Dim flxLimits As New Float[]
    Dim entScale As Float
    Dim aLayer As New Layer
    Dim entidad As Entity
    Dim sFActor As Float = 1.5

    sFilename = DirView1.Current &/ ListView1.Current.Text & ".dxf"

    ' For Each entidad In entyBlock
    '     entidad.pLayer = aLayer
    ' Next
    ' clsEntities.BuildPoi(entyBlock)

    PanelBlockFit.Visible = True
    ListView1.Visible = False

    gcd.clsJobPrevious = gcd.clsJob
    gcd.clsJob = clsBlocks
    gcd.clsJob.Start(sFilename)

    '

End

Public Sub ListView1_DragMove()

    If Mouse.Left Then
        ListView1.Drag(ListView1.Current.Picture.Image)
    Endif

End

Public Sub ListView1_Drag()

    Stop

End

Public Sub ListView1_DragLeave()

    Stop

End

Public Sub ListView1_Drop()

    Stop

End

Public Sub tmrAutosave_Timer()

    ' el autosave funciona solo si guarde antes, o sea si el dibujo tiene nombre
    ' ademas se guarda solo en formato dxf, para acelerar el proceso

    If Not gcd.CurrDrawing.RequiresFileRename Then
        If gcd.CurrDrawing.RequiresSaving Then
            If Dxf.SaveFile(gcd.CurrDrawing.FileName & ".Autosave", gcd.CurrDrawing.cModel) < 0 Then
                Print "Autosave error"
            Else
                Print ("Autosaved to ") & gcd.CurrDrawing.FileName & ".Autosave"
            Endif
        End If
    End If

End
