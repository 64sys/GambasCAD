' Gambas class file

'------------------------------------------------------------------------------

'Variables del formulario
'Public CurrentDrawing As FCAD                '' CAD Editor

Public CurrentForm As Form
Public CurrentFile As String

Public CursorX As Integer
Public CursorY As Integer

Public KeysAccumulator As String
Public TmrTicks As Integer

Public SelectingColor As Boolean    '' Selecting Color
Public CurrentColor As Integer
Public imgColor As Image

Public SelectingLayer As Boolean    '' Selecting Layer
Public CurrentLayer As String = "0"

Public SelectingLtype As Boolean    '' Selecting Linetype
Public CurrentLtype As Integer

Public SelectingWidth As Boolean    '' Selecting width
Public CurrentWidth As Integer

Public EditingText As Boolean       '' Editing Text value
Public CurrentText As String

'Public SelectedWidth As Boolean

'Private PropertiesFlag As Boolean = False
Private PropertiesFlag As Boolean = True
Private RawFlag As Boolean = False

'variables de ambiente
Public flgShowInspector As Boolean = True
Public flgSearchingEntity As Boolean = False  ' impide cuellos de botellla
Public flgSearchingPOI As Boolean


Public Sub Run() As Boolean

  Return Not Me.ShowModal()

End

Public Function Action_Activate(cAction As String) As Boolean
  ' Acciones de los botones y los menús (para no repetir código)
  ' El string de la acción es una propiedad de cada botón o menú
  ' El código que se ejecuta lo hace dentro de la rutina llamada, nunca dentro de este mismo evento.

  Print Last.name

  Select Case cAction

    Case "mFileImport"

      ' Print Last.name


  End Select

End



Public Sub Form_Activate()

  GLplus.Init(glarea1)

End

Public Sub glarea1_Resize()

  GLplus.Resize(glarea1)

End

Public Sub GLArea1_draw()

  Dim iParent As Integer

  If Not gcd.DrawingReady Then Return

  gcd.drwDrawingClass = gcd.drwOpenGLClass

  gl.Clear(gl.DEPTH_BUFFER_BIT Or gl.COLOR_BUFFER_BIT)

  gl.LoadIdentity

  gl.Translatef(gcd.CurrentDrawing.PanX, gcd.CurrentDrawing.PanY, 0)

  gl.Scalef(gcd.CurrentDrawing.ScaleZoom, gcd.CurrentDrawing.ScaleZoom, 1)

  ' el orden del dibujo es importante en paint, porque una cosa tapa a la otra; en openGL aparentemente es al reves, lo primero se dibuja primero

  ' Primero la grid
  ' clsDrawingAids.DrawGrid

  If gcd.DrawBounds Then clsDrawingAids.DrawPolygons

  ' entidad resaltada
  If gcd.CurrentDrawing.iEntity[3] >= 0 And gcd.CurrentDrawing.iEntity[3] < gcd.CurrentDrawing.arrEntities.Count Then

    ' si no esta seleccionada, la resalto
    'If Not arrEntities[iEntity[3]].Selected Then
    'iParent = clsEntities.GetParentBlock(gcd.CurrentDrawing.iEntity[3]) ' esto verifica si tiene que resaltar el bloque completo
    iParent = gcd.CurrentDrawing.iEntity[3]
    gcd.CurrentDrawing.arrEntities[iParent].ClassHandler.DrawRemark(gcd.CurrentDrawing.arrEntities[iParent])
    'End If

  End If
  clsDrawingAids.DrawCoordenadas

  clsDrawingAids.DibujaHelper

  gcd.clsJob.Draw()

  gl.CallList(gcd.CurrentDrawing.GlListAllEntities)                      ' si GL no tiene contexto, la lista no se genera. Es necesario que la instancia de FCAD este cargada.

  ' POI dinamicos
  If gcd.CurrentDrawing.flgShowPOIinfo Then

    Select gcd.CurrentDrawing.iEntity[2]
      Case gcd.poiMidPoint
        glPlus.PolygonFilled([gcd.CurrentDrawing.iEntity[0] - Metros(4), gcd.CurrentDrawing.iEntity[1], gcd.CurrentDrawing.iEntity[0], gcd.CurrentDrawing.iEntity[1] + Metros(4), gcd.CurrentDrawing.iEntity[0] + Metros(4), gcd.CurrentDrawing.iEntity[1], gcd.CurrentDrawing.iEntity[0], gcd.CurrentDrawing.iEntity[1] - Metros(4)], Color.Blue, Color.Green)
      Case gcd.poiQuadrant
        glPlus.PolygonFilled([gcd.CurrentDrawing.iEntity[0] - Metros(6), gcd.CurrentDrawing.iEntity[1], gcd.CurrentDrawing.iEntity[0], gcd.CurrentDrawing.iEntity[1] + Metros(6), gcd.CurrentDrawing.iEntity[0] + Metros(6), gcd.CurrentDrawing.iEntity[1], gcd.CurrentDrawing.iEntity[0], gcd.CurrentDrawing.iEntity[1] - Metros(6)], Color.Cyan, Color.Cyan)

      Case -1
        ' nada
      Case gcd.poiCenter, gcd.poiBasePoint

        glPlus.Circle([gcd.CurrentDrawing.iEntity[0], gcd.CurrentDrawing.iEntity[1]], Metros(4), Color.Cyan, True, False)
        'glPlus.Rectangle2D(gcd.CurrentDrawing.iEntity[0] - Metros(4), gcd.CurrentDrawing.iEntity[1] - Metros(4), Metros(8), Metros(8), Color.Blue,,,, Color.Blue, 1, 1)

      Case Else
        glPlus.Rectangle2D(gcd.CurrentDrawing.iEntity[0] - Metros(4), gcd.CurrentDrawing.iEntity[1] - Metros(4), Metros(8), Metros(8), Color.Blue,,,, Color.Blue, 1, 1)

    End Select

  Endif

  ' Debug "redraw"

End

' Protocolo del Mouse
'--------------------

' Rigth Clicks  ---> No son enviados a las clases herramienta/entidad; son procesados por FCAD como accion es que terminan o empiezan algo. Tanto MouseDown/Up
'   MouseDown ---------> Lo ignoro
'   MouseUp -----------> A-Trabajo activo? Mando señal de Finalizar/Cancelar ya mismo
'                        B- Click en objeto: muestro las propiedades frmPropiedades (aun no implementado)
'                           Click en el aire: Equivale a <enter> que repite el trabajo anterior, si lo hubo.

' Wheel -----------> Es utilizado como zoom. No es enviado a las clases.

' MouseMove--------> 1-Trabajo activo? --> Se envia el evento
'                    2-Paneando? Se actualizan los valores de PanX/Y y se refresca la pantalla

' Left Clicks
'   MouseDown------> 1- Trabajo activo? -> Se envia a la clase que trabaja gcd.clsJobs si hay una activa. Sino se analziza donde fue el click.
'                    2- no hay trabajos:
'                           2.a- Click en el aire  --> o Paneo, segun el boton que este presionado.
'                           2.b- Click en objeto   --> De/selecciono el objeto
'
'
'
'   MouseUp-------->1-Trabajo activo: ---> envio evento
'
'

Public Sub GLArea1_MouseDown()

  If Mouse.Right Then Return  'handled in MouseUp

  If Mouse.Middle Then Return  'handled in MouseUp

  Select gcd.clsJob.gender

    Case "Default"                                                  ' 1. Seleccionando

      gcd.clsJob.mouseDown(mouse.x, mouse.y)                               '    -> envio el evento a la clase default

    Case "Builder"                                                  ' 2.Construyendo una entidad

      gcd.clsJob.mouseDown(mouse.x, mouse.y)                                   '      y envio el evento a la clase

    Case Else

      gcd.clsJob.mouseDown(mouse.x, mouse.y)                                   ' dispatch event to the Job

  End Select

  redraw

End

Public Sub GLArea1_DblClick()

  Dim k As Single
  Dim e As Entity
  Dim te As Entity

  CursorX = mouse.x
  CursorY = mouse.y

  Select gcd.clsJob.gender

    Case "Default"                                                  ' 1. Seleccionando

      If Not Me.flgSearchingPOI Then
        gcd.CurrentDrawing.iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
      Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

        gcd.CurrentDrawing.iEntity[0] = Xreal(mouse.x)
        gcd.CurrentDrawing.iEntity[1] = Yreal(mouse.y)
        gcd.CurrentDrawing.iEntity[2] = -1                 ' POI type
        gcd.CurrentDrawing.iEntity[3] = -1                 ' Hooked entity

      End If

      If gcd.CurrentDrawing.iEntity[3] >= 0 Then

        'Stop
        ' I comment the abobe line because its stop my tool also. What is the idea whit stop?
        ' TINCHO aca podes lanzar tu editor de texto u otras propiedades
        k = gcd.CurrentDrawing.iEntity[3]
        e = gcd.CurrentDrawing.arrEntities[k]

        Select e.Gender
          Case "Text"
            If EditingText = False Then

              EditingText = False
            Endif
        End Select
      Endif
      '======================= otra Tool
    Case Else

  End Select

End

Public Sub GLArea1_MouseMove()

  CursorX = mouse.x
  CursorY = mouse.y
  Me.flgSearchingEntity = True ' FIXME: poner en false despues de reparar
  Me.flgSearchingPOI = True

  Select gcd.clsJob.gender

    Case "Default"                                                  ' 1. Seleccionando

      If gcd.clsJob.poichecking Then
        If gcd.clsJob.iEntityForEdit < 0 Then
          If Not Me.flgSearchingEntity Then
            gcd.CurrentDrawing.iEntity[2] = -1
            gcd.CurrentDrawing.iEntity[3] = clsMouseTracking.CheckAboveEntity(Xreal(mouse.x), Yreal(mouse.Y), Metros(8))
            If gcd.CurrentDrawing.iEntity[3] <> gcd.CurrentDrawing.iLastEntity Then
              gcd.CurrentDrawing.iLastEntity = gcd.CurrentDrawing.iEntity[3]

            End If

          Else
            Debug "No puedo buscar entidades"
          End If
        Else
          If Not Me.flgSearchingPOI Then
            gcd.CurrentDrawing.iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
          Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

            gcd.CurrentDrawing.iEntity[0] = Xreal(mouse.x)
            gcd.CurrentDrawing.iEntity[1] = Yreal(mouse.y)
            gcd.CurrentDrawing.iEntity[2] = -1                 ' POI type
            gcd.CurrentDrawing.iEntity[3] = -1                 ' Hooked entity

          End If
        End If
      End If
      gcd.clsJob.MouseMove(mouse.x, mouse.y) ' dispatch event to the Job

      If gcd.ShowInspector Then

        If gcd.CurrentDrawing.iEntity[3] >= 0 Then

          FInspector.Run(gcd.CurrentDrawing.arrEntities[gcd.CurrentDrawing.iEntity[3]])
        Else
          FInspector.Close

        Endif
      End If

      '======================= otra Tool
    Case Else

      If gcd.clsJob.poichecking Then
        If Not Me.flgSearchingPOI Then
          gcd.CurrentDrawing.iEntity = clsMouseTracking.CheckPOI(Xreal(mouse.x), Yreal(mouse.Y))
        Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior

          gcd.CurrentDrawing.iEntity[0] = Xreal(mouse.x)
          gcd.CurrentDrawing.iEntity[1] = Yreal(mouse.y)
          gcd.CurrentDrawing.iEntity[2] = -1                 ' POI type
          gcd.CurrentDrawing.iEntity[3] = -1                 ' Hooked entity

        End If

      End If

      If gcd.clsJob.EntityChecking Then
        If Not Me.flgSearchingEntity Then
          gcd.CurrentDrawing.iEntity[3] = clsMouseTracking.CheckAboveEntity(Xreal(mouse.x), Yreal(mouse.Y), Metros(8))
        End If
      End If

      gcd.CurrentDrawing.flgShowPOIinfo = True

      clsDrawingAids.Helper.dX = 15
      clsDrawingAids.Helper.dY = 15
      clsDrawingAids.Helper.fColor = Color.DarkBlue
      gcd.clsJob.MouseMove(mouse.x, mouse.y) ' dispatch event to the Job

  End Select

  Redraw

End

Public Sub GLArea1_MouseUp()
  ' ex Public Sub drwArea_MouseUp()

  ' "Los IF son mas rapidos" - Autor Anonimo

  ' los rigth clicks se manejan en FCAD , ni las herramientas ni las entidades los necesitan
  If Mouse.Right Then                ' rigth clicks means finish what you're doing rigth now and go back to the previous Job
    ' the Finish() sub will do this in a good manner
    If gcd.clsJob.gender = "Builder" Then

      gcd.clsJob.KeyText("U")

    Else If gcd.clsJob.gender = "Default" Then

      gcd.clsJob = gcd.clsJobPrevious
      gcd.clsJob.Start()

    Else    ' es una tool

      gcd.clsJob.finish
      gcd.clsJobPrevious = gcd.clsJob
      gcd.clsJob = clsDefaultJob

    Endif

  Else If Mouse.Left Then

    gcd.clsJob.MouseUp(mouse.x, mouse.y)

  Else If Mouse.Middle Then

    If gcd.clsJob.gender <> "Pan" Then
      gcd.clsJobPreZoom = gcd.clsJob
      gcd.clsJob = cadPan
      gcd.clsJob.Start()

    Else

      gcd.clsJob = gcd.clsJobPreZoom

    End If

  End If

  redraw

End

Public Function Xreal(ScreenX As Float) As Float

  Return Metros((screenx - glarea1.w / 2 - gcd.CurrentDrawing.PanX))

End

Public Function Yreal(ScreenY As Float) As Float

  Return Metros((-ScreenY + glarea1.h / 2 - gcd.CurrentDrawing.PanY))

End

Public Function Pixels(distancia As Float) As Float  ' converts meters to pixels
  ' transforma Metros en Pixeles sin tener en cuenta el Pan

  Return distancia * gcd.CurrentDrawing.ScaleZoom

End

Public Function Metros(pixeles As Integer) As Float  ' converts pixels to meters

  Return pixeles / gcd.CurrentDrawing.ScaleZoom

End

Public Sub GLArea1_MouseWheel()
  ' ex  Public Sub drwArea_MouseWheel()

  Dim px, py, factor As Float
  ' chequeamos si vale la pena seguir dibujando la grid, o sea, menos de 3 pixels

  If Pixels(puntos.GridSpacing) < 5 Then puntos.Gridactive = False Else puntos.Gridactive = True

  px = Xreal(GLArea1.w / 2)
  py = Yreal(GLArea1.h / 2)

  ' TODO: , redondear para que la escala sea 1:100 1:75 1:50 etc

  factor = (1 + 0.075 * Mouse.Delta)

  gcd.CurrentDrawing.ScaleZoom = gcd.CurrentDrawing.ScaleZoom * factor

  ' pero con ciertos limites
  ' If ScaleZoom < 0.001 Then ScaleZoom = 0.001
  ' If ScaleZoom > 50 Then ScaleZoom = 50

  ' reacomodo el panning, pero solo si estoy en los limites del drwarea, sino es solo un zoom
  ' pero tengo que reajustar la posicion de las cosas , porque tienden a alejarse
  ' Supongamos que partimos de un Zoom = 1 y una posicion centrada, y hacemos zoom=2
  ' la posicion de las cosas estara 2x mas alejado; yo quiero que lo que hay en el centro de la pantalla, siga ahi
  ' entonces Pc = drwarea/2 anes del zoom, debera estar en el mismo lugar

  gcd.CurrentDrawing.PanX = -Pixels(px)
  If mouse.x < glarea1.w * 0.2 Then
    gcd.CurrentDrawing.PanX -= gcd.CurrentDrawing.ScaleZoom * 5 * Mouse.Delta
  Else If mouse.x > glarea1.w * 0.8 Then
    gcd.CurrentDrawing.PanX += gcd.CurrentDrawing.ScaleZoom * 5 * Mouse.Delta
  Endif

  gcd.CurrentDrawing.PanY = -Pixels(py)
  If mouse.y < glarea1.h * 0.2 Then
    gcd.CurrentDrawing.PanY -= gcd.CurrentDrawing.ScaleZoom * 5 * Mouse.Delta
  Else If mouse.y > glarea1.h * 0.8 Then
    gcd.CurrentDrawing.PanY += gcd.CurrentDrawing.ScaleZoom * 5 * Mouse.Delta
  Endif

  redraw

End

Public Sub redraw()

  glarea1.Refresh

End

'' Regenera las listas de OpenGL
Public Sub Regen()

  'gcd.UpdateLayers
  clsEntities.glGenDrawList
  clsEntities.glGenDrawListSel
  redraw

End

'
' Public Sub AddLtypesPics()
'
'   Dim lt As Variant
'   Dim dash As Float[]
'   Dim img As Image
'   Dim hColor As ColorInfo
'   'Dim pxl As Integer
'
'   hColor = Color[Color.ButtonBackground]
'
'   If iTheme <> hColor.Luminance Then
'     iTheme = hColor.Luminance
'
'     For Each lt In gcd.cStyles
'
'       dash = lt[0]
'
'       img = New Image(btnLtypes.Width, 8, btnLtypes.Background)
'
'       Paint.Begin(img)
'       Paint.NewPath
'       Select dash.Count
'         Case 0, 1
'
'         Case Else
'           Paint.Dash = dash
'
'       End Select
'
'       hColor = Color[Color.ButtonBackground]
'
'       If hColor.Luminance > 160 Then
'         Paint.Brush = Paint.Color(Color.Black)
'       Else
'         Paint.Brush = Paint.Color(Color.White)
'       Endif
'
'       Paint.LineWidth = 1
'       Paint.MoveTo(4, 4)
'       Paint.LineTo(btnLtypes.Width - 4, 4)
'       Paint.Stroke
'       Paint.End
'
'       If gcd.cStyles[gcd.cStyles.Key].Count = 4 Then
'         gcd.cStyles[gcd.cStyles.Key][3] = img
'       Else
'         gcd.cStyles[gcd.cStyles.Key].Add(img)
'       Endif
'
'     Next
'
'   Endif
'
' End
'
' Public Sub AddWidthsPics()
'
'   Dim wt As Variant
'   Dim img As Image
'   Dim hColor As ColorInfo
'   Dim mm As String
'   Dim px As Float
'
'   hColor = Color[Color.ButtonBackground]
'
'   iTheme = hColor.Luminance
'
'   For Each wt In gcd.cWidths
'     mm = wt[0]
'     If CInt(gcd.cWidths.Key) > 0 And CInt(gcd.cWidths.Key) < 27 Then
'       img = New Image(btnLtypes.Width, 8, btnLtypes.Background)
'       px = gcd.cWidths.Key
'     Else
'       img = New Image(btnLtypes.Width / 2, 8, btnLtypes.Background)
'       px = 1
'     Endif
'
'     Paint.Begin(img)
'     If hColor.Luminance > 160 Then
'       Paint.Brush = Paint.Color(Color.Black)
'     Else
'       Paint.Brush = Paint.Color(Color.White)
'     Endif
'
'     Paint.NewPath
'     Paint.LineWidth = px ' CFloat(wt) * 3
'     Paint.MoveTo(4, 4)
'
'     'If CInt(gcd.cWidths.Key) > 0 And CInt(gcd.cWidths.Key) < 27 Then
'     Paint.LineTo(btnLtypes.Width - 4, 4)
'     'Else
'     '  Paint.LineTo(CInt(btnLtypes.Width / 2), 4)
'     'Endif
'
'     Paint.Stroke
'     Paint.End
'     gcd.cWidths[gcd.cWidths.Key] = [mm, px, img]
'
'   Next
'
' End
'
' Public Sub AddColorsPics()
'
'   Dim lt As Variant[]
'   Dim img As Image
'
'   For Each lt In gcd.cColors
'
'     img = New Image(16, 16, btnLtypes.Background)
'
'     Paint.Begin(img)
'
'     Paint.NewPath
'
'     Select gcd.flgWhiteAndBlack
'       Case 0
'         Paint.Brush = Paint.Color(Color.Black)
'       Case Else
'         Paint.Brush = Paint.Color(Color.White)
'     End Select
'
'     Paint.Begin(img)
'     Paint.LineWidth = 2
'     Paint.Arc(8, 8, 7, 0, 2 * Pi)
'     Paint.Brush = Paint.Color(Val(gcd.cColors.Key))
'     Paint.Fill(True)
'     Paint.Brush = Paint.Color(Color.Black)
'     Paint.Stroke()
'     Paint.End
'
'     'lt.Insert([img.Copy()])
'     gcd.cColors[gcd.cColors.Key][1] = img.Copy()
'
'   Next
'
' End

Public Sub Form_KeyPress()

  Dim com As Variant
  Dim umx As Integer     '' Index in undo array
  Dim uEnty As Entity    '' Undo entity
  Dim aEnty As Entity    '' Actual entity
  Dim imx As Integer     '' Index in Entities array
  Dim SelectMode As Boolean

  Print Key.Code
  Dim t As Float = Timer

  Select Key.Code

    Case Key.Enter, Key.Return
      Debug KeysAccumulator


      Form_Activate()

      gcd.clsJob.KeyText(KeysAccumulator)
      KeysAccumulator = ""

    Case Key.f2
      Stop

    Case Key.f6

      ' If btnBounds.Value = True Then
      '   gcd.DrawBounds = False
      ' Else
      '   gcd.DrawBounds = True
      ' Endif
      ' btnBounds.Value = gcd.DrawBounds

    Case Key.BackSpace

      KeysAccumulator = Left(KeysAccumulator, -1)

    Case Key.f8

      Debug "Entidades transferidas en  ", Timer - t

      ' If btnOrtho.Value = False Then
      '   gcd.Orthogonal = True
      ' Else
      '   gcd.Orthogonal = False
      ' Endif

      ' btnOrtho.Value = gcd.Orthogonal

    Case Key.f7
      ' If btnGrid.Value = False Then
      '   puntos.Gridactive = True
      ' Else
      '   puntos.Gridactive = False
      ' Endif
      ' btnGrid.Value = puntos.Gridactive

    Case Key.F11


    Case Key.Esc

      If gcd.clsJob.gender = "Builder" Then

        gcd.clsJob.KeyText("U")

      Else If gcd.clsJob.gender = "Default" Then

        gcd.clsJob = gcd.clsJobPrevious
        gcd.clsJob.Start()

      Else    ' es una tool

        gcd.clsJob.finish
        gcd.clsJobPrevious = gcd.clsJob
        gcd.clsJob = clsDefaultJob

      Endif

      ' SelectionRefresh()

    Case Key.Space
      Stop Event

    Case Key.Del
      gcd.clsJob.KeyText("Erase")

    Case Key.ControlKey
      KeysAccumulator = "Function"

    Case Else
      ' A GOOD KEY
      If InStr(KeysAccumulator, "Function") > 0 Then

        ' Select Key.Code
        '   Case Asc("1") ' Properties
        '
        '     Select PropertiesFlag
        '       Case 1 ' Tools
        '         PropertiesFlag = 2
        '         pnlProperties.Visible = True
        '         pnlIcons.Visible = False
        '         'btnSelectionMode.Value = False
        '       Case 2 ' Props
        '         PropertiesFlag = 0
        '         pnlProperties.Visible = False
        '         pnlIcons.Visible = False
        '         'btnSelectionMode.Value = True
        '
        '       Case Else ' Invisible
        '         PropertiesFlag = 1
        '         pnlProperties.Visible = False
        '         pnlIcons.Visible = True
        '
        '     End Select
        '
        '     If PropertiesFlag = False Then
        '       pnlProperties.Visible = True
        '       PropertiesFlag = True
        '       pnlIcons.Visible = False
        '       btnSelectionMode.Value = False
        '     Else
        '       pnlProperties.Visible = False
        '       PropertiesFlag = False
        '       pnlIcons.Visible = True
        '       btnSelectionMode.Value = True
        '     Endif
        '
        '   Case Asc("2") ' Layers
        '
        '     'Case Asc("3") ' Blocks
        '
        '     'Case Asc("4...") ' More...
        '     'KeysAccumulator &= "-" & Key.Text
        '     'Case Else
        '     '    KeysAccumulator = ""
        '     'pnlProperties.Visible = False
        '     'pnlDebug.Visible = False
        '
        '   Case Asc("3") ' Raw properties for debuging
        '     If RawFlag = False Then
        '       pnlRaw.Visible = True
        '       RawFlag = True
        '     Else
        '       pnlRaw.Visible = False
        '       RawFlag = False
        '     Endif
        '
        '   Case Asc("a"), Asc("A") ' Select/Unselect All
        '     SelectMode = True
        '     For Each aEnty In gcd.CurrentDrawing.arrEntities
        '       If aEnty.Selected Then
        '         SelectMode = False
        '         Break
        '       Endif
        '     Next
        '
        '     If SelectMode Then
        '       For Each aEnty In gcd.CurrentDrawing.arrEntities
        '         If aEnty.Selected = False Then
        '           aEnty.Selected = True
        '         Endif
        '       Next
        '     Else
        '       For Each aEnty In gcd.CurrentDrawing.arrEntities
        '         If aEnty.Selected Then
        '           aEnty.Selected = False
        '         Endif
        '       Next
        '     Endif
        '     fMain.regen
        '
        '   Case Asc("z"), Asc("Z") ' Undo
        '
        '     If gcd.CurrentDrawing.arrUndo.Count > 0 Then
        '       umx = gcd.CurrentDrawing.arrUndo.Max
        '
        '       uEnty = gcd.CurrentDrawing.arrUndo[umx]
        '       For Each aEnty In gcd.CurrentDrawing.arrEntities
        '         If aEnty.Handle = uEnty.Handle Then
        '           gcd.CurrentDrawing.arrEntities.Remove(imx, 1)
        '           gcd.CurrentDrawing.arrEntities.Add(uEnty, imx)
        '           gcd.CurrentDrawing.arrUndo.Remove(umx, 1)
        '           fMain.regen
        '           'gcd.Redraw
        '           Break
        '         Endif
        '         Inc imx
        '       Next
        '
        '     Endif
        '   Case Else
        '     KeysAccumulator = ""
        '
        ' End Select

      Else
        KeysAccumulator &= Key.Text
        clsDrawingAids.ErrorMessage = ""
      Endif

  End Select

  clsDrawingAids.DibujaHelper

End


Public Sub tmr500_Timer()

  If clsDrawingAids.PromtSlash = "|" Then clsDrawingAids.PromtSlash = "" Else clsDrawingAids.PromtSlash = "|"
  clsDrawingAids.DibujaHelper

End

Public Sub tbnOrtho_Click()

  gcd.Orthogonal = tbnOrtho.value
  If tbnOrtho.Value Then
    tbnOrtho.foreground = Color.Blue
    tbnOrtho.Font.Bold = True
  Else
    tbnOrtho.foreground = Color.Buttonforeground
    tbnOrtho.Font.Bold = False
  Endif

End

Public Sub tbnSnap_Click()


  If tbnSnap.Value Then
    gcd.SnapMode = gcd.SnapModePrev
    tbnSnap.foreground = Color.DarkGreen
    tbnSnap.Font.Bold = True
  Else
    gcd.SnapModePrev = gcd.SnapMode
    gcd.SnapMode = -1
    tbnSnap.foreground = Color.Buttonforeground
    tbnSnap.Font.Bold = False
  Endif


End
