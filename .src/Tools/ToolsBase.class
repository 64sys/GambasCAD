' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

' Tool maintained by Terco
Create Static
Create Private
Public Const Gender As String = "TOOLSBASE"
Public Const USEWITH As String = ""
' Add more if needed

Public SelStartX As Integer                         ' Sel = selection, where? Start/End , axis? X/Y
Public SelStartY As Integer
Public SelEndX As Integer
Public SelEndy As Integer

Public SelStartXr As Float                          ' same but in real space, METERS not pixel
Public SelStartYr As Float
Public SelEndXr As Float
Public SelEndyr As Float

Public StartXr As Float                          ' same but in real space, METERS not pixel
Public StartYr As Float
Public EndXr As Float
Public Endyr As Float

Public LastX As Float               ' change in MouseMove/MouseUp
Public LastY As Float

Public MouseX As Integer               ' change in MouseMove/MouseUp
Public MouseY As Integer
Public MouseButton As Integer
Public MouseFakeClick As Boolean = False

Public SelectionCount As Integer

Public PointsDone As Integer
Public PointsTotal As Integer
Public NextParamType As String          ' What kind of input the element expects P=point, F=float, C=color, S=string, M=mixed either Point, or Float that is taken from Max(Px-Px', Pz-Pz')
Public NextParamDefault As Variant      ' default value

Public Active As Boolean = False
Public PoiChecking As Boolean = False
Public EntityChecking As Boolean = False
Public Mode As Integer

Public MenuRightClick As String

Public inxSelected As New Integer[]

' this affects the gl Drawing list
Public glTranslate As New Float[]         ' dX, dY, dZ
Public glRotate As New Float[]            ' rX, rY, rZ
Public glAngle As Float                   ' deg
Public glScale As New Float[]             ' sX, sY, sZ

Public cursorX As Integer
Public cursory As Integer

Public Const ContextMenu As String = ("Close;_CLOSE;Undo;_UNDO;End;_END;Cancel;_CANCEL") ' el menu para el boton derecho, los comendos en mayusculas NO se traducen

Public Sub _new()

    Me.glTranslate.Insert([0.0, 0.0, 0.0])         ' dX, dY, dZ
    Me.glRotate.Insert([0.0, 0.0, 1.0])            ' rX, rY, rZ
    Me.glAngle = 0                           ' deg
    Me.glScale.Insert([1.0, 1.0, 1.0])             ' sX, sY, sZ

End

Public Function Start(Optional ElemToBuild As Variant, Optional _mode As Integer = 0) As Boolean

    Me.PointsDone = 0
    Me.mode = _mode
    Utils.MenuMaker(fMain, "mToolsBase", Me.ContextMenu)
    fMain.GLArea1.PopupMenu = "mToolsBase"

End

Public Function NewParameter(vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    ' dummy

End

Public Sub Draw()               ' called by gcd.CurrDrawing.drwArea_Draw

    gl.PushMatrix

    gl.Translatef(glTranslate[0], glTranslate[1], glTranslate[2])
    gl.Rotatef(glAngle, glRotate[0], glRotate[1], glRotate[2])
    gl.Scalef(glScale[0], glScale[1], glScale[2])
    gl.CallList(gcd.CurrentDrawing.GlListSelectedEntities)
    gl.PopMatrix

    DrawingAids.DrawDxDy([Me.SelStartXr, Me.SelStartYr], [Me.SelEndXr, Me.SelEndYr])

End

Public Sub KeyPress()

End

Public Function KeyText(EnteredText As String)
    ' Lets see what are we expecting

    Dim Xt, yt As Float, ErrTxt As String, Relative As Boolean

    Select Case NextParamType

        Case "P", "+"
            errtxt = ", expected a valid point like 12.4,9.5  or @12.34,10.5"
            ' lets filter
            EnteredText = Trim$(UCase$(EnteredText))
            ' So we expect a position x,y , but in some cases it can be
            ' C = close
            ' U = undo, delete last segment
            ' and others

            If Left(EnteredText, 1) = "C" Then          ' close the element
                ' got othe first point and exit
                If gcd.clsJob.NewParameter(["close"]) Then Me.Finish

            Else If Left(EnteredText, 1) = "U" Then     ' undo last command and go

                If gcd.clsJob.NewParameter(["undo"]) Then Me.Finish

            Else                                        ' an X,Y or @X,Y

                If InStr(EnteredText, "@") > 0 Then    ' may be a point
                    Relative = True
                    EnteredText = Replace(EnteredText, "@", "")
                Endif
                Xt = CFloat(Split(EnteredText, ",")[0])
                yt = CFloat(Split(EnteredText, ",")[1])

                If Relative Then
                    xt += Me.LastX
                    yt += Me.LastY

                Endif
                Me.LastX = xt
                Me.LastY = yt

                If gcd.clsJob.NewParameter(["point", xt, yt], True) Then
                    ' last point
                    gcd.CurrentDrawing.LastPoint.Clear
                    gcd.CurrentDrawing.LastPoint.Insert([xt, yt])

                End If

            End If

            ' Case "T"
            '     errtxt = ", expected text, not a point"
            '     ' its a valid input?
            '     If EnteredText = "" Then
            '
            '         sText = ParamDefault[clsjob.StepsDone]
            '
            '     Else
            '
            '         sText = EnteredText
            '
            '     End If
            '
            '     If elem.Gcd.CCC[e.gender].NewParameter(elem, ["text", sText], True) Then AdvanceStep
            '
            ' Case "F", "M", "A", "L", "R"                ' Float, Mixed, Angle, Longitud
            '     errtxt = "enter a valid text size"
            '
            '     If EnteredText = "" Then
            '         Try bResult = elem.Gcd.CCC[e.gender].NewParameter(elem, ["float", ParamDefault[elem.Gcd.CCC[e.gender].StepsDone]], True)
            '
            '     Else
            '
            '         bResult = elem.Gcd.CCC[e.gender].NewParameter(elem, ["float", CFloat(EnteredText)], True)
            '
            '     Endif
            '
            '     If bResult Then AdvanceStep
            '
            ' Case "C"                                ' color
            '     If Dialog.SelectColor() Then
            '         elem.fParam[iFloat] = CFloat(Dialog.Color)
            '         Inc iFloat
            '         AdvanceStep
            '
            '     Endif
            '     Key.Cod

    End Select

End

Public Sub DblClick()
    ' veo si encuentro una entidad debao del mouse

    clsMouseTracking.CheckAboveEntity(gcd.Xreal(Mouse.x), gcd.Yreal(Mouse.y))

End

Public Sub MouseUp()

End
'

Public Sub MouseMove()

    '   If gcd.clsJob.poichecking Then
    '     If Not gcd.flgSearchingPOI Then
    '       gcd.CurrentDrawing.iEntity = clsMouseTracking.CheckPOI(gcd.Xreal(mouse.x), gcd.Yreal(mouse.Y))
    '     Else    ' estoy buscando, pero me movi, asi que me desengancho del POI anterior
    '
    '       gcd.CurrentDrawing.iEntity[0] = gcd.Xreal(mouse.x)
    '       gcd.CurrentDrawing.iEntity[1] = gcd.Yreal(mouse.y)
    '       gcd.CurrentDrawing.iEntity[2] = -1                 ' POI type
    '
    '     End If
    '
    '   End If
    '
    '   If gcd.clsJob.EntityChecking Then
    '     If Not gcd.flgSearchingAllowed Then
    '       gcd.CurrentDrawing.HoveredEntity = clsMouseTracking.CheckAboveEntity(gcd.Xreal(mouse.x), gcd.Yreal(mouse.Y), gcd.metros(8))
    '     End If
    '   End If
    '
    '   gcd.CurrentDrawing.flgShowPOIinfo = True
    '
    '   DrawingAids.Helper.dX = 15
    '   DrawingAids.Helper.dY = 15
    '   DrawingAids.Helper.fColor = Color.DarkBlue
    '   '''gcd.clsJob.MouseMove(mouse.x, mouse.y) ' diIf Mouse.Middle Then

    '   If gcd.clsJob.gender <> "Pan" Then
    '     gcd.clsJobPreZoom = gcd.clsJob
    '     gcd.clsJob = cadPan
    '     gcd.clsJob.Start()
    '     ' glarea1.Refresh  ' glarea1.Refresh
    '     '
    '     '
    '   Else
    '
    '     gcd.clsJob = gcd.clsJobPreZoom
    '
    '   End If
    '
    '
    ' If Mouse.Middle Then
    '
    '   If gcd.clsJob.gender <> "Pan" Then
    '     gcd.clsJobPreZoom = gcd.clsJob
    '     gcd.clsJob = cadPan
    '     gcd.clsJob.Start()
    '     ' glarea1.Refresh  ' glarea1.Refresh
    '     '
    '     '
    '   Else
    '
    '     gcd.clsJob = gcd.clsJobPreZoom
    '
    '   End If
    '
    ' Endif Mouse.Middle Then
    '
    '
    ' End If
    ' End If

End

Public Sub MouseDown()
    ' ' ex Public Sub drwArea_MouseUp()
    '
    ' ' "Los IF son mas rapidos" - Autor Anonimo
    '
    ' ' los rigth clicks se manejan en fMain , ni las herramientas ni las entidades los necesitan

    If Mouse.Right Then                ' rigth clicks means finish what you're doing rigth now and go back to the previous Job
        ' the Finish() sub will do this in a good manner
        If gcd.clsJob.gender = "BUILDER" Then

            gcd.clsJob.KeyText("U")

        Else If gcd.clsJob.gender = "DEFAULT" Then

            gcd.clsJob = gcd.clsJobPrevious
            gcd.clsJob.Start()

        Else    ' es una tool

            gcd.clsJob.finish
            gcd.clsJobPrevious = gcd.clsJob
            gcd.clsJob = cadSelection
            gcd.clsJob.start()

        Endif

    Else If Mouse.Left Then

        'gcd.clsJob.MouseUp(mouse.x, mouse.y)

    Else If Mouse.Middle Then

        If gcd.clsJob.gender <> "PAN" Then
            gcd.clsJobPreZoom = gcd.clsJob
            gcd.clsJob = cadPan
            gcd.clsJob.Start()
            ' glarea1.Refresh  ' glarea1.Refresh
            '
            '
        Else

            gcd.clsJob = gcd.clsJobPreZoom
            gcd.clsJob.start()

        End If

    End If

    gcd.redraw

End

' El objetivo es que el zoom dinamico se haga manteniendo el dibujo que esta en la pos del mouse
Public Sub MouseWheel()

    Dim px, py, dx, dy, factor As Float
    ' chequeamos si vale la pena seguir dibujando la grid, o sea, menos de 3 pixels
    ' Inc flgWheelCounter
    ' Debug "Mouse weel", flgWheelCounter

    ' TODO: revisar la siguiente linea
    'If gcd.Pixels(FMain.GridSpacing) < 5 Then FMain.GridActive = False Else FMain.GridActive = True
    '
    px = gcd.Xreal(Mouse.x) ' posicion real en donde esta el mouse, previo al zoom
    py = gcd.Yreal(Mouse.y)

    ' TODO: , redondear para que la escala sea 1:100 1:75 1:50 etc

    factor = (1 + 0.075 * Mouse.Delta)

    gcd.currentDrawing.ScaleZoom = gcd.currentDrawing.ScaleZoom * factor

    dx = gcd.Xreal(Mouse.x) ' posicion real en donde esta el mouse, posterior al zoom
    dy = gcd.Yreal(Mouse.y)

    ' pero con ciertos limites TODO: imponer
    ' If ScaleZoom < 0.001 Then ScaleZoom = 0.001
    ' If ScaleZoom > 50 Then ScaleZoom = 50

    ' nuevo metodo (el Pan esta en pixels)
    gcd.currentDrawing.PanX += gcd.pixels(dx - px)
    gcd.currentDrawing.PanY += gcd.pixels(dy - py)

    gcd.flgNewPosition = True

    gcd.redraw 'glarea1.Refresh

    ' despues de actualizar la pantalla, recolectamos las entidades visibles

    ' Dec flgWheelCounter

    ' Test
    ' Debug "Mouse tracking task ID", tskMouseTracking.Handle

End

Public Sub Finish()

    clsEntities.DeSelection()
    gcd.CurrentDrawing.RequiresSaving = True
    gcd.CurrentDrawing.iEntity.Clear
    gcd.CurrentDrawing.iEntity.Insert([0, 0, -1, -1])
    gcd.clsJobPrevious = Me
    gcd.clsJob = cadSelection
    gcd.clsJob.start()
    DrawingAids.CleanTexts
    gcd.StepsDone = 0

    gcd.DrawOriginals = False
    Me.Active = False
    gcd.ToolActive = False
    gcd.regen

End

Public Sub Cancel()

    gcd.clsJobPrevious = Me
    gcd.clsJob = cadSelection
    clsEntities.DeSelection()
    gcd.clsJob.start()
    DrawingAids.CleanTexts
    gcd.Redraw

End
