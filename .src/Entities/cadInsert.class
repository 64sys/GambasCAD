' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits EntityBase
Public Const Gender As String = "INSERT"
Public Const CmdLineHelper As String = ("Inserts a block")
Public Const ParamType As String = "TPFFF"
Public Const ParamHelper As String = "BlockName; Position ; X scale ; Y scale ; Rotation"
Public Const ParamDefault As String = "<no name>; 0,0 ; 1 ;1 ; 0"

' fParam helpers
Public Const TotalParams As Integer = 5
Public Const ipaEscX As Integer = 0
Public Const ipaEscY As Integer = 1
Public Const ipaEscZ As Integer = 2
Public Const ipaRotacion As Integer = 3
Public Const ipaAttribs As Integer = 4

Public Const sdaTotalParams As Integer = 1
Public Const sdaBlockName As Integer = 0
' special vars

Public CurrLType As Integer
Public CurrColor As Integer
Public CurrLwt As Float

Public Function NewEntity(Optional fPoints As Float[], bNewid As Boolean = False) As Entity

    Dim e As New Entity

    e = Super.NewEntity(fPoints, bNewid)
    e.Gender = Me.Gender
    e.pBlock = New Block

    Return e

End

'' Return if that position is over the entity within the tolerance
Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean

    If e.Polygon Then
        If puntos.isInside(e.Polygon, xr, yr) Then Return True
    End If

    Return False

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    ' Dim eBlock As Entity
    ' ' los insertos se mueven de acuerdo al punto de insercion
    ' Select Case e.pBlock.InsertionPlace
    '     Case 0  ' simplemente muevo P
    puntos.Translate(e.p, dx, dy)
    '     Case 1  ' aca es mas complicado porque P no se tiene en cuenta, hay que mover todas las entidades del bloque
    '         puntos.Translate(e.p, dx, dy)
    '         For Each eBlock In e.pBlock.entities
    '             gcd.CCC[eBlock.gender].translate(eBlock, dx, dy)
    '         Next
    '
    ' End Select

End

Public Sub Rotate(e As Entity, radians As Float)

    puntos.Rotate(e.P, radians)
    E.fParam[Me.ipaRotacion] += Deg(radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    Dim i As Integer

    E.fParam[Me.ipaEscX] *= sX
    E.fParam[Me.ipaEscY] *= sY
    For i = 0 To e.p.max Step 2

        e.P[i] = e.P[i] * sX
        e.P[i + 1] = e.P[i + 1] * sY

    Next

End

Public Sub Draw(oE As Entity)

    'If oe.id = "14140A" Then Stop
    If oe.pBlock Then Draw_List(oe.pBlock.entities, oe, oe.pBlock.InsertionPlace)

End

'' DrawMode: 0 Normal ; 1 Selected ; 2 Remark ; 3 Paint
Public Sub Draw_List(eList As Collection, eParent As Entity, DrawMode As Integer)

    'insertion place:
    ' 0 = entity.P[0],[1]
    ' 1 = entity.pBlock.entities.P[0],[1]
    ' 2 = entity.pBlock.x0,y0

    Dim et As Entity

    If Not eList Then Return

    For Each ET In eList
        ' et.visible = True
        ' et.LineType = eParent.LineType
        ' et.colour = eParent.colour
        ' et.LineWidth = eParent.LineWidth

        If et.Gender = "INSERT" Then

            If et.pBlock Then Draw_List(et.pBlock.entities, et, DrawMode)

        Else
            ' If et.Gender = "ATTRIB" Then
            '     ' nada
            '
            ' Else
            '     gl.PushMatrix
            '     gl.Translatef(gcd.Pixels(eParent.p[0]) / gcd.Drawing.Sheet.ScaleZoom, gcd.Pixels(eParent.p[1]) / gcd.Drawing.Sheet.ScaleZoom, 0)
            '     gl.Rotatef(eParent.fParam[Me.ipaRotacion], 0, 0, 1)
            '     gl.Scalef(eParent.fParam[Me.ipaEscX], eParent.fParam[Me.ipaEscY], eParent.fParam[Me.ipaEscZ])
            ' End If

            Select Case DrawMode
                Case 0 ' normal
                    GCD.CCC[et.gender].Draw(et)
                Case 1 ' Selected
                    GCD.CCC[et.gender].DrawSelected(et)
                Case 2 ' Remark
                    GCD.CCC[et.gender].DrawRemark(et)
                Case 3 ' Paint
                    GCD.CCC[et.gender].Draw2(et)

            End Select
            'If et.Gender <> "ATTRIB" Then gl.PopMatrix
        End If

    Next

End

'' A selected version of the entity
Public Sub DrawSelected(oE As Entity)

    If oe.pBlock Then Draw_List(oe.pBlock.entities, oe, 1)

End

'' A fat version of the entity
Public Sub DrawRemark(oE As Entity)

    If oe.pBlock Then Draw_List(oe.pBlock.entities, oe, 2)

End

Public Function Draw2(oE As Entity)

    If oe.pBlock Then Draw_List2(oe.pBlock.entities, oe, oe.pBlock.InsertionPlace)

End

Public Sub Draw_List2(eList As Collection, eParent As Entity, Optional InsertionPlace As Integer = 0)
    'insertion place:
    ' 0 = entity.P[0],[1]
    ' 1 = entity.pBlock.entities.P[0],[1]
    ' 2 = entity.pBlock.x0,y0

    Dim et As Entity

    Paint.Save

    If InsertionPlace = 0 Then
        Paint.Translate(gcd.Pixels(eParent.p[0]) / gcd.Drawing.Sheet.ScaleZoom, gcd.Pixels(eParent.p[1]) / gcd.Drawing.Sheet.ScaleZoom)
    Else If InsertionPlace = 1 Then
        ' absolute coordinate, so each entity has its own position
        ' nothing to translate
    Else If InsertionPlace = 2 Then
        Paint.translate(gcd.Pixels(eParent.pBlock.x0) / gcd.Drawing.Sheet.ScaleZoom, gcd.Pixels(eParent.pBlock.y0) / gcd.Drawing.Sheet.ScaleZoom)

    End If

    ' tengo que invertir el sentido de giro porque en fPrint tengo EscY invertida
    Paint.Rotate(Rad(-eParent.fParam[Me.ipaRotacion]))

    Paint.Scale(eParent.fParam[Me.ipaEscX], eParent.fParam[Me.ipaEscY])

    For Each ET In eList
        et.visible = True
        ' et.LineType = eParent.LineType
        ' et.colour = eParent.colour
        ' et.LineWidth = eParent.LineWidth
        '
        If et.Gender = "INSERT" Then

            If et.pBlock Then Draw_List2(et.pBlock.entities, et)
        Else
            Gcd.CCC[et.gender].Draw2(et)
        End If

    Next
    Paint.Restore

End

'' Creo los puntos de interes
'' Build point of interest
Public Function BuildPOI(oE As Entity) As Integer

    ' si este valor no es provisto , estos POI son de la ultima entidad

    oe.PoiPoints.Clear
    oe.PoiType.Clear
    oe.Polygon.Clear

    ' points
    oe.poiPoints.insert([oE.p[0], oE.p[1]])
    oe.poiType.Add(gcd.poiBasePoint)
    'oe.poiEntities.Add(arrIndex)
    'If oe.Handle = "78193" Then Stop

    ' polygon
    Dim fLimits As Float[]
    'If IsNull(oe.pBlock) Then Return ' Stop
    fLimits = clsEntities.ComputeLimits(oe.pBlock.entities)
    If IsNull(fLimits) Then Stop 'Return
    oe.Polygon.Insert([fLimits[0], fLimits[1], fLimits[2], fLimits[1], fLimits[2], fLimits[3], fLimits[0], fLimits[3]])
    ' puntos.Scale(oe.Polygon, oe.fParam[cadInsert.ipaEscX], oe.fParam[cadInsert.ipaEscY])
    ' puntos.Rotate(oe.Polygon, Rad(oe.fParam[cadInsert.ipaRotacion])) ' TODO: verificar orden de esta y la siguiente linea
    ' puntos.Translate(oe.Polygon, oe.P[0], oe.P[1])

End

'

Public Sub ExportDXFCol(e As Entity, ByRef stxExport As String[]) As Boolean

    ' stxExport.insert(["INSERT", dxf.codEntity])
    ' Los datos comunes a todas las entidades son guardados por la rutina que llama a esta
    stxExport.insert(["AcDbBlockReference", "100"])
    stxExport.insert([e.pBlock.name, dxf.codName])
    stxExport.insert([CStr(e.p[0]), dxf.codX0])
    stxExport.insert([CStr(e.p[1]), dxf.codY0])
    stxExport.insert(["0", dxf.codZ0])

    stxExport.insert([CStr(e.fParam[Me.ipaEscX]), "41"])           ' X scale factor
    stxExport.insert([CStr(e.fParam[Me.ipaEscY]), "42"])           ' Y scale factor
    stxExport.insert([CStr(e.fParam[Me.ipaEscZ]), "43"])           ' Z scale factor
    stxExport.insert([CStr(e.fParam[Me.ipaRotacion]), "50"])       ' rotation

    stxExport.insert(["1", "70"])
    stxExport.insert(["1", "71"])
    stxExport.insert(["0", "44"])
    stxExport.insert(["0", "45"])

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer, b As Block

    ' tengo q presuponer que las escalas son = 1
    e.fParam[Me.ipaEscX] = 1    ' esc X
    e.fParam[Me.ipaEscY] = 1    ' esc Y
    e.fParam[Me.ipaEscZ] = 1    ' esc Z
    
    
        b = New Block
e.pBlock = b 'gcd.Drawing.Blocks[sValues[i]]
    
        i = dxf.ReadCodePlus(2, sClaves, sValues, ByRef b.name,,, 0)
        
        i = dxf.ReadCodePlus(10, sClaves, sValues, ByRef e.p[0],,, 0)
        i = dxf.ReadCodePlus(20, sClaves, sValues, ByRef e.p[1],,, 0)
        i = dxf.ReadCodePlus(41, sClaves, sValues, ByRef e.fParam[Me.ipaEscX],,, 0)
        i = dxf.ReadCodePlus(42, sClaves, sValues, ByRef e.fParam[Me.ipaEscY],,, 0)
        i = dxf.ReadCodePlus(43, sClaves, sValues, ByRef e.fParam[Me.ipaEscZ],,, 0)
        i = dxf.ReadCodePlus(50, sClaves, sValues, ByRef e.fParam[Me.ipaRotacion],,, 0)
        i = dxf.ReadCodePlus(66, sClaves, sValues, ByRef e.fParam[Me.ipaAttribs],,, 0)
        
    
    If e.fParam[Me.ipaEscZ] = 0 Then e.fParam[Me.ipaEscZ] = 1    ' esc Z
    ' esc Z
    'InsertParts(e, False)

    Return True

    '' catch

    Return False

End

'' Inserta las partes de un Insert en la coleccion de entidades
Public Function InsertParts(eInsert As Entity, bDontMoveThem As Boolean) As Boolean

    eInsert.pBlock.entities = GetPartsFromBlock(eInsert)

    Return True

End

'' Busca las entidades de un Block y las devuelve con los parametros del Insert
Public Function GetPartsFromBlock(eInsert As Entity) As Collection

    ' la geometria de un inserto implica
    Dim e, e2 As Entity
    Dim cParts As New Collection

    ' eInsert.pBlock.entities.Clear
    For Each e In gcd.Drawing.Blocks[eInsert.pBlock.name].entities
        If e.Gender = "ATTRIB" Then Continue                    ' esta entidad ya viene digerida en el DXF
        If e.Gender = "ATTDEF" Then Continue                    ' esta entidad ya viene digerida en el DXF
        If e.Gender = cadInsert.Gender Then
            For Each e2 In GetPartsFromBlock(e)
                If e.Gender = "ATTRIB" Then Continue                    ' esta entidad ya viene digerida en el DXF
                If e.Gender = "ATTDEF" Then Continue                    ' esta entidad ya viene digerida en el DXF      
            gcd.CCC[e2.gender].scale(e2, eInsert.fParam[cadInsert.ipaEscX], eInsert.fParam[cadInsert.ipaEscY])
            gcd.CCC[e2.gender].rotate(e2, eInsert.fParam[cadInsert.ipaRotacion])
            gcd.CCC[e2.gender].translate(e2, eInsert.p[0], eInsert.p[1])
            ' gcd.CCC[e2.gender].rotate(e2, eInsert.fParam[cadInsert.ipaRotacion])
            ' gcd.CCC[e2.gender].scale(e2, eInsert.fParam[cadInsert.ipaEscX], eInsert.fParam[cadInsert.ipaEscY])
    'e2.IdContainer = eInsert.Id
                cParts.Add(e2, e2.Id)
            Next
        Else

            e2 = clsEntities.ClonEntity(e)
            e2.IdContainer = eInsert.Id
            gcd.CCC[e2.gender].scale(e2, eInsert.fParam[cadInsert.ipaEscX], eInsert.fParam[cadInsert.ipaEscY])
            gcd.CCC[e2.gender].rotate(e2, eInsert.fParam[cadInsert.ipaRotacion])
            gcd.CCC[e2.gender].translate(e2, eInsert.p[0], eInsert.p[1])
            ' gcd.CCC[e2.gender].rotate(e2, eInsert.fParam[cadInsert.ipaRotacion])
            ' gcd.CCC[e2.gender].scale(e2, eInsert.fParam[cadInsert.ipaEscX], eInsert.fParam[cadInsert.ipaEscY])

            ' llamo recursivamente en caso que sea inserto
            cParts.Add(e2, e2.Id)  ' tambien guardo una referencia aqui
        End If

    Next

    Return cParts

End

' '' Mueve las entidades de un insert a su posicion final
' Public Function MoveInsertParts(eInsert As Entity)
' 
'     Dim e As Entity
' 
'     For Each e In eInsert.pBlock.entities
'         'If e.Gender = "ATTRIB" Then Continue
'         gcd.CCC[e.gender].translate(e, eInsert.p[0], eInsert.p[1])
'         gcd.CCC[e.gender].rotate(e, eInsert.fParam[cadInsert.ipaRotacion])
'         gcd.CCC[e.gender].scale(e, eInsert.fParam[cadInsert.ipaEscX], eInsert.fParam[cadInsert.ipaEscY])
'     Next
' 
' End

Public Sub Finish(oE As Entity) As Boolean

    InsertParts(oe, True)
    'MoveInsertParts(oe)

    ' tareas finales de armado del objeto
    Me.BuildPOI(oe)

    'Me.BuildGeometry(oe)

    oE.psel.resize(oE.p.count / 2)

    'oE.Selected = False

End
