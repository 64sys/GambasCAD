' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA

Create Static

Public inxBuffersID As New Integer[]

'' Changes the properties of the seleccted entities with given values
Public Function EditEntities(sProperty As String, vValue As Variant, Optional DoRegen As Boolean = True, cEntities As Collection = gcd.Drawing.EntitiesSelected) As Boolean

    Dim e As Entity

    gcd.Drawing.uUndo.OpenUndoStage(sProperty, Undo.TypeModify)

    For Each e In cEntities
        gcd.Drawing.uUndo.AddUndoItem(clsEntities.ClonEntity(e, False))
        Select Case sProperty

            Case "color"
                e.colour = vValue

            Case "linewidth"

                e.LineWidth = vValue
            Case "layer"

                e.pLayer = gcd.GetLayer(vValue)

            Case "linetype"
                e.LineType = vValue

            Case "points"
                e.p = vValue

        End Select
    Next

    gcd.Drawing.uUndo.CloseUndoStage()
    If DoRegen Then gcd.Regen()

End

Public Sub DrawArrays()

    Dim iError, vOffset, nOffset, cOffset, tOffset As Integer

    If inxBuffersID.Count = 0 Then Return

    glx.glBindBuffer(glc.ARRAY_BUFFER, inxBuffersID[0])

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)
    glx.glEnableClientState(glc.VERTEX_ARRAY)
    glx.glEnableClientState(glc.NORMAL_ARRAY)
    glx.glEnableClientState(glc.COLOR_ARRAY)

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)

    vOffset = 0
    nOffset = glPlus.VBO_vertex.Count * SizeOf(gb.Single)
    cOffset = nOffset + glPlus.VBO_normals.Count * SizeOf(glPlus.VBO_normals.Type)
    'tOffset = cOffset + sizeof colors

    glx.glVertexPointer(3, glc.FLOAT, 0, vOffset)
    glx.glNormalPointer(glc.FLOAT, 0, nOffset)
    glx.glColorPointer(3, glc.FLOAT, 0, cOffset)

    iError = glx.glGetError()
    If iError <> 0 Then gcd.debuginfo("GL Error: " & iError)

    glx.glDrawArrays(glc.LINES, 0, glPlus.VBO_vertex.Count * 3)

    glx.gldisableClientState(glc.VERTEX_ARRAY)
    glx.gldisableClientState(glc.NORMAL_ARRAY)
    glx.gldisableClientState(glc.COLOR_ARRAY)

    glx.glBindBuffer(glc.ARRAY_BUFFER, 0)

End

Public Function FIndBlockIDbyid(Blockid As String) As Block

    Dim B As Block

    For Each B In gcd.Drawing.Blocks
        If B.id = Blockid Then Return B
    Next
    Return Null

End

Public Function FIndBlock(BlockName As String, cContainer As Collection) As Block

    Dim b As Block

    For Each b In cContainer
        If b.name = BlockName Then Return b
    Next
    Return Null

End

Public Function FindStyle(sName As String) As Style

    Dim b As Style

    For Each b In gcd.Drawing.oStyles
        If b.name = sName Then Return b
    Next
    Return

End

' Public Sub setEntity(e As Entity)
'
'     Try e.iParam.Resize(gcd.CCC[e.gender].iTotalParams)
'     Try e.fParam.Resize(gcd.CCC[e.gender].fTotalParams)
'     Try e.StringData.Resize(gcd.CCC[e.gender].sdaTotalParams) ' text, style
'     Try e.P.Resize(gcd.CCC[e.gender].TotalPoints * 2)
'
' End

Public Function ReconstruirBloques() As Boolean

    ' busco bloques y coloco puntos de referencias
    ' Armamos los bolques, que extraemos de las entidades
    Dim i, i2 As Integer, PartesEncontradas As Boolean, iStart As Integer
    Dim t As Float = Timer

    gcd.debuginfo("Recostruyendo bloques")

    For i = 0 To gcd.Drawing.Entities
        DrawingAids.CmdLineHelper = ("Loading blocks ") & Format$(i / gcd.Drawing.Entities, "0.00%")
        Wait 0.0001
        If gcd.Drawing.Entities[i].gender = "BLOCK" Then
            Dim newBlock As New Block
            newBlock.name = gcd.Drawing.Entities[i].block
            newBlock.x = gcd.Drawing.Entities[i].p[0]
            newBlock.y = gcd.Drawing.Entities[i].p[1]
            newBlock.entities = New Collection
            ' busco los objetos de este bloque y los reconstruyo
            For i2 = iStart To gcd.Drawing.Entities
                If gcd.Drawing.Entities[i2].block = newBlock.name And gcd.Drawing.Entities[i2].gender <> "BLOCK" Then ' sin recursividad en bloques
                    If gcd.Drawing.Entities[i2].block = newBlock.name And gcd.Drawing.Entities[i2].gender <> "INSERT" Then 'no quiero insertarme a mi mismo
                        PartesEncontradas = True
                        Dim o2 As Entity
                        o2 = ClonEntity(gcd.Drawing.Entities[i2])

                        Gcd.CCC[o2.gender].finish(o2)
                        newBlock.entities.Add(o2)
                    End If
                Else
                    If PartesEncontradas Then ' estaba armando un bloque, pero ya termine porque esta entidad es otra cosa
                        PartesEncontradas = False
                        iStart = i2
                        Break
                    End If

                Endif
            Next
            gcd.Drawing.arrBlocks.Add(newBlock)
        End If
    Next

    Wait 0.001
    Debug "Reconstruccion finalizada en ", Str$(Timer - t)

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenBuffers(Optional eEntity As Entity = Null)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i, iVbo As Integer, e As Entity

    If eEntity Then

        ' If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
        ' gl.NewList(eEntity.glDrwList, gl.COMPILE)
        ' eEntity.Gcd.CCC[e.gender].Draw(eEntity)
        ' gl.EndList
        '
        ' If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
        ' gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
        ' eEntity.Gcd.CCC[e.gender].DrawSelected(eEntity)
        ' gl.EndList

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        Dim iError As Integer
        ' listas de entidades
        glPlus.VBOFlush
        'glPlus.InmediateMode = False

        If gcd.Drawing.Entities.Count = 0 Then Return
        For Each e In gcd.Drawing.Entities

            'If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)
            'gl.NewList(e.glDrwList, gl.COMPILE)
            gcd.CCC[e.gender].Draw(e)
            'gl.EndList

        Next
        glPlus.InmediateMode = True

        Dim oneBufferID As Integer
        inxBuffersID.Resize(3)

        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)

        'glx.glGenBuffers(1, VarPtr(oneBufferID))
        glx.glGenBuffers(3, inxBuffersID.Data)                      ' genero un buffer ID
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        glx.glBindBuffer(glc.ARRAY_BUFFER, inxBuffersID[0])      ' lo conecto como Vertex Buffer
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        Dim BytesTotales As Integer
        BytesTotales = glPlus.VBO_vertex.Count + glPlus.VBO_normals.Count + glPlus.VBO_colors.Count
        BytesTotales *= SizeOf(gb.Single)

        ' Reservo espacio. 0 significa que despues le mando la data
        glx.glBufferData(glc.ARRAY_BUFFER, BytesTotales, 0, glc.STATIC_DRAW)
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        ' mando vertices
        glx.glBufferSubData(glc.ARRAY_BUFFER, 0, glPlus.VBO_vertex.Count * SizeOf(gb.Single), glPlus.VBO_vertex.Data)

        ' mando normales
        glx.glBufferSubData(glc.ARRAY_BUFFER, glPlus.VBO_vertex.Count * SizeOf(gb.Single), glPlus.VBO_normals.Count * SizeOf(gb.Single), glPlus.VBO_normals.Data)

        ' mando colores
        glx.glBufferSubData(glc.ARRAY_BUFFER, (glPlus.VBO_vertex.Count + glPlus.VBO_normals.Count) * SizeOf(gb.Single), glPlus.VBO_colors.Count * SizeOf(gb.Single), glPlus.VBO_colors.Data)
        iError = glx.glGetError()
        If iError <> 0 Then Print "GL Error:", Hex(iError)
        glx.glBindBuffer(glc.ARRAY_BUFFER, 0)      ' finlizo transferencia de datos a la GPU

        ' ' lista de entidaes seleccionadas
        ' For Each e In gcd.Drawing.oEntities
        '     If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
        '     gl.NewList(e.glDrwListSel, gl.COMPILE)
        '     gcd.CCC[e.gender].DrawSelected(e)
        '     gl.EndList
        ' Next
        '
        ' ' lista de todas las entidades
        ' t = Timer
        ' glGenDrawListLAyers
        '
        ' Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Genera las listas GL de cada entidad individual, y la version seleccionada
'' Borra la lista anterior y genera una nueva
Public Sub glGenDrawList(Optional eEntity As Entity = Null)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer, e As Entity, b As Block, s As Sheet

    If eEntity Then
        If Not eEntity Then Return
        If Not gl.islist(eEntity.glDrwList) Then eEntity.glDrwList = gl.GenLists(1)
        gl.NewList(eEntity.glDrwList, gl.COMPILE)
        Gcd.CCC[eEntity.gender].Draw(eEntity)
        gl.EndList

        If Not gl.islist(eEntity.glDrwListSel) Then eEntity.glDrwListSel = gl.GenLists(1)
        gl.NewList(eEntity.glDrwListSel, gl.COMPILE)
        Gcd.CCC[eEntity.gender].DrawSelected(eEntity)
        gl.EndList

        If Not gl.islist(eEntity.glDrwListRemark) Then eEntity.glDrwListRemark = gl.GenLists(1)
        gl.NewList(eEntity.glDrwListRemark, gl.COMPILE)
        Gcd.CCC[eEntity.gender].DrawRemark(eEntity)
        gl.EndList

    Else

        ' If Not gl.islist(gcd.CurrDrawing.GlListAllEntities) Then gcd.CurrDrawing.GlListAllEntities = gl.GenLists(1)
        Dim t As Float = Timer
        ' listas de entidades
        For Each s In gcd.Drawing.Sheets
            For Each e In s.Entities
                If Not e.Visible Then Continue

                If Not gl.islist(e.glDrwList) Then e.glDrwList = gl.GenLists(1)

                gl.NewList(e.glDrwList, gl.COMPILE)
                gcd.CCC[e.gender].Draw(e)
                gl.EndList

                If Not e.Visible Then Continue
                If Not gl.islist(e.glDrwListSel) Then e.glDrwListSel = gl.GenLists(1)
                gl.NewList(e.glDrwListSel, gl.COMPILE)
                gcd.CCC[e.gender].DrawSelected(e)
                gl.EndList

                If Not gl.islist(e.glDrwListRemark) Then e.glDrwListRemark = gl.GenLists(1)
                gl.NewList(e.glDrwListRemark, gl.COMPILE)
                Gcd.CCC[e.gender].DrawRemark(e)
                gl.EndList
            Next

            ' lista de todas las entidades
            t = Timer
            glGenDrawListLAyers
        Next
        Debug "GLlista de todas generada en  ", Timer - t
    End If

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListSel(Optional mode As Integer = 0)

    Dim idDrawing As Integer ' la instancia de dibujo en la que estamos
    Dim i As Integer, e As Entity

    If Not gl.islist(gcd.Drawing.GlListEntitiesSelected) Then gcd.Drawing.GlListEntitiesSelected = gl.GenLists(1)

    gl.NewList(gcd.Drawing.GlListEntitiesSelected, gl.COMPILE)

    For Each e In gcd.Drawing.EntitiesSelected

        If mode = 0 Then gl.CallList(e.glDrwListSel)
        If mode = 1 Then gl.CallList(e.glDrwList)

    Next

    gl.EndList

End

' '' Generates a GL list for the selected
' '' Mode: 0=Selected version 1=Normal version
' Public Sub glGenDrawListAll(Optional ExcludeSelected As Boolean = False)
'
'     Dim i As Integer, e As Entity
'
'     gl.NewList(gcd.Drawing.GlListAllEntities, gl.COMPILE)
'
'     For Each e In gcd.Drawing.Entities
'         If Not (e.Selected And ExcludeSelected) Then gl.CallList(e.glDrwList)
'
'     Next
'
'     gl.EndList
'
'     For Each L As Layer In gcd.Drawing.Layers
'         If Not gl.islist(L.glList) Then L.glList = gl.GenLists(1)
'         gl.NewList(L.glList, gl.COMPILE)
'     Next
'     For Each e In gcd.Drawing.Entities
'         If Not (e.Selected And ExcludeSelected) Then gl.CallList(e.glDrwList)
'
'     Next
'
'     gl.EndList
'     gcd.debugInfo("Lista de dibujo GL construida",,, True)
'
' End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
Public Sub glGenDrawListLAyers(Optional aLayer As Layer)

    Dim i As Integer
    Dim e As Entity, s As Sheet

    If aLayer Then

        If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
        gl.NewList(aLayer.glList, gl.COMPILE)
        For Each e In gcd.Drawing.Entities

            If e.pLayer = aLayer Then
                If Not e.PaperSpace Then

                    gl.CallList(e.glDrwList)
                Endif
            End If
        Next
        gl.EndList

    Else

        For Each aLayer In gcd.Drawing.Layers
            If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
            gl.NewList(aLayer.glList, gl.COMPILE)
            For Each s In gcd.Drawing.Sheets
                For Each e In s.Entities

                    If e.Gender = "HATCH" And Not gcd.DrawHatch Then Continue
                    If e.PaperSpace Then Continue

                    If e.pLayer = aLayer Then
                        gl.CallList(e.glDrwList)
                        If e.Gender = cadInsert.Gender And s.name = "Model" Then

                            Debug e.pBlock.name
                            If Left(e.pBlock.name, 1) = "A" Then Stop
                        End If
                    End If

                Next
            Next
            gl.EndList

        Next

    Endif

End

'' Generates a GL list for the selected
'' Mode: 0=Selected version 1=Normal version
' Public Sub glGenDrawListLAyers2(Optional aLayer As Layer)
'
'     Dim i As Integer
'     Dim e As Entity
'
'     If aLayer Then
'
'         If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
'         gl.NewList(aLayer.glList, gl.COMPILE)
'         For Each e In gcd.Drawing.oEntities
'
'             If e.pLayer = aLayer Then gl.CallList(e.glDrwList)
'
'         Next
'         gl.EndList
'
'     Else
'
'         For Each aLayer In gcd.Drawing.oLayers
'             If Not gl.islist(aLayer.glList) Then aLayer.glList = gl.GenLists(1)
'             gl.NewList(aLayer.glList, gl.COMPILE)
'             For Each e In aLayer.Entities
'                 gl.CallList(e.glDrwList)
'
'             Next
'             gl.EndList
'
'         Next
'
'     Endif
'
' End

Public Sub DrawPoiSymbolsAll()

    Dim i, total As Integer

    For Each e As Entity In gcd.Drawing.EntitiesSelected

        ' If (e.Gender = "INSERT") Then
        DrawPoiSymbols(e)
        Inc total
        ' End If
        '
        If total = 100 Then Break                           ' limitamos la cantidad de enganches a un numero sensato
    Next

End

Public Sub DrawPoiSymbols(oE As Entity)

    Dim i As Integer

    If IsNull(oe) Then Return

    For i = 0 To oe.PoiPoints.Max Step 2
        Select Case oe.PoiType[i / 2]
            Case gcd.poiEndPoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1,, 1)

            Case gcd.poiMidPoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1,, 1)

            Case gcd.poiCenter
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1,, 1)

            Case gcd.poiQuadrant
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Cyan, 1,, 1)

            Case gcd.poiBasePoint
                glPlus.Rectangle2D(oe.PoiPoints[i] - gcd.Metros(4), oe.PoiPoints[i + 1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Cyan,,,, Color.Blue, 1,, 1)

        End Select

    Next

End

Public Sub Finish(Optional selected As Boolean = True)

    ' creo copias de cada elemento seleccionado
    Dim m As Integer, E As Entity

    For Each E In gcd.Drawing.Entities
        If selected Then                                                    ' apply to only the selected ones
            If E.Selected Then gcd.CCC[e.gender].Finish(E)
        Else                                                                ' apply to all
            gcd.CCC[e.gender].Finish(E)
        End If

    Next

End

Public Sub ClonEntity(eOrigen As Entity, Optional GetNewid As Boolean = True) As Entity

    Dim e As Entity

    e = gcd.CCC[eOrigen.Gender].ClonEntity(eOrigen)
    If GetNewid Then e.id = gcd.Newid()
    Return e

End

Public Sub ClonElements(Optional cEntities As Collection, GenerateGlList As Boolean = True) As Collection

    ' creo copias de cada elemento seleccionado
    Dim E, eClon As Entity
    Dim cEntititesToClon As Collection
    Dim cContainer As New Collection

    If cEntities Then cEntititesToClon = cEntities Else cEntititesToClon = gcd.Drawing.EntitiesSelected

    For Each E In cEntititesToClon
        eClon = Me.ClonEntity(e, True)
        Gcd.CCC[eClon.gender].finish(eClon)
        If GenerateGlList Then glGenDrawList(eClon)
        cContainer.Add(eClon, eClon.id)

    Next
    Return cContainer

End

Public Function CopyBlock(bBase As Block) As Block

    Dim b As New Block
    Dim h As Hatch
    Dim s As SPline
    Dim e As Entity

    b.name = bBase.name
    b.description = bBase.description
    b.Explotability = bBase.Explotability
    b.Flags = bBase.Flags
    ' b.HandleAsociatedLayout = bBase.HandleAsociatedLayout
    ' b.HandleOwner = bBase.HandleOwner
    ' b.HandleOwnerParent = bBase.HandleOwnerParent
    b.InsertionPlace = bBase.InsertionPlace
    b.InsertUnits = bBase.InsertUnits
    b.layer = bBase.layer
    b.Scalability = bBase.Scalability
    b.x0 = bBase.x0
    b.y0 = bBase.y0
    b.z0 = bBase.z0

    b.entities = New Collection

    For Each e In bBase.entities
        b.entities.Add(ClonEntity(e), gcd.Newid())
    Next

    Return b

End

Public Function DeSelection(Optional elementos As String = "todo", Accion As String = "deseleccionar") As Integer
    ' Esta rutina analiza si los elemento seleccionados para alguna accion pueden realizarla, caso contrario los deselecciona
    ' se basa en los puntos que tengan la propiedad .Selected = True
    ' tambien puede deseleccionar todo
    ' Devuelve la cantidad de elementos que quedaron seleccionados despues de filtrar

    Dim i As Integer, c As Integer, Clase As String, iii As Integer

    ' por las dudas vengan alguna letra mayuscula
    If Accion = "" Then accion = "deseleccionar"
    accion = LCase(accion)
    elementos = LCase(elementos)

    '   primero vacio la seleccion anterior
    gcd.Drawing.EntitiesSelected.Clear

    For Each eTesting As Entity In gcd.Drawing.Entities

        clase = eTesting.Gender

        Select Case accion

            Case "mover", "copiar", "borrar", "escalar" ' necesito que todos los puntos esten seleccionados

                If SelFull() And (elementos = "todo" Or elementos = clase) Then

                    gcd.Drawing.EntitiesSelected.Add(eTesting, eTesting.id)
                    SelectElem(eTesting)
                    Inc i

                Else

                    DeSelectElem(eTesting)

                End If

            Case "estirar" ' necesito que dos puntos contiguos esten seleccionados

                If SelPArtial() And (elementos = "todo" Or elementos = clase) Then
                    gcd.Drawing.EntitiesSelected.Add(eTesting, eTesting.id)
                    SelectElem(eTesting, False) ' dont touch the points
                    Inc i

                Else

                    DeSelectElem(eTesting)

                End If

            Case "deseleccionar" ' todas las acciones

                If (elementos = "todo" Or elementos = clase) Then

                    Inc i
                    DeSelectElem(eTesting)

                End If

        End Select

    Next

    Return i

End

' Public Function GetSelectionCount() As Integer
'
'     Dim e As Entity
'
'     gcd.Drawing.oSelected.Clear
'     For Each e In gcd.Drawing.oEntities
'         If e.Selected Then
'
'             gcd.Drawing.oSelected.Add(e, e.handle)
'         End If
'     Next
'     Return gcd.Drawing.oSelected.Count
'
' End Function

Public Function DeleteSelected() As Integer

    Dim E As Entity, c As Integer
    Dim lay As Layer

    '  Purgue will also delete those with .ForDeletion = true

    For Each E In gcd.Drawing.Entities

        If E.Selected Then
            gcd.Drawing.Entities.Remove(gcd.Drawing.Entities.Key)
            Inc c
        End If

    Next

    '   we also need to regenerate the drawing list
    For Each lay In gcd.Drawing.Layers
        If lay.Visible Then glGenDrawListLayers(lay)
    Next

    ' we also need too recalculate visible items
    Me.CollectVisibleEntities()

    ' TODO: put something in UNDO collection

    Return c

End Function

Public Function SelectFromPoint(Xr As Float, Zr As Float, Optional Autoselect As Boolean = True) As Entity

    Dim i As Integer

    For i = gcd.Drawing.Entities To 0 Step -1
        ' last elements are drawn last so the click belongs to them
        If gcd.Drawing.Entities[i].pointClick(Xr, Zr) Then
            If Autoselect Then
                If Not gcd.Drawing.Entities[i].Selected Then
                    SelectElem(gcd.Drawing.Entities[i])
                Else
                    DeSelectElem(gcd.Drawing.Entities[i])
                End If
            End If
            Return gcd.Drawing.Entities[i]
        End If

    Next

End

Public Sub DrawPoint(x As Float, y As Float, Optional colour As Integer = -1, Optional LargoReal As Float = 0.4)

    If colour <> -1 Then
        paint.brush = Paint.Color(colour)
    Else
        paint.brush = Paint.Color(Color.Blue)
    End If
    paint.LineWidth = 1
    paint.MoveTo(x - LargoReal / 2, y)
    paint.RelLineTo(LargoReal, 0)

    paint.MoveTo(x, y - LargoReal / 2)
    paint.RelLineTo(0, -LargoReal)
    paint.Stroke

End

Public Sub SelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

    Dim i, ii As Integer

    eEntity.selected = True
    If AndItsPoints Then
        For i = 0 To eEntity.Psel.Max
            eEntity.Psel[i] = True
        Next

    End If
    gcd.Drawing.EntitiesSelected.Add(eEntity, eEntity.id)

End

Public Sub DeSelectElem(eEntity As Entity, Optional AndItsPoints As Boolean = True)

    ' deselect all points and myself

    Dim i, ii As Integer

    eEntity.selected = False
    If AndItsPoints Then
        For i = 0 To eEntity.Psel.Max
            eEntity.Psel[i] = False
        Next

    End If
    gcd.Drawing.EntitiesSelected.Remove(eEntity.id)

End

Public Sub Move(dX As Float, dY As Float, Optional cEntitiesToMove As Collection, OnlyPointSelected As Boolean = False)

    ' crea un backup de todos los puntos
    Dim e As Entity, i As Integer

    If Not cEntitiesToMove Then cEntitiesToMove = gcd.Drawing.EntitiesSelected

    For Each e In cEntitiesToMove

        gcd.CCC[e.gender].Translate(e, dX, dY, OnlyPointSelected)

    Next

End

Public Sub Rotate(e As Entity, degAngle As Float)

    gcd.CCC[e.gender].Rotate(e, degAngle)

End

Public Sub Translate(e As Entity, dX As Float, dY As Float)

    gcd.CCC[e.gender].Translate(e, dX, dY)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    gcd.CCC[e.gender].Scale(e, sX, sY)

End

' Public Sub Scale(sX As Float, sY As Float, Optional sZ As Float = 1, OnlySelected As Boolean = False, OnlyPointSelected As Boolean = False)
'
'     ' crea un backup de todos los puntos
'     Dim e As Entity, i As Integer
'
'     For Each e In gcd.Drawing.oEntities
'         If (e.selected And OnlySelected) Or Not OnlySelected Then
'
'             gcd.CCC[e.gender].Scale(e, sX, sY)
'
'         Endif
'
'     Next
'
' End

Public Function SelectionSquare(X1real As Float, Y1real As Float, X2real As Float, Y2real As Float, Optional NuevaSumaResta As String = "nueva", crossing As Boolean) As Integer

    ' Veo que accion estoy tomando
    Dim e As Entity, i, i2, TotalSeleccionados As Integer

    NuevaSumaResta = LCase$(NuevaSumaResta)

    If NuevaSumaResta = "nueva" Then ' nueva seleccion
        For Each e In gcd.Drawing.Entities
            e.selected = False
            For i2 = 0 To e.Psel.max
                e.Psel[i2] = False
            Next
        Next
        gcd.Drawing.EntitiesSelected.Clear
        TotalSeleccionados = 0
    End If

    For Each e In gcd.Drawing.Entities
        ' cada entidad debe decidir si esta seleccionada o no
        If crossing Then
            If SelPArtial(e, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(e, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(e, False)

                End If

            Endif
        Else
            If SelFull(e, X1real, Y1real, X2real, Y2real) Then
                ' el punto esta en el recuadro
                If NuevaSumaResta <> "resta" Then
                    Inc TotalSeleccionados
                    Me.SelectElem(e, False)

                Else If NuevaSumaResta = "resta" Then
                    Dec TotalSeleccionados
                    Me.DeSelectElem(e, False)

                End If

            Endif

        End If
    Next
    ' GetSelectionCount()

    ' deprecada
    ' GetSelectionHandles(gcd.Drawing.hSelection)

    Return TotalSeleccionados

End

'' Put all visible entity refs in arrVisibleEntities[]
Public Function CollectVisibleEntities(Optional sSheet As Sheet)

    Dim x0, y0, x1, y1 As Float
    Dim lay As Layer
    Dim e As Entity
    Dim i, tot As Integer
    Dim s As Sheet
    Dim ho As String

    gcd.flgsearchingallowed = False

    x0 = gcd.Xreal(0)
    y1 = gcd.Yreal(0)                     ' el eje Y esta invertido en OpenGL
    x1 = gcd.Xreal(gcd.ScreenWidth())
    y0 = gcd.Yreal(gcd.ScreenHeight())

    If Not sSheet Then sSheet = gcd.Drawing.Sheet

    'If gcd.Drawing.oEntities > gcd.Drawing.arrVisibleEntities.Max Then gcd.Drawing.arrVisibleEntities.Resize(gcd.Drawing.oEntities.Count)
    gcd.Drawing.EntitiesVisibles.Clear
    For Each e In sSheet.Entities 'gcd.Drawing.Entities
        If e.pLayer.Visible Then

            'If e.HandleOwner = ho Then

            If SelPArtial(e, x0, y0, x1, y1) Then

                gcd.Drawing.EntitiesVisibles.Add(e, e.id)

            End If
            'End If
        End If
    Next

    CollectDetectableEntities
    'gcd.debugInfo("Recolectadas las entidades visibles",,, True)
    gcd.flgSearchingAllowed = True

End

'' recolecta las entidades detectables de las entidades visibles

Public Function CollectDetectableEntities()

    Dim x0, y0, x1, y1 As Float
    Dim lay As Layer
    Dim e As Entity
    Dim i, tot As Integer

    For Each e In gcd.Drawing.EntitiesVisibles
        Select Case e.Gender
            Case "CIRCLE", "ARC", "SPline", "ELLIPSE"
                If Config.TrackEntityCurves Then e.Trackable = True Else e.Trackable = False
            Case "Mtext", "Text", "Attrib", "Attdef"
                If Config.TrackEntityTexts Then e.Trackable = True Else e.Trackable = False
            Case "INSERT"
                If Config.TrackEntityInserts Then e.Trackable = True Else e.Trackable = False
            Case "Hatch"
                If Config.TrackEntityHatches Then e.Trackable = True Else e.Trackable = False

            Case Like "Dim*"
                If Config.TrackEntityDim Then e.Trackable = True Else e.Trackable = False

        End Select
    Next

End

'Return bound limits for all verices in the array of entities
Public Sub BuildPoi(Optional entities As Collection, OnlyVisibles As Boolean = True)

    Dim e As Entity, i As Integer
    Dim entGroup As Collection

    If Not entities Then
        entGroup = gcd.Drawing.Entities
    Else
        entGroup = Entities
    End If

    If Not entGroup Then Return
    If entGroup.Count = 0 Then Return

    For Each e In entGroup
        If e.pLayer Then

            If (OnlyVisibles And e.pLayer.Visible) Or Not OnlyVisibles Then
                gcd.CCC[e.gender].BuildPoi(e)
            End If
        Else
            e.pLayer = gcd.Drawing.CurrLayer
            gcd.CCC[e.gender].BuildPoi(e)
        End If
    Next

End

'Return bound limits for all verices in the array of entities

Public Function ComputeLimits(Optional entities As Collection, OnlyVisibles As Boolean = True, IgnorePoints As Boolean = True, OnlyModel As Boolean = True) As Float[]

    Dim e As Entity, i As Integer
    Dim entGroup As Collection
    Dim Xmenor As Float = 1e10, Ymenor As Float = 1e10, Xmayor As Float = -1e10, Ymayor As Float = -1e10
    Dim newLimits As New Float[]
    Dim IsVisible As Boolean
    Dim a As Integer

    If Not entities Then entGroup = gcd.Drawing.Entities Else entGroup = Entities

    If entGroup.Count = 0 Then Return [0, 0, 0, 0]

    For Each e In entGroup
        If OnlyModel And e.PaperSpace Then Continue
        If OnlyVisibles Then
            If IsNull(e.pLayer) Then
                IsVisible = True
            Else
                IsVisible = e.pLayer.Visible
            End If

        Endif

        If IsVisible Then

            ' If e.Gender = "INSERT" Then
            '     If IsNull(e.pBlock) Then Continue
            '     newLimits = ComputeLimits(e.pBlock.entities)
            '     If IsNull(newLimits) Then Continue
            '     puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
            '     puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
            '     puntos.Translate(newLimits, e.P[0], e.P[1])
            '     If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
            '     If ymenor > newLimits[1] Then ymenor = newLimits[1]
            '     If Xmayor < newLimits[2] Then Xmayor = newLimits[2]
            '     If Ymayor < newLimits[3] Then Ymayor = newLimits[3]
            '
            '     'If (ymayor > 3000) And gcd.SnapMode Then Stop
            '     'End If
            '
            ' Else
            If e.Gender Like "DIM*" Then

                If IsNull(e.pBlock) Then Continue
                If IsNull(e.pBlock.entities) Then Continue
                newLimits = ComputeLimits(e.pBlock.entities)
                If IsNull(newLimits) Then Continue
                'puntos.Translate(newLimits, e.P[0], e.P[1])
                'puntos.Rotate(newLimits, e.fParam[cadInsert.ipaRotacion]) ' TODO: verificar orden de esta y la siguiente linea
                'puntos.Scale(newLimits, e.fParam[cadInsert.ipaEscX], e.fParam[cadInsert.ipaEscY])
                If Xmenor > newLimits[0] Then Xmenor = newLimits[0]
                If ymenor > newLimits[1] Then ymenor = newLimits[1]
                If Xmayor < newLimits[2] Then Xmayor = newLimits[2]
                If Ymayor < newLimits[3] Then Ymayor = newLimits[3]

                'If (Xmenor < 0) And gcd.SnapMode Then Stop
                ' End If

            Else If e.Polygon.Count > 0 Then

                For i = 0 To e.Polygon.max Step 2
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.Polygon[i] < Xmenor Then Xmenor = e.Polygon[i]

                    If e.Polygon[i + 1] < Ymenor Then Ymenor = e.Polygon[i + 1]

                    If e.Polygon[i] > Xmayor Then Xmayor = e.Polygon[i]

                    If e.Polygon[i + 1] > Ymayor Then Ymayor = e.Polygon[i + 1]

                    'If (Xmenor < 0) And gcd.SnapMode Then Stop

                Next
            Else If e.PolyLine.Count > 0 Then

                For i = 0 To e.PolyLine.max Step 2
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.PolyLine[i] < Xmenor Then Xmenor = e.PolyLine[i]

                    If e.PolyLine[i + 1] < Ymenor Then Ymenor = e.PolyLine[i + 1]

                    If e.PolyLine[i] > Xmayor Then Xmayor = e.PolyLine[i]

                    If e.PolyLine[i + 1] > Ymayor Then Ymayor = e.PolyLine[i + 1]

                    'If (Xmenor < 0) And gcd.SnapMode Then Stop

                Next
            Else If e.Gender = "POINT" Then

                If IgnorePoints Then Continue
                i = 0
                If e.p[i] < Xmenor Then Xmenor = e.p[i]

                If e.p[i + 1] < Ymenor Then Ymenor = e.p[i + 1]

                If e.p[i] > Xmayor Then Xmayor = e.p[i]

                If e.p[i + 1] > Ymayor Then Ymayor = e.p[i + 1]

            Else

                For i = 0 To e.p.max Step 2

                    If i > e.P.Max - 1 Then Break
                    'If e.p[i] > 0 Then Debug e.gender

                    If e.p[i] < Xmenor Then Xmenor = e.p[i]

                    If e.p[i + 1] < Ymenor Then Ymenor = e.p[i + 1]

                    If e.p[i] > Xmayor Then Xmayor = e.p[i]

                    If e.p[i + 1] > Ymayor Then Ymayor = e.p[i + 1]

                    'If (Xmenor < 0) And gcd.SnapMode Then Stop

                Next
            End If
        End If
        If Xmenor < 10 Then
            If e.Gender = "INSERT" Then

                a = 1
            End If

        End If
        ' If Xmayor > 425 Then Stop

    Next

    Return [Xmenor, Ymenor, Xmayor, Ymayor]

End

'' Determines if the entity was selected by a rectanle surrounding al points
'' by default, if ALL points are selected, it can.
Public Function SelFull(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim ii As Integer, puedo As Boolean

    Select Case eTesting.Gender

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que todos los puntos esten dentro
            If eTesting.Polygon.Count > 0 Then

                Return puntos.IsPoligonInsideRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)
            Else If eTesting.PolyLine.Count > 0 Then
                Return puntos.IsPoligonInsideRect(eTesting.PolyLine, X1real, Y1real, X2real, Y2real)

            Else    ' no tengo un poligono, entonces verifico que todos los puntos definitorios de al entidad esten dentro

                If eTesting.p.Count > 0 Then puedo = True Else puedo = False                     ' supongamos que puedo, por ahora, si hay puntos
                For ii = 0 To eTesting.p.max Step 2
                    If ii + 1 > eTesting.p.max Then Break
                    If Not ((eTesting.p[ii] >= X1real And eTesting.p[ii] <= X2real) And (eTesting.p[ii + 1] >= Y1real And eTesting.p[ii + 1] <= Y2real)) Then
                        puedo = False
                    End If
                Next

                If puedo Then
                    For ii = 0 To eTesting.PSel.Max
                        eTesting.PSel[ii] = True
                    Next

                    Return True
                Else
                    For ii = 0 To eTesting.PSel.Max
                        eTesting.PSel[ii] = False
                    Next

                    Return False
                End If
            Endif
    End Select

End

'' Determines if the entity
'' by default, if ANY point is selected, it can.
Public Function SelPartial(eTesting As Entity, X1real As Float, Y1real As Float, X2real As Float, Y2real As Float) As Boolean

    Dim ii As Integer, puedo As Boolean = False
    Dim oLoop As Hatch, flxPoly As Float[]

    Select Case eTesting.Gender

        Case "Hatch"

            'For Each oLoop In eTesting.pBlock

            For Each flxPoly In eTesting.pBlock.Polylines

                puedo = puntos.IsPoligonInsideRect(flxPoly, X1real, Y1real, X2real, Y2real)
                If puedo Then Break

                puedo = puntos.IsPoligonCrossingRect(flxPoly, X1real, Y1real, X2real, Y2real)
                If puedo Then Break
            Next
            'Next

        Case Else

            ' Si tengo un bounding poligon, entonces verifico que todos los puntos esten dentro
            If eTesting.Polygon.Count > 0 Then

                ' Si tengo un bounding poligon, entonces verifico que alguna linea lo cruce

                puedo = puntos.IsPoligonInsideRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)
                If puedo Then Return True

                Return puntos.IsPoligonCrossingRect(eTesting.Polygon, X1real, Y1real, X2real, Y2real)

            Else If eTesting.PolyLine.Count > 0 Then
                puedo = puntos.IsPoligonInsideRect(eTesting.PolyLine, X1real, Y1real, X2real, Y2real)
                If puedo Then Return True

                Return puntos.IsPoligonCrossingRect(eTesting.PolyLine, X1real, Y1real, X2real, Y2real)

            Else
                ' si cualquier linea cruza alguna linea de la eentiidad, esta queda seleccionada

                For Ii = 0 To eTesting.p.max Step 2
                    If ii + 1 > eTesting.p.max Then Break
                    If ii / 2 > eTesting.Psel.Max Then Break
                    If ((eTesting.p[iI] >= X1real And eTesting.p[Ii] <= X2real) And (eTesting.p[iI + 1] >= Y1real And eTesting.p[iI + 1] <= Y2real)) Then
                        eTesting.PSel[iI / 2] = True
                        puedo = True
                    End If

                Next

                If puntos.IsPoligonCrossingRect(eTesting.p, X1real, Y1real, X2real, Y2real) Then puedo = True
            End If

    End Select

    If puedo Then

        Return True
    Else
        Return False
    End If

End

' Public Function GetParentBlock(iEntity As Integer) As Integer
'
'     Dim iParent As Integer
'
'     iParent = iEntity
'     Do
'
'         If gcd.CurrDrawing.arrEntities[iParent].iInsert >= 0 Then
'             If iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert Then Break
'             iParent = gcd.CurrDrawing.arrEntities[iParent].iInsert
'         Else
'             Break
'         End If
'
'     Loop
'
'     Return iParent
'
' End

'' Imports data from a collection to an entity. True if the entity is handled by GambasCAD at this version,
'' False if entity couldn't be created for some reason.
Public Function DXFImportToEntity(c As Collection, Optional IsDummy As Boolean = False) As Entity

    Dim clsidr As Object
    Dim sClass As Class
    Dim sClave As New String[]
    Dim sValue As New String[]
    Dim lpValue, lpclave As String
    Dim i As Integer
    Dim GotEntity As Boolean
    Dim e As Entity
    Dim LT As LineType

    dxf.DigestColeccion(c, ByRef sClave, ByRef sValue)

    e = gcd.CCC[c[dxf.codEntity]].newEntity()
    ' llenamos Common data:
    Try e.pLayer = GetLayerByName(c[dxf.codLayer])
    e.id = c[dxf.codid]

    ' for testing FIXME: ojo con esto!!!
    '    If e.handle = "129D" Then Stop

    e.idContainer = dxf.ReadCodeFromCol(c, dxf.codidContainer)
    Try e.colour = c[dxf.codColor]            ' no es obligatorio
    Try e.LineWidth = c[dxf.codLWht] / 100    ' por eso el try
    ' 67 Absent or zero indicates entity is in model space. 1 indicates entity is in paper space (optional).
    If c.Exist("67") Then ' no es obligatorio

        If c["67"] = "1" Then e.PaperSpace = True
    End If
    If e.LineWidth < 1 Then e.LineWidth = 1
    If c.Exist(dxf.codLType) Then
        LT = GetLTypeByName(c[dxf.codLType])
        If LT Then
            e.LineType = LT
        Else
            e.LineType = gcd.Drawing.LineTypes[gcd.Drawing.LineTypes.First]
        End If
    Else
        e.LineType = gcd.Drawing.LineTypes[gcd.Drawing.LineTypes.First]

    End If
    If gcd.CCC[e.gender].ImportDXF(e, sClave, sValue) Then

        'If gcd.CCC[e.gender].gender <> "Hatch" Then gcd.CCC[e.gender].Finish(e)
        gcd.CCC[e.gender].Finish(e)

        Return e

    Else

        Return Null

    End If

    ' Catch
    'gcd.CCC[e.gender] = cadDummy
    Return Null

End

Public Function GetEntityIndex(dDrawing As Drawing, sid As String, Optional iStart As Integer = 0) As Integer

    Dim i As Integer

    For i = iStart To dDrawing.Entities

        If dDrawing.Entities[i].id = sid Then Return i

    Next

    Return -1           ' no hay handle asociada a esa entidad

End

Public Sub DXFExportCommonCol(e As Entity, ByRef cExported As String[])

    cExported.Add(e.Gender)
    cExported.Add(dxf.codEntity)
    cExported.add(e.id)
    cExported.Add(dxf.codid)
    cExported.add("")   ' se agrega despues
    cExported.Add(dxf.codidContainer)
    cExported.Add("AcDbEntity")
    cExported.Add("100")
    cExported.Add(e.pLayer.Name)
    cExported.Add(dxf.codLayer)
    cExported.Add(e.LineType.Name)
    cExported.Add(dxf.codLType)
    cExported.Add(e.colour)
    cExported.Add(dxf.codColor)
    cExported.Add(CStr(e.LineWidth))
    cExported.Add(dxf.codLWht)

End

' '' Imports data from a collection to an entity. True if the entity is handled by GauchoCAD at this version,
' '' False if entity couldn't be created for some reason.
' Public Function ImportJsonToEntity(c As JSONCollection, Optional IsDummy As Boolean = False) As Entity
'
'     Dim clsHandler As Object
'     Dim e As Entity
'
'     ' If Not c.Exist("entity") Then Return False
'     ' If Not c "entity") Then Return False
'     If IsDummy Then
'         clsHandler = cadDummy
'     Else
'         clsHandler = Object.New("cad" & c["entity"])  ' obtenemos el tipo de entidad y buscamos su clase. Si no manjemos esa entidad, esto de error.
'
'     End If
'
'     e = clsHandler.newEntity() ' le pedimos a la clase que arme un objeto Entity para agregar al Drawing actual
'     If clsHandler.ImportJSONCol(c, e) Then
'         ' llenamos Common data:
'         e.player = GetLayerByHandle(c["layer"][3])  ' busco el layer por nombre
'         e.Handle = c["handle"][1]
'         If e.pLayer = Null Then Stop
'         If TypeOf(c["color"]) = gb.Object Then
'             Try e.colour = c["color"]["index"]    ' FIXME: esto sigue dando error
'         Else
'             Try e.colour = c["color"]
'         Endif
'         e.LineWidth = c["linewt"] / 100
'         If e.LineWidth < 1 Then e.LineWidth = 1
'         e.LineType = GetLTypeByIndex(c["ltype_flags"])
'         If Not e.LineType Then
'             e.LineType = gcd.Drawing.oLTypes[gcd.Drawing.oLTypes.First]
'         End If
'
'         clsHandler.Finish(e)
'
'         Return e
'
'     Else
'
'         Return Null
'
'     End If
'
'     'Catch
'     'gcd.CCC[e.gender] = cadDummy
'     Return False
'
' End

Public Function GetLTypeByName(sName As String) As LineType

    Dim LT As LineType

    For Each LT In gcd.Drawing.LineTypes

        If LCase(LT.Name) = LCase(sname) Then Return LT

    Next

    Return Null

End

Public Function GetLTypeByIndex(sName As String) As LineType

    Dim lt As LineType

    For Each lt In gcd.Drawing.LineTypes

        If LCase(lt.Name) = LCase(sname) Then Return lt

    Next

    Return Null

End

Public Function GetLayerByid(sid As String) As Layer

    Dim Lay As Layer

    For Each Lay In gcd.Drawing.Layers

        If Lay.id = sid Then Return Lay
    Next
    Return Null

End

Public Function GetLayerByName(LayerName As String) As Layer

    Dim Lay As Layer

    For Each Lay In gcd.Drawing.Layers

        If Lay.Name = LayerName Then Return Lay
    Next
    Return Null

End

'' Reads entities and fill arrLayers
' Public Sub FillLayersWithEntities(oDrawing As Drawing)
'
'     Dim hLay As Layer
'     Dim e As Entity
'
'     ' primero eliminamos lo q haya
'     For Each hLay In oDrawing.Layers
'         hLay.Entities.Clear
'     Next
'
'     If oDrawing.Entities Then
'         For Each e In oDrawing.Entities
'             'e.pLayer = CurrDrawing.arrLayers[gcd.FindLaIndex(e.pLayer)]
'             e.pLayer.Entities.Add(e)
'         Next
'     End If
'     ' Esto ya no es posible con Colecciones
'     'Drawing.oVisibleEntities.Resize(Drawing.oEntities.Count)
'     gcd.debugInfo("Llenados los Layers con las entidades",,, True)
'
' End

'' Devuelve una entidad recortada de la original que esta dentro del recuadro provisto
'' o null si la enidad base queda afuera del recuadro
Public Function TrimmedEntity(eBase As Entity, x0 As Float, y0 As Float, X1 As Float, Y1 As Float) As Entity
    ' vamos a considerar que x0,y0 son coordenadas inferior-izquierda (como openGL, no como Paint)

    If Me.SelFull(eBase, x0, y0, x1, y1) Then Return eBase

    If Me.SelPartial(eBase, x0, y0, x1, y1) Then
        Return eBase

    Else ' la entidad esta completamente fuera del recuadro

        Return Null
    Endif

End

'' Convierte una Entity a JSON a efectos de ser usada con el Clipboard
'' No se incluye informacion propia del Drawing, solo de las entidades.
Public Sub EntityToJsonString(e As Entity) As String

    Dim j As New JSONCollection
    Dim s As String

    j.Add(e.Gender, "Entity")
    j.Add(e.p, "Points")                    '' X,Y pairs
    j.Add(e.sParam, "ParamString")      '' Array of Strings
    j.Add(e.fparam, "ParamFloat")           '' Array of floats
    j.Add(e.iParam, "ParamInt")             '' Array of integers
    j.Add(e.Colour, "Color")                '' CAD color code
    j.Add(e.LineWidth, "LineWidth")
    Try j.Add(e.LineType.Name, "LineType")
    Try j.Add(e.pStyle.name, "Style")
    Try j.Add(e.pDimStyle.name, "DimStyle")

    s = JSON.encode2(j)
    Return s

End
