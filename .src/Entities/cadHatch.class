' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast
Inherits EntityBase
Public Const Gender As String = "HATCH"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = ("Hatch")
Public Const ParamType As String = "PTF"                             ' that is Point, Point, Float; could be Color Text, etc
Public Const ParamHelper As String = "Point;Texture;Scale"      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = " ;Concrete;1"
Public Const USEWITH As String = "HATCHBUILDER"

Public Const DXF_Export As Boolean = False

' fParam helpers
Public Const TotalParams As Integer = 10
Public Const ipaSolid As Integer = 0
Public Const ipaAsociativity As Integer = 1
Public Const ipaTotalLoops As Integer = 2
Public Const ipaRotation As Integer = 3
Public Const ipaScale As Integer = 4
Public Const ipaParity As Integer = 5
Public Const ipaPatternType As Integer = 6
Public Const ipaBoundaryType As Integer = 7 ' 0=lwpolyine, 1=lines, 2=circular arc, 3=ellipse arc, 4=spline

' stringdata helpers
Public Const sdaTotalParams As Integer = 2
Public Const sdaPattern As Integer = 0
Public Const sdaPaternFile As Integer = 1

Public Xmenor As Float = 1e10
Public Ymenor As Float = 1e10
Public Xmayor As Float = -1e10
Public Ymayor As Float = -1e10

' Parametros de la entidad:

' P[]:        son los puntos de la polilinea que define el contorno del sombreado
' fParam[0]:  escala del sombreado
' fParam[1]:  angulo
' StringData[0]: nombre del patron del sombreado
'' Builds the geometry of the entity wthout drwing it
Public Function BuildGeometry(E As Entity, Optional density As Float)

    Dim flxContorno As Float[]

    MakeBorder2(e.pBlock)

    If LCase(e.sParam[Me.sdaPattern]) <> "solid" Then

        FillEntityWithHatch4(e)

    Else

        ' para solidos, tengo que hacer una llamada para cada loop de borde
        ' tengo q ver cuantos puntos tiene cada loop
        ' Ojo con LibreCAD
        'For Each e.pBlock In hData

        For Each flxContorno In e.pBlock.PolyLines
            e.Polygon.Insert(puntos.PolygonTriangulation(flxContorno))
        Next

    End If

End

Public Sub Draw(oE As Entity)

    Dim i, iLoop, iStart, iColour As Integer
    Dim fBorder As New Float[]

    Dim E2 As Entity

    If Not oE.Visible Then Return

    'BuildGeometry(oe)

    If LCase(oe.sParam[Me.sdaPattern]) <> "solid" Then
        iColour = gcd.GetGBColor(oE.Colour, oe.pLayer)
        GLplus.Lines(oE.PolyLine, iColour, oE.LineWidth, oE.LineType.TrameLength)

        gl.Begin(gl.POINTS)

        For i = 0 To oE.PolyLine.Max - 3 Step 4
            If (oE.PolyLine[i] = oE.PolyLine[i + 2]) And (oE.PolyLine[i + 1] = oE.PolyLine[i + 3]) Then
                glPlus.glColorRGB(iColour)
                gl.Vertex2f(oE.PolyLine[i], oE.PolyLine[i + 1])
            End If

        Next
        gl.end

    Else

        ' para solidos, tengo que hacer una llamada para cada loop de borde
        ' tengo q ver cuantos puntos tiene cada loop
        ' Ojo con LibreCAD
        'For Each oLoop In ohData

        ' obtengo el poligono de bordes
        ' fBorder.Clear
        ' fBorder.Insert(oLoop.e.PolyLine.Copy(iStart, oe.iParam[iLoop]))
        ' iStart += fBorder.Count

        'glPlus.Polygon(oLoop.Polyline, Color.Yellow, 2)
        ' If oloop.Polylines.Count = 0 Then Return
        '
        ' If puntos.IsPoligonSelfIntersecting(oLoop.Polylines[0]) Then
        '
        '     Debug "A polygon in HATCH is self intersecting"
        ' Endif

        glPlus.TRIANGLES(oe.Polygon, gcd.GetGBColor(oE.Colour, oe.pLayer), gcd.GetGBColor(oE.Colour, oe.pLayer))

        'Next

    End If

End

'' A fat version of the line
Public Sub DrawSelected(oE As Entity)



    Dim oBound As Float[]

    For Each oBound In oe.pBlock.Polylines

        GLplus.Lines(oBound, config.WindowBackColor, oE.LineWidth, gcd.stiDashed)
        GLplus.Lines(obound, config.ColorForSelected, oE.LineWidth, oE.LineType.TrameLength)
    Next

    GLplus.Lines(oE.PolyLine, config.ColorForSelected)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)



    Dim oBound As Float[]

    For Each oBound In oe.pBlock.Polylines

        GLplus.Lines(oBound, config.WindowBackColor, oE.LineWidth, gcd.stiDashed)
        GLplus.Lines(obound, config.ColorForSelected, oE.LineWidth, oE.LineType.TrameLength)
    Next


    GLplus.Lines(oE.PolyLine, gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth + 1)

End

Public Function Draw2(oE As Entity)

    Dim iLoop, iStart As Integer
    Dim fBorder As New Float[]

    If oe.sParam[1] <> "Solid" Then

        paintPlus.Lines(oE.PolyLine)
    Else
        Paint.Polygon(oe.PolyLine)

    End If

End

'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity) As Integer

    ' si este valor no es provisto , estos POI son de la ultima entidad
    Dim i As Integer

    Return
    oe.PoiPoints.Clear
    oe.poiPoints.insert([oE.P[0], oE.P[1]])
    oe.poiType.Add(gcd.poiEndPoint)
    'oe.poiEntities.Add(arrIndex)

    For i = 0 To oE.P.count - 4 Step 2

        oe.poiPoints.insert([(oE.P[i + 0] + oE.P[i + 2]) / 2, (oE.P[i + 1] + oE.P[i + 3]) / 2])   ' mid
        oe.poiType.Add(gcd.poiMidPoint)
        'oe.poiEntities.Add(arrIndex)

        oe.poiPoints.insert([oE.P[i + 2], oE.P[i + 3]])
        oe.poiType.Add(gcd.poiEndPoint)
        'oe.poiEntities.Add(arrIndex)

        ' line
        'gcd.CurrDrawing.poiLines.insert([oE.p[i], oE.p[i + 1], oE.p[i + 2], oE.p[i + 3]])
        'gcd.CurrDrawing.poiLinesEntities.Add(arrIndex)
        ' gcd.CurrDrawing.poiLinesRelPoint.Insert([i / 2, i / 2 + 1])

    Next

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    cadLWPolyline.Translate(e, dX, dY, OnlySelected)
    puntos.Translate(e.PolyLine, dx, dy)

End

Public Sub Rotate(e As Entity, radians As Float)

    cadLWPolyline.Rotate(e, radians)
    puntos.Rotate(e.PolyLine, radians)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    cadLWPolyline.Scale(e, sx, sy)
    puntos.Scale(e.PolyLine, sx, sy)

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i, iPattern, iLoop, iPoints, iBorderObjects, iBoundaryObject As Integer
    Dim LoopToRead As Integer
    Dim LoopType As Integer
    Dim EdgesToRead As Integer
    Dim EdgeType As Integer
    Dim eContour As Entity
    Dim edge As Integer
    Dim NewPath As Hatch
    Dim oPattern As Pattern
    ' Dim jscPath, vSeg As JSONCollection
    Dim RefObjHandle As String
    Dim DashLength, fVar As Float
    Dim hData As Hatch
    Dim Dashes As Integer

    ' vamos a agrupar las entidades que forman el contorno en un bloque
    e.pBlock = New Hatch
    NewPath = e.pBlock

    NewPath.eSegments = New Entity[]
    'NewPath.sHandles = New String[]

    'If e.Handle = "567A1" Then Stop

    'For i = 0 To sClaves.Max
    i = -1
    Do While i < sClaves.max    ' en este importador usare un do-loop en vez de un for-next por la complejidad del hatch
        Inc i

        If sClaves[i] = "91" Then
            e.fParam[Me.ipaTotalLoops] = CFloat(sValues[i])
            LoopToRead = e.fParam[Me.ipaTotalLoops]
        End If

        If LoopToRead > 0 Then

            Inc i

            ' para Debug
            ' If LoopToRead = 21 Then Stop

            For iLoop = 0 To LoopToRead - 1 'descubri que un Loop puede o no ser un area a rellenar distinta, a veces un Loop es un agujero de otro Loop

                ' NewPath = hData
                ' 'hData.Add(NewPath)
                '
                ' NewPath.eSegments = New Entity[]
                ' NewPath.sHandles = New String[]
                Dec LoopToRead
                ' estas claves definen el borde

                i = dxf.ReadCode(92, sClaves, sValues, ByRef LoopType, i)

                NewPath.Flag = LoopType
                ' If i = True Then Stop
                If (LoopType And 2) <> 2 Then ' otherwise is a polyline
                    Inc i

                    i = dxf.ReadCode(93, sClaves, sValues, ByRef EdgesToRead, i)
                    If i = True Then Stop
                    For edge = 0 To EdgesToRead - 1

                        i = dxf.ReadCode(72, sClaves, sValues, ByRef EdgeType, i)
                        If i = True Then Stop

                        ' segun el tipo de edge, agrego una entidad al bloque que
                        ' forma el contorno
                        eContour = New Entity
                        ' a esta entidad que es un borde le etiquetamos el loop al que pertenece

                        NewPath.eSegments.Add(eContour, CStr(i))
                        Select Case EdgeType
                            Case 0  ' invalido

                                Stop

                            Case 1 ' lines

                                eContour.Gender = cadLine.Gender
                                ' leo los dos puntos
                                Inc i
                                If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "11" Then eContour.P.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "21" Then eContour.P.Add(CFloat(sValues[i]))
                            Case 2 ' arc o circle

                                eContour.Gender = cadArc.Gender
                                Inc i
                                If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "50" Then eContour.fParam.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "51" Then eContour.fParam.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "73" Then eContour.fParam.Add(CFloat(sValues[i]))
                            Case 3 ' ellipse

                                eContour.Gender = cadEllipse.Gender
                                Inc i
                                If sClaves[i] = "10" Then eContour.P.Add(CFloat(sValues[i]))     ' centro
                                Inc i
                                If sClaves[i] = "20" Then eContour.P.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "11" Then eContour.P.Add(CFloat(sValues[i]) + eContour.P[0])     ' eje mayor, relativo al centro
                                Inc i
                                If sClaves[i] = "21" Then eContour.P.Add(CFloat(sValues[i]) + eContour.P[1])
                                Inc i
                                If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
                                Inc i
                                If sClaves[i] = "50" Then eContour.fParam.Add(CFloat(sValues[i]) * 180 / Pi)

                                ' esto soluciona un proble de unidades de LibreCAD
                                If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
                                    eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
                                Endif
                                Inc i
                                If sClaves[i] = "51" Then eContour.fParam.Add(CFloat(sValues[i]) * 180 / Pi)

                                ' esto soluciona un proble de unidades de LibreCAD
                                If eContour.fParam[eContour.fParam.Max] > 2 * Pi Then
                                    eContour.fParam[eContour.fParam.Max] /= (360 / 2 / Pi)
                                Endif
                            Case 4 ' spline
                                ' 94 Degree
                                ' 73 Rational
                                ' 74 Periodic
                                ' 95 Number of knots
                                ' 96 Number of control points
                                ' 40 Knot values (multiple entries)
                                ' 10 Control point (in OCS) 20 Y value of control point (in OCS)
                                ' 42 Weights (optional, default = 1)
                                ' 97 Number of fit data
                                ' 11 Fit datum (in OCS) 21
                                ' 12 Start tangent 22
                                ' 13 End tangent 23
                                '                             eContour.Gender = cadSPLine.Gender
                                '                             ' COPIO Y PEGO DE CADSPLINE, CAMBIANDO LAS CLAVES
                                '
                                ' If sClaves[i] = "94" Then eContour.fParam[Me.ipaDegree] = CInt(sValues[i])
                                ' If sClaves[i] = "73" Then eContour.fParam[Me.ipaFlag] = CInt(sValues[i])
                                ' If sClaves[i] = "95" Then eContour.fParam[Me.ipaTotalKnots] = CInt(sValues[i])
                                ' If sClaves[i] = "96" Then eContour.fParam[Me.ipaTotalControlPoints] = CInt(sValues[i])
                                '
                                ' If sClaves[i] = "74" Then eContour.fParam[Me.ipaTotalFitPoints] = CInt(sValues[i])
                                ' If sClaves[i] = "42" Then eContour.fParam[Me.ipaKnotTolerance] = CFloat(sValues[i])
                                ' If sClaves[i] = "43" Then eContour.fParam[Me.ipaControlTolerance] = CFloat(sValues[i])
                                ' If sClaves[i] = "44" Then eContour.fParam[Me.ipaFitTolerance] = CFloat(sValues[i])
                                '
                                ' ' Los Knots estan en el indice me.TotalParams en adelante
                                ' If sClaves[i] = "40" Then eContour.fParam.Add(CFloat(sValues[i]))
                                '
                                ' ' por lo general hay fit points o controls points, pero no ambos, cargo lo que sea en P
                                ' ' Control points
                                ' If sClaves[i] = "10" Then Pbase.Add(CFloat(sValues[i]))
                                ' If sClaves[i] = "20" Then Pbase.Add(CFloat(sValues[i]))
                                '
                                ' ' Estos Fitting points no se usan en la construccion, tengo que verificar si los necesitan otros programas para guardarlos y reescribirlos
                                ' If sClaves[i] = "11" Then PFit.Add(CFloat(sValues[i]))
                                ' If sClaves[i] = "21" Then PFit.Add(CFloat(sValues[i]))
                                '
                                ' ' tangentes, no se usan DXF
                                ' If sClaves[i] = "12" Then Ptang1.Add(CFloat(sValues[i]))
                                ' If sClaves[i] = "22" Then Ptang1.Add(CFloat(sValues[i]))
                                '
                                ' If sClaves[i] = "13" Then Ptang2.Add(CFloat(sValues[i]))
                                ' If sClaves[i] = "23" Then Ptang2.Add(CFloat(sValues[i]))

                        End Select
                    Next

                    ' cuando termino de leer los datos del Edge, puede venir REference Boundary Object
                    ' estas son las entidades de donde se obtuvo el contorno, puede ignrarse
                    Inc i
                    If sClaves[i] = "97" Then
                        For iBoundaryObject = 1 To CInt(sValues[i])
                            Inc i

                            ' a esta entidad que es un borde le etiquetamos el loop al que pertenece

                            i = dxf.ReadCode(330, sClaves, sValues, ByRef RefObjHandle, i)

                            ' Podria guardar esta Handle, pero es totalmente redundante
                            ' NewPath.sHandles.Add(RefObjHandle)
                        Next
                    End If

                    Continue

                Else ' read the polyline loop
                    ' forma el contorno
                    eContour = cadLWPolyline.NewEntity()
                    ' a esta entidad que es un borde le etiquetamos el loop al que pertenece

                    ' Debug "PolyLine loop en un hatch"
                    NewPath.eSegments.Add(eContour)

                    Inc i
                    ' leo si tiene bulges
                    If sClaves[i] = "72" Then
                        If sValues[i] = "1" Then ' tiene bulges
                            eContour.iParam[cadLWPolyline.iiiBulged] = 1
                        End If
                    Else
                        'error de DXF
                        Stop
                    Endif

                    Inc i
                    ' leo si es abierta o cerrada
                    If sClaves[i] = "73" Then
                        If sValues[i] = "1" Then ' cerrada
                            eContour.iParam[cadLWPolyline.iiiPolylineClosed] = 1
                        End If
                    Else
                        'error de DXF
                        Stop
                    Endif

                    Inc i
                    ' numero de vertice
                    If sClaves[i] = "93" Then
                        eContour.P.Resize(CInt(sValues[i] * 2))
                    Else
                        'error de DXF

                    Endif

                    For iPoints = 0 To eContour.P.Count / 2 - 1
                        Inc i
                        eContour.P[iPoints * 2] = CFloat(sValues[i])
                        Inc i
                        eContour.P[iPoints * 2 + 1] = CFloat(sValues[i])
                        If eContour.iParam[cadLWPolyline.iiiBulged] Then
                            Inc i ' ignoro el bulge
                        Endif
                    Next

                    ' If eContour.iParam[cadLWPolyline.iiiPolylineClosed] = 1 Then
                    '   eContour.P.Add(eContour.P[0])
                    '   eContour.P.Add(eContour.P[1])
                    '
                    ' Endif

                Endif
                ' despues del loop hay un 97
                Inc i
                ' Objetos ecternos de borde
                If sClaves[i] = "97" Then
                    For iBorderObjects = 0 To CInt(sValues[i]) - 1 ' los leo
                        ' aca viene un Handle a un objeto que tambien es contorno pero no esta definido directamette en la entidad Hatch
                        ' pero puede ocurrir que este objeto no este cargado aun en ningun lado porque su lectura no ocurrio
                        ' TODO: verificar esto

                        Inc i
                    Next
                Else
                    'error de DXF

                Endif
                Inc i

            Next

        End If
        If sClaves[i] = "2" Then e.sParam[Me.sdaPattern] = sValues[i] ' hach file

        If sClaves[i] = "70" Then e.fParam[Me.ipaSolid] = CFloat(sValues[i])
        If sClaves[i] = "71" Then e.fParam[Me.ipaAsociativity] = CFloat(sValues[i])
        If sClaves[i] = "72" Then e.fParam[Me.ipaBoundaryType] = CFloat(sValues[i])

        If sClaves[i] = "52" Then e.fParam[Me.ipaRotation] = CFloat(sValues[i])
        If sClaves[i] = "41" Then
            e.fParam[Me.ipaScale] = CFloat(sValues[i])

        End If
        If sClaves[i] = "75" Then e.fParam[Me.ipaParity] = CFloat(sValues[i])
        If sClaves[i] = "76" Then e.fParam[Me.ipaPatternType] = CFloat(sValues[i])

        ' ahora viene el pattern data
        If sClaves[i] = "78" Then
            For iPattern = 1 To sValues[i]
                oPattern = New Pattern
                e.pBlock.Patterns.Add(oPattern)
                i = dxf.ReadCode(53, sClaves, sValues, ByRef oPattern.AngleDeg, i)
                i = dxf.ReadCode(43, sClaves, sValues, ByRef oPattern.BaseX, i)
                i = dxf.ReadCode(44, sClaves, sValues, ByRef oPattern.BaseY, i)
                i = dxf.ReadCode(45, sClaves, sValues, ByRef oPattern.OffsetX, i)
                i = dxf.ReadCode(46, sClaves, sValues, ByRef oPattern.OffsetY, i)
                i = dxf.ReadCode(79, sClaves, sValues, ByRef Dashes, i)

                For iBorderObjects = 1 To Dashes

                    i = dxf.ReadCode(49, sClaves, sValues, ByRef DashLength, i + 1)
                    oPattern.DashLength.Add(DashLength)
                Next

            Next
        End If

        ' ahora viene el seed points
        If sClaves[i] = "98" Then
            For iPattern = 1 To sValues[i]

                i = dxf.ReadCode(10, sClaves, sValues, ByRef fVar, i)
                e.pBlock.SeedPoints.Add(fVar)
                i = dxf.ReadCode(20, sClaves, sValues, ByRef fVar, i)
                e.pBlock.SeedPoints.Add(fVar)
            Next

        End If
    Loop

    If e.fParam[Me.ipaSolid] Then
        e.sParam[Me.sdaPaternFile] = "Solid"
    Else
        e.sParam[Me.sdaPaternFile] = gcd.dirResources &/ "patterns" &/ LCase(e.sParam[Me.sdaPattern]) & ".dxf"
    End If

    Return True

    ' catch

    Return False

LoopImport:

End

'' Return if that position is over the entity within the tolerance
Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean

    Dim oBound As Float[]

    For Each oBound In e.pBlock.Polylines

        If puntos.isInside(oBound, xr, yr) Then Return True

    Next

    Return False

End

'' Procesa las entidades de borde y las trnasforma en polilineas cerradas, que pueden estar una dentro de otra
Fast Unsafe Public Sub MakeBorder2(oPath As Hatch)

    Dim eBorder, eFind As Entity
    Dim drwPath As New Float[]
    Dim i As Integer
    Dim FirstX, FirstY As Single
    Dim FirstPointSet As Boolean = False
    Dim BoundaryGotClosed As Boolean = False

    ' armo ese contorno

    For Each eBorder In oPath.eSegments

        If Not eBorder Then Continue 'por si es Null

        If eBorder.Gender = "" Then
            ' eFind = gcd.FindEntity(eborder.Handle, True)
            ' If IsNull(eFind) Then
            '
            Debug "Borde de hatch no encntrado", eborder.Handle
            Continue
            Stop
            '
            ' Else
            '   eborder = eFind
            ' End If
        End If
        Select Case eBorder.gender

            Case cadLWPolyline.Gender
                drwPath.Insert(eborder.P.Copy())
                BoundaryGotClosed = True
                FirstX = drwPath[0]
                FirstY = drwPath[1]

            Case "ARC", "CIRCLE", "ELLIPSE", "SPLINE"

                Try Gcd.CCC[eBorder.gender].MakePolyline(eborder)
                drwPath.Insert(eborder.PolyLine.Copy())
                BoundaryGotClosed = True
                FirstX = drwPath[0]
                FirstY = drwPath[1]

            Case "TEXT", "MTEXT"

                drwPath.Insert(eborder.Polygon.Copy())
                BoundaryGotClosed = True
                FirstX = drwPath[0]
                FirstY = drwPath[1]

            Case "LINE"

                If Not FirstPointSet Then
                    drwPath.Insert(eborder.P.Copy())

                    FirstX = eborder.P[0]
                    FirstY = eborder.P[1]
                    FirstPointSet = True
                Else
                    drwPath.Insert([eborder.P[2], eborder.P[3]])

                    If puntos.Equal(FirstX, eborder.P[2]) Then
                        If puntos.Equal(FirstY, eborder.P[3]) Then ' se cerro el contorno
                            BoundaryGotClosed = True

                        End If
                    End If
                End If
        End Select
        If BoundaryGotClosed Then

            ' verifico que este cerrado
            If (drwPath[0] <> drwPath[drwPath.Max - 1]) Or (drwPath[1] <> drwPath[drwPath.Max]) Then ' le agrego

                drwPath.Add(drwPath[0])
                drwPath.Add(drwPath[1])
            End If
            ' ' ahora veo si tengo un a poly anterior
            ' If oPath.Polylines.Count = 0 Then
            '     oPath.Polylines.add(drwPath)
            ' Else ' verifico que no sea un hueco
            '     If puntos.isInside(oPath.Polylines[0], FirstX, FirstY) Then ' es un hueco
            '         oPath.Holes.Add(drwPath)
            '     Else
            '         oPath.Polylines.add(drwPath)
            '     Endif
            '
            ' Endif

            '==============NEW=======================
            oPath.Polylines.add(drwPath)

            drwPath = New Float[]
            FirstPointSet = False
            BoundaryGotClosed = False
        Endif

    Next

    '========================NEW===========================
    ' ahora ordeno los contornos

    Dim Changes As Boolean = False
    Dim i2 As Integer

    ' incializo los indices
    For i = 0 To oPath.Polylines.Max
        oPath.Levels.add(1)
    Next

    Do
        Changes = False
        For i = 0 To oPath.Polylines.Max
            For i2 = 0 To oPath.Polylines.Max
                If i = i2 Then Continue
                If puntos.isInsidePolygons(oPath.Polylines[i], oPath.Polylines[i2]) Then
                    If Abs(oPath.Levels[i]) <= oPath.Levels[i2] Then
                        Changes = True
                        oPath.Levels[i] = (Abs(oPath.Levels[i2]) + 1) * -1 * Sgn(oPath.Levels[i2])
                    Endif
                Endif
            Next
        Next
    Loop Until Not Changes
    Return

End

Public Sub GetBoundLimits2(fxlPoints As Float[])

    Dim i As Integer

    For i = 0 To fxlPoints.max Step 2

        If fxlPoints[i] < Xmenor Then Xmenor = fxlPoints[i]

        If fxlPoints[i + 1] < Ymenor Then Ymenor = fxlPoints[i + 1]

        If fxlPoints[i] > Xmayor Then Xmayor = fxlPoints[i]

        If fxlPoints[i + 1] > Ymayor Then Ymayor = fxlPoints[i + 1]

    Next

End

Fast Unsafe Public Sub FillEntityWithHatch4(entToFill As Entity)    ' Apto para rotaciones

    ' reeleno usando un pattern manual
    ' https://knowledge.autodesk.com/support/autocad-lt/learn-explore/caas/CloudHelp/cloudhelp/2018/ENU/AutoCAD-LT/files/GUID-79B99823-7600-4CAB-BD12-04D5103D90CB-htm.html

    ' Parametros de la entidad:

    ' P[]:        son los puntos de la polilinea que define el contorno del sombreado
    ' fParam[0]:  escala del sombreado
    ' fParam[1]:  angulo
    ' StringData[0]: nombre del patron del sombreado

    Dim e As Entity
    Dim fPAtternSide, fDashTotal, fDistance As Float
    Dim iPatternOffset, iPatternN As Integer
    Dim nx As Integer
    Dim ny As Integer
    Dim ie, i, AlPedo, Sirve, nTrames As Integer
    Dim flxBaseLine, flxOffset, flxBase, flxTrimmedLine, flxPatternLimits, flxContorno, flxFirstPass, flxSecondPass, flxPatternLines, flxDashes, flxInter As New Float[]
    Dim iLoop As Integer
    Dim enxPattern As New Collection
    Dim cPattern As New Collection
    Dim drwPattern As New Drawing
    Dim enxPatternScaled As New Collection
    Dim eBorder As Entity
    Dim sPAtternFile As String
    Dim oPat As Pattern
    Dim EsUtil, NoMoreIntersections, MeAlejo, Filled, UseAxisX As Boolean
    Dim OffsetDirection As Integer = 1
    Dim mX, mY, dX, dY, BaseX, BaseY, Check, StartX, StartY, FinalX, FinalY, TanA, DashLength, DashTrame As Float
    Dim Scale, CosA, SinA, DashBaseX, DashBaseY, DashFinalX, DashFinalY As Float
    Dim A1, A2, SeedX, SeedY, SeedIndex, CosB, SinB, CosAB, SinAB As Float
    Dim Mucho, MuchoViejo As Float
    Dim Xcg, Ycg, DistCg, DistCgOld As Float
    Dim d1, d2, ox, oy, bx, by, fOffset As Float
    Dim OyMax, OxMax As Float
    ' este valor intenta commpensar un problema de compatibilidad entre DWG y DXF
    ' para estar de acuerdo a LibreCAD, debe ser =1, pero algunos DWG se represetan
    ' con una densidad de relleno menor (mas disperso el relleno)
    Dim CorrectionScale As Float = 1 '0.01 ' 0.1
    Dim iHatchLinesDrawn As Integer

    Dim bInvert As Boolean = False    ' TODO ver como hacer andar esto

    If entToFill.fParam[Gcd.CCC["HATCH"].ipaScale] = 0 Then
        entToFill.fParam[Gcd.CCC["HATCH"].ipaScale] = 1
    Else
        ''entToFill.fParam[Gcd.CCC["HATCH"].ipaScale] /= 12  ' TODO: verificar esta escala
    Endif

    'For Each oLoop In entToFill.pBlock

    'If entToFill.Handle = "35256" Then Stop
    'If entToFill.StringData[0] = "ANSI31" Then Stop
    'If entToFill.StringData[0] = "GRAVEL" Then entToFill.Colour = 2

    'If ((entToFill.Flag And 1) = 1) Or (entToFill.Flag = 0) Then ' es external, o sea lo que esta afuera de todo

    If entToFill.pBlock.Polylines.Count = 0 Then Return

    ' veo los limites del contorno exterior
    Xmenor = 1e10
    Ymenor = 1e10
    Xmayor = -1e10
    Ymayor = -1e10

    Dim l1, l2, lmax As Float



    Try SeedX = entToFill.pBlock.SeedPoints[SeedIndex * 2]
    Try SeedY = entToFill.pBlock.SeedPoints[SeedIndex * 2 + 1]

    Scale = entToFill.fParam[Me.ipaScale]
    Scale = 1                                   ' La escala ya esta aplicada, pero aqui podriamos corregir
    SeedIndex = 0

    ' determino offsets maximos
    For Each oPat In entToFill.pBlock.Patterns
        If Abs(oPat.OffsetX) > OxMax Then OxMax = Abs(oPat.OffsetX)
        If Abs(oPat.OffsetY) > OyMax Then OyMax = Abs(oPat.OffsetY)
    Next

    ' ya tenemos las lineas del pattern, las hacemos intersectar con el contorno
    For Each flxContorno In entToFill.pBlock.Polylines
        Utils.DoEvents(10)
        If entToFill.pBlock.Levels[SeedIndex] < 0 Then Continue ' es un hole

        If flxContorno.Count < 6 Then Continue          ' este borde es nulo

        ' obtengo los limites
        GetBoundLimits2(flxContorno)

        ' Calculo el CG
        Xcg = (Xmayor + Xmenor) / 2
        Ycg = (Ymayor + Ymenor) / 2

        ' muevo el seed al CG proporcionalemnte al offset del patron
        If OxMax <> 0 Then SeedX = SeedX + Int((Xcg - SeedX) / OxMax) * OxMax Else SeedX = Xcg
        If OyMax <> 0 Then SeedY = SeedY + Int((Ycg - SeedY) / OyMax) * OyMax Else SeedY = Ycg


        CosA = Cos(entToFill.fParam[Me.ipaRotation] * Pi / 180)
        SinA = Sin(entToFill.fParam[Me.ipaRotation] * Pi / 180)
        'Debug entToFill.fParam[Me.ipaRotation]
        For Each oPat In entToFill.pBlock.Patterns

            iHatchLinesDrawn = 0
            NoMoreIntersections = False
            OffsetDirection = 1
            iPatternOffset = 0

            ' Debug oPat.AngleDeg

            ' el angulo de la linea del patron ya tiene incorporado el angulo general del hatch

            CosB = Cos(oPat.AngleDeg * Pi / 180)
            SinB = Sin(oPat.AngleDeg * Pi / 180)

            ' TanAB = Tan((oPat.AngleDeg + entToFill.fParam[Me.ipaRotation]) * Pi / 180)
            CosAB = Cos((oPat.AngleDeg + entToFill.fParam[Me.ipaRotation]) * Pi / 180)
            SinAB = Sin((oPat.AngleDeg + entToFill.fParam[Me.ipaRotation]) * Pi / 180)

            flxBase.Clear
            flxBase.Insert([oPat.BaseX, oPat.BaseY])

            puntos.Rotate(flxBase, entToFill.fParam[Me.ipaRotation] * Pi / 180)

            flxOffset.Clear
            flxOffset.Insert([oPat.OffsetX, oPat.OffsetY])

            puntos.Rotate(flxOffset, entToFill.fParam[Me.ipaRotation] * Pi / 180)

            bx = flxBase[0]
            by = flxBase[1]

            ox = flxOffset[0]
            oy = flxOffset[1]

            ' ox = oPat.OffsetX
            ' oy = oPat.OffsetY
            '
            ' bx = oPat.BaseX
            ' by = oPat.BaseY

            'Debug bx, by, ox, oy

            DistCg = 1e100
            Do
                EsUtil = False

                'If iPatternOffset > 1e3 Then Break 'Stop

                ' el Offset entre lineas del patron ya tiene incorporado el angulo del hatch
                BaseX = SeedX + bx + iPatternOffset * OffsetDirection * ox
                BaseY = SeedY + by + iPatternOffset * OffsetDirection * oy

                'Debug baseX, BaseY
                Mucho = 1e5

                StartX = BaseX - cosAB * mucho
                StartY = BaseY - SinAB * Mucho

                FinalX = BaseX + CosAB * Mucho
                FinalY = BaseY + SinAB * Mucho

                ' ' normalizo esto
                ' If CSingle(StartX) > CSingle(FinalX) Then
                '     Swap StartX, FinalX
                '     Swap StartY, FinalY
                ' Else If CSingle(StartX) = CSingle(FinalX) Then
                '     If CSingle(StartY) > CSingle(FinalY) Then
                '         Swap StartX, FinalX
                '         Swap StartY, FinalY
                '     Endif
                '
                ' Endif

                '

                Inc iPatternOffset

                ' TEST: para ver si los dashed son el problema, descomentar la siguiente linea
                'oPat.DashLength.Clear

                ' PARTE 1

                ' La linea recortada al contorno es (OJO, esto puede ser un conjunto de lineas):
                flxTrimmedLine = puntos.LinePolyIntersection([BaseX, baseY, FinalX, FinalY], flxContorno)

                If flxTrimmedLine.Count > 0 Then
                    'If flxTrimmedLine.Count > 4 Then Stop
                    EsUtil = True

                    Inc iHatchLinesDrawn
                    If oPat.DashLength.Count = 0 Then ' es una linea recta
                        flxFirstPass.Insert(flxTrimmedLine.Copy())

                    Else ' armo los dashes y despue los recorto al contorno
                        'fOffset = puntos.distancia(startX, starty, basex, basey)
                        d1 = puntos.distancia(baseX, basey, flxTrimmedLine[0], flxTrimmedLine[1])
                        'd2 = fOffset + puntos.distancia(startX, starty, flxTrimmedLine[flxTrimmedLine.Max - 1], flxTrimmedLine[flxTrimmedLine.Max])
                        If d1 <= d2 Then

                            'bInvert = False
                            fOffset = 0'd1
                            'Debug "Normal"
                        Else
                            'bInvert = True
                            fOffset = 0'd2
                            'Debug "Invert"
                        End If
                        fOffset = d1
                        flxDashes = puntos.DashedLineStrip(flxTrimmedLine, oPat.DashLength,, fOffset, bInvert, True)
                        'Debug fOffset 'baseX, BaseY
                        flxFirstPass.Insert(flxDashes)
                    End If
                End If
                ' PARTE 2

                ' La linea recortada al contorno es (OJO, esto puede ser un conjunto de lineas):
                flxTrimmedLine = puntos.LinePolyIntersection([BaseX, baseY, startX, startY], flxContorno)

                If flxTrimmedLine.Count > 0 Then
                    'If flxTrimmedLine.Count > 4 Then Stop
                    EsUtil = True

                    Inc iHatchLinesDrawn
                    If oPat.DashLength.Count = 0 Then ' es una linea recta
                        flxFirstPass.Insert(flxTrimmedLine.Copy())

                    Else ' armo los dashes y despue los recorto al contorno
                        'fOffset = puntos.distancia(startX, starty, basex, basey)
                        d1 = puntos.distancia(baseX, basey, flxTrimmedLine[0], flxTrimmedLine[1])
                        'd2 = fOffset + puntos.distancia(startX, starty, flxTrimmedLine[flxTrimmedLine.Max - 1], flxTrimmedLine[flxTrimmedLine.Max])
                        If d1 <= d2 Then

                            'bInvert = False
                            fOffset = 0'd1
                            'Debug "Normal"
                        Else
                            'bInvert = True
                            fOffset = 0'd2
                            'Debug "Invert"
                        End If
                        fOffset = d1
                        flxDashes = puntos.DashedLineStrip(flxTrimmedLine, oPat.DashLength,, fOffset, True, True)
                        'Debug fOffset 'baseX, BaseY
                        flxFirstPass.Insert(flxDashes)
                    End If

                End If




                If Not EsUtil Then
                    'RUTINA DE VERIFICACION PARA VER SI SIGO TRAZANDO EN ESTA DIRECCION

                    DistCgOld = DistCg
                    DistCg = Abs(puntos.PointToLineDistance([Xcg, Ycg], [StartX, StartY, FinalX, FinalY]))
                    If DistCg > DistCgOld Then MeAlejo = True Else MeAlejo = False

                End If

                If MeAlejo Then
                    If OffsetDirection = 1 Then
                        OffsetDirection = -1
                        iPatternOffset = 1
                        DistCg = 1e100
                        MeAlejo = False

                    Else
                        NoMoreIntersections = True
                        MeAlejo = False
                    Endif
                End If
                'End If

                '
            Loop Until NoMoreIntersections
            'Next

        Next    ' Patterns
        Inc SeedIndex
    Next    ' contorno
    'If entToFill.PolyLine.Count = 0 Then Stop
    'entToFill.PolyLine.Insert(flxFirstPass.Copy())

    ' HASTA ACA LLEGO BIEN, CON EL CONTORNO PPAL LLENO

    ' https://ezdxf.readthedocs.io/en/stable/dxfentities/hatch.html
    ' Boundary Paths
    ' The hatch entity is build by different functional path types, this are filter flags for the Hatch.dxf.hatch_style:
    '
    ' EXTERNAL: defines the outer boundary of the hatch
    ' OUTERMOST: defines the first tier of inner hatch boundaries
    ' DEFAULT: default boundary path
    ' As you will learn in the next sections, these are more the recommended usage type for the flags, but the fill algorithm doesn’t care much about that, for instance an OUTERMOST path doesn’t have to be inside the EXTERNAL path.

    'limpio los huecos
    'Else If (entToFill.Flag And 16) = 16 Then ' es outermost

    SeedIndex = -1
    Filled = False
    For Each flxContorno In entToFill.pBlock.Polylines
        Inc SeedIndex
        If entToFill.pBlock.Levels[SeedIndex] > 0 Then Continue ' es un borde

        Filled = True

        For i = 0 To flxFirstPass.Max - 3 Step 4
            entToFill.PolyLine.Insert(puntos.LineholeIntersection(flxFirstPass.Copy(i, 4), flxContorno))

        Next

    Next

    If Not Filled Then entToFill.PolyLine.Insert(flxFirstPass.Copy())

End
