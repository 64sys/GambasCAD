' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
Inherits CadDimension

Public Const Gender As String = "DIMENSION_LINEAR"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = ("Insert a linear acotation")
Public Const ParamType As String = "PPP"
Public Const ParamHelper As String = "Start point;End point;extension"
Public Const ParamDefault As String = " "

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer
    Dim AfterSubclassmarker As Boolean
    ' ' revisamos lo que viene del importador comun
    e.P[4] = e.P[0]
    e.P[5] = e.P[1]
    '
    e.P[6] = e.P[2]
    e.P[7] = e.P[3]

    For i = 0 To sClaves.Max
        If sClaves[i] = "100" And sValues[i] = "AcDbAlignedDimension" Then AfterSubclassmarker = True
        If AfterSubclassmarker Then ' los siguientes codigos
            If sClaves[i] = "12" Then e.P[8] = CFloat(sValues[i])
            If sClaves[i] = "22" Then e.P[9] = CFloat(sValues[i])

            'If sClaves[i] = "13" Then e.P[0] = CFloat(sValues[i])
            'If sClaves[i] = "23" Then e.P[1] = CFloat(sValues[i])

            If sClaves[i] = "14" Then e.P[2] = CFloat(sValues[i])
            If sClaves[i] = "24" Then e.P[3] = CFloat(sValues[i])

            ' este parametro determina el angulo de la dimension, y no los puntos
            If sClaves[i] = "50" Then e.iParam[cadDimension.iiiMode] = 1000 * CFloat(sValues[i])

            If sClaves[i] = "52" Then e.fParam[cadDimension.ipaObliqueExtension] = CFloat(sValues[i])

        End If

    Next

    ' Equivalencias
    ' DXF       Entity P[]
    ' 10-20     4-5
    ' 11-21     6-7
    ' 12-22     no se usa
    ' 13-23     0-1
    ' 14-24     2-3

    e.fParam[cadDimension.ipaExtension] = -puntos.distancia(Me.pointDefPoint0.x, Me.pointDefPoint0.y, Me.pointDefPoint2.x, Me.pointDefPoint2.y)

    ' TODO: cuando este terminada la entidad, sacar eso
    ' tengo q presuponer que las escalas son = 1
    e.fParam[Me.ipaEscX] = 1    ' esc X
    e.fParam[Me.ipaEscY] = 1    ' esc Y
    e.fParam[Me.ipaEscZ] = 1    ' esc Z
    Try e.pBlock.AbsoluteCoords = True

    ' y poner esto
    ' e.pBlock = Me.ReBuildBlock(e)

    Return True

    ' catch

    Return False

End

Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    Dim fAngle As Float
    Dim iMode As Integer




    If vParam[0] <> "point" Then Return False

    If Me.StepsDone = 0 Then

        ' supongo que marca el punto de derecha a izq
        ' el primero es P3 o P67
        Try eBuild.p[0] = vParam[1]
        Try eBuild.p[1] = vParam[2]
        eBuild.p[2] = eBuild.P[0]
        eBuild.p[3] = eBuild.P[1]
        eBuild.p[4] = eBuild.p[2]
        eBuild.p[5] = eBuild.P[3]
        ' Me.pointDefPoint2.x = Me.pointDefPoint1.x
        ' Me.pointDefPoint2.y = Me.pointDefPoint1.y

        If eBuild.iParam[Me.iiiMode] = 0 Then ' linear (depende de la posicion de la medida)
            iMode = 0
        Else If eBuild.iParam[Me.iiiMode] = 1 Then ' Horizontal
            iMode = 1
        Else If eBuild.iParam[Me.iiiMode] = 2 Then ' Vertical
            iMode = 2
        Else

            eBuild.fParam[Me.ipaRotacion] = eBuild.iParam[Me.iiiMode] / 1e6
            eBuild.iParam[Me.iiiMode] = 3
        End If

        If definitive Then Return True
    Else If Me.StepsDone = 1 Then

        Try eBuild.p[2] = vParam[1]
        Try eBuild.p[3] = vParam[2]
        eBuild.p[4] = eBuild.p[2]
        eBuild.p[5] = eBuild.P[3]

        ' Try Me.pointDefPoint2.x = vParam[1]
        ' Try Me.pointDefPoint2.y = vParam[2]
        eBuild.pBlock = ReBuildBlock2(eBuild, eBuild.iParam[Me.iiiMode])
        If definitive Then Return True
    Else If Me.StepsDone = 2 Then   ' el tercer punto sera la posicion del texto

        ' return the angle from horizontal to us
        'eBuild.fParam[Me.ipaExtension] = -puntos.PointToLineDistance([vParam[1], vParam[2]], [eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]]) ' / puntos.distancia(eBuild.p[0], eBuild.p[1], eBuild.p[2], eBuild.p[3]
        Try eBuild.p[4] = vParam[1]
        Try eBuild.p[5] = vParam[2]

        ' Try Me.pointDefPoint0.x = vParam[1]
        ' Try Me.pointDefPoint0.y = vParam[2]
        eBuild.pBlock = ReBuildBlock2(eBuild, eBuild.iParam[Me.iiiMode])
        If definitive Then
            'Stop
            Return True
        End If
    Endif

End



'' iMode=-1 es dim alineada entre P1 y P2
'' iMode= 0 linear (determinada por la posicion)
'' iMode= 1 es Horizontal
'' iMode= 2 es Vertical
'' iMode> 1E5 --> 1E5 x fAngle determina el angulo sobre el cual se mide

'' bContinued fuerza seguir desde el ultimo punto marcado (pasa a ser P1)
Public Sub ReBuildBlock2(E As Entity, Optional iMode As Integer, fAngle As Float, bContinued As Boolean) As Block

    ' esta rutina no sabe si el bloque a reconstruir es desde ENTITYBUILDER o desde
    ' DXF o JSON

    Dim flxTextExt As Float[]
    Dim fRotXY As Float[]

    Dim newBlock As New Block
    Dim f1, f2 As New Float[]
    Dim a1 As Float
    Dim sDim As String
    Dim invertida As Integer = 1
    Dim d, fAngle90 As Single ' para evitar problemas de mantisa cuando Ang=89.99999

    ' para definir este bloque necesito 6 entidades
    Dim eLineaPpal As Entity
    Dim eOblique1 As Entity       ' tambien pueden ser flechas Solid
    Dim eOblique2 As Entity
    Dim eExtension1 As Entity
    Dim eExtension2 As Entity
    Dim eText As Entity
    Dim ePoint1 As Entity
    Dim ePoint2 As Entity
    Dim MyStyle As DimStyle
    ' vemos los estilos
    MyStyle = gcd.currentDrawing.CurrDimStyle
    If E.fParam[Me.ipaStyleTextHeigth] > 0 Then Me.DimTextHeight = E.fParam[Me.ipaStyleTextHeigth] Else Me.DimTextHeight = MyStyle.DIMTXT
    If E.fParam[Me.ipaStyleArrowSize] > 0 Then Me.DimArrowSize = E.fParam[Me.ipaStyleArrowSize] Else Me.DimArrowSize = MyStyle.DIMASZ
    Me.DimArrowWidth = Me.DimArrowSize / 3

    newBlock.entities = New Collection

    ' Pasamos los puntos que viene marcando el user a nuestros puntos.
    Me.DefPoint1.x = e.P[0]
    Me.DefPoint1.y = e.P[1]
    Me.DefPoint2.x = e.P[2]
    Me.DefPoint2.y = e.P[3]
    Me.DefTextMidPoint.x = e.P[4]
    Me.DefTextMidPoint.y = e.P[5]

    If iMode = -1 Then
        Me.DefAngle = Ang(Me.DefPoint2.x - Me.DefPoint1.x, Me.DefPoint2.y - Me.DefPoint1.y)
    Else If iMode = 0 Then  ' depende de la posicion del mouse

        If ((Me.DefTextMidPoint.x < Me.DefPoint1.x) And (Me.DefTextMidPoint.x < Me.DefPoint2.x)) Or ((Me.DefTextMidPoint.x > Me.DefPoint1.x) And (Me.DefTextMidPoint.x > Me.DefPoint2.x)) Then ' es vertical
            Me.DefAngle = Pi / 2
        Else If ((Me.DefTextMidPoint.y < Me.DefPoint1.y) And (Me.DefTextMidPoint.y < Me.DefPoint2.y)) Or ((Me.DefTextMidPoint.y > Me.DefPoint1.y) And (Me.DefTextMidPoint.y > Me.DefPoint2.y)) Then ' es horizontal

            Me.DefAngle = 0
        Else
            If Abs(Me.DefPoint1.x - Me.DefPoint2.x) > Abs(Me.DefPoint1.y - Me.DefPoint2.y) Then ' es horiz
                Me.DefAngle = 0
            Else
                Me.DefAngle = Pi / 2
            End If
        End If



    Else If iMode = 1 Then
        Me.DefAngle = 0
    Else If iMode = 2 Then
        Me.DefAngle = Pi / 2
    Else If iMode = 3 Then
        Me.DefAngle = e.fParam[Me.ipaRotacion] '' RADIANS

    Endif



    ' reduzco este valor a -89.99 -> 90
    Me.DefAngle = Utils.fMod(Me.DefAngle, Pi)
    If Me.DefAngle > Pi / 2 Then Me.DefAngle -= Pi
    ' busco el angulo perpendicular
    fAngle90 = Me.DefAngle + Pi / 2
    fAngle90 = Utils.fMod(fAngle90, Pi)
    If fAngle90 > Pi / 2 Then fAngle90 -= Pi

    ' el siguiente valor depende de la posicion del texto
    Me.DefDeltaT = Me.DimTextHeight * 3 / 4

    ' el centro de la linea principal
    Me.DefPointCentral.x = Me.DefTextMidPoint.x - Sin(Me.DefAngle) * Me.DefDeltaT
    Me.DefPointCentral.y = Me.DefTextMidPoint.y + Cos(Me.DefAngle) * Me.DefDeltaT

    ' Determino los puntos auxiliares, que estan sobre una recta que pasa por DefCenter a un angulo DefAngle
    ' 1- Defino la recta

    If Cos(Me.DefAngle) <> 0 Then
        d = Tan(Me.DefAngle)
        Me.DefPointCentralAux.x = Me.DefPointCentral.x + 1
        Me.DefPointCentralAux.y = Me.DefPointCentral.y + d
    Else
        Me.DefPointCentralAux.x = Me.DefPointCentral.x
        Me.DefPointCentralAux.y = Me.DefPointCentral.y + 1
    End If

    ' busco la perendicular q pasa por DefPoint1
    If Cos(fAngle90) <> 0 Then
        d = Tan(fAngle90)
        Me.DefPointAux1.x = Me.DefPoint1.x + 1
        Me.DefPointAux1.y = Me.DefPoint1.y + d
    Else
        Me.DefPointAux1.x = Me.DefPoint1.x
        Me.DefPointAux1.y = Me.DefPoint1.y + 1
    End If

    ' busco la perendicular q pasa por DefPoint2
    If Cos(fAngle90) <> 0 Then
        d = Tan(fAngle90)
        Me.DefPointAux2.x = Me.DefPoint2.x + 1
        Me.DefPointAux2.y = Me.DefPoint2.y + d
    Else
        Me.DefPointAux2.x = Me.DefPoint2.x
        Me.DefPointAux2.y = Me.DefPoint2.y + 1
    End If

    ' ahora determino la inteerseccion de ambas rectas
    f1 = puntos.lineLineIntersection2(Me.DefPointAux1.x, Me.DefPointAux1.y, Me.DefPoint1.x, Me.DefPoint1.y, Me.DefPointCentral.x, Me.DefPointCentral.y, Me.DefPointCentralAux.x, Me.DefPointCentralAux.y)
    Me.DefPoint1b.x = f1[0]
    Me.DefPoint1b.y = f1[1]

    f1 = puntos.lineLineIntersection2(Me.DefPointAux2.x, Me.DefPointAux2.y, Me.DefPoint2.x, Me.DefPoint2.y, Me.DefPointCentral.x, Me.DefPointCentral.y, Me.DefPointCentralAux.x, Me.DefPointCentralAux.y)
    Me.DefPoint2b.x = f1[0]
    Me.DefPoint2b.y = f1[1]


    ' verifico el armado, siempre el P1 debe estar a la izq del P2
    If Me.DefPoint2b.x < Me.DefPoint1b.x Then ' swapeo los puntos
        Swap Me.DefPoint2b.x, Me.DefPoint1b.x
        Swap Me.DefPoint2b.y, Me.DefPoint1b.y

        Swap Me.DefPoint2.x, Me.DefPoint1.x
        Swap Me.DefPoint2.y, Me.DefPoint1.y
    Else If Me.DefPoint2b.x = Me.DefPoint1b.x Then ' swapeo los puntos
        If Me.DefPoint2b.y < Me.DefPoint1b.y Then ' swapeo los puntos
            Swap Me.DefPoint2b.x, Me.DefPoint1b.x
            Swap Me.DefPoint2b.y, Me.DefPoint1b.y

            Swap Me.DefPoint2.x, Me.DefPoint1.x
            Swap Me.DefPoint2.y, Me.DefPoint1.y
        End If
    End If

    ' ahora recalculo la posicion del terxto
    ' el centro de la linea principal
    Me.DefPointCentral.x = (Me.DefPoint1b.x + Me.DefPoint2b.x) / 2
    Me.DefPointCentral.y = (Me.DefPoint1b.y + Me.DefPoint2b.y) / 2
    Me.DefTextMidPoint.x = Me.DefPointCentral.x - Sin(Me.DefAngle) * Me.DefDeltaT
    Me.DefTextMidPoint.y = Me.DefPointCentral.y + Cos(Me.DefAngle) * Me.DefDeltaT





    'newBlock.AbsoluteCoords = True

    ' linea principal
    eLineaPpal = cadLine.NewEntity([Me.DefPoint1b.x, Me.DefPoint1b.y, Me.DefPoint2b.x, Me.DefPoint2b.y])  ' el 2do punto lo tengo que determinar, el primero esta en la posicion final

    ' lineas de demarcacion
    'eExtension1 = cadLine.NewEntity([Me.DefPoint1b.x, Me.DefPoint1b.y - Me.DimExtension, Me.DefPoint1b.x, Me.DefPoint1b.y + Me.DimExtension])

    eExtension1 = cadLine.NewEntity([Me.DefPoint1.x, Me.DefPoint1.y, Me.DefPoint1b.x, Me.DefPoint1b.y])
    eExtension2 = cadLine.NewEntity([Me.DefPoint2.x, Me.DefPoint2.y, Me.DefPoint2b.x, Me.DefPoint2b.y])


    ' puntos base, ya en las ubicaciones finales (coinciden con los clicks)
    ePoint1 = cadPoint.NewEntity([Me.DefPoint1.x, Me.DefPoint1.y])
    ePoint2 = cadPoint.NewEntity([Me.DefPoint2.x, Me.DefPoint2.y])

    ' ' flechas
    ' eOblique1 = cadSolid.NewEntity([0, 0, Me.DimArrowSize, Me.DimArrowWidth, Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])
    ' eOblique2 = cadSolid.NewEntity([0, 0, -Me.DimArrowSize, Me.DimArrowWidth, -Me.DimArrowSize, -Me.DimArrowWidth, 0, 0])

    ' texto
    eText = cadMText.NewEntity([Me.DefTextMidPoint.x, Me.DefTextMidPoint.y])  ' si leo un archivo, esta es la posicion final
    eText.fParam[cadMText.ipaAttchmPoint] = 8
    eText.fParam[cadMText.ipaTextAngle] = Me.DefAngle
    eText.fParam[cadMText.ipaTextHeight] = Me.DimTextHeight

    ' agrego todo al bloque
    newBlock.entities.Add(eLineaPpal, gcd.NewHandle())
    newBlock.entities.Add(eExtension1, gcd.NewHandle())
    newBlock.entities.Add(eExtension2, gcd.NewHandle())
    newBlock.entities.Add(ePoint1, gcd.NewHandle())
    newBlock.entities.Add(ePoint2, gcd.NewHandle())
    newBlock.entities.Add(eText, gcd.NewHandle())
    newBlock.AbsoluteCoords = True

    ' -> el bloque
    E.fParam[cadInsert.ipaEscX] = 1      ' ScaleX del inserto
    E.fParam[cadInsert.ipaEscY] = 1      ' ScaleY del inserto
    E.fParam[cadInsert.ipaEscZ] = 1      ' ScaleY del inserto
    E.Visible = True

    'E.fParam[cadInsert.ipaRotacion] = CFloat(E.iParam[Me.iiiMode]) / 1000

    ' el largo de la linea principal viene dado por la distancia entre ambos puntos
    ' pero como es una dimension alineada, se multiplica por la diferencia de angulos
    ' entre P1-P2 y el angulo de la dimension a medir
    ' a1 = Ang(E.p[2] - E.P[0], E.p[3] - E.P[1]) * 180 / Pi
    ' a1 -= E.fParam[cadInsert.ipaRotacion]  ' esto viene en grados *1000
    ' a1 = Abs(a1) / 180 * Pi
    d = puntos.distancia(Me.DefPoint1b.x, Me.DefPoint1b.y, Me.DefPoint2b.x, Me.DefPoint2b.y)

    ' ' verifico el armado
    ' If E.P[2] < E.P[0] Then
    '   ' Swap elem.P[2], elem.P[0]
    '   ' Swap elem.p[3], elem.P[1]
    '   invertida = -1
    '
    ' Endif
    '
    ' If E.P[2] = E.P[0] Then
    '   If E.P[1] > E.P[3] Then
    '     ' Swap elem.P[2], elem.P[0]
    '     ' Swap elem.p[3], elem.P[1]
    '     invertida = -1
    '
    '   End If
    ' Endif
    '
    ' ' la primer entidad del bloque es la linea principal
    ' eLineaPpal.P[2] = d '* invertida           ' X1
    ' eLineaPpal.P[3] = 0           ' Y1
    '
    ' ePoint2.P[0] = d '* invertida

    ' la segunda es la primer linea de demarcacion (sin cambios)
    ' eExtension1.P[0] = 0           ' X0
    ' eExtension1.P[1] = 0           ' Y0
    '
    ' eExtension1.P[2] = 0           ' X1
    ' eExtension1.P[3] = 0           ' Y1

    ' la tercera es la segunda linea de demarcacion
    ' eExtension2.P[0] = d '* invertida           ' X0
    '
    ' eExtension2.P[2] = d '* invertida          ' X1
    '
    E.fParam[cadDimension.ipaRealMeasure] = Abs(d)
    If E.StringData[Me.sdaTextOverride] <> "" Then
        sDim = E.StringData[Me.sdaTextOverride]
    Else
        sDim = Format(Abs(d), Me.DimFormat)
    Endif
    ' el texto
    eText.StringData[cadMText.sdaText] = "\\A1;" & sDim
    ' flxTextExt = glPlus.TextExtends(sDim, 0, 0, eText.fParam[cadMText.ipaTextHeight])
    '
    ' ' la cuarta y quinta son las flechas , tengo que verificar si entran, o el texto
    ' If flxTextExt[2] * 1.1 > Abs(d) Then                      ' no entra
    '
    '     eOblique1.P[0] = d '* invertida           ' X0
    '     eOblique1.P[2] = (Me.DimArrowSize + d) '* invertida            ' X0
    '     eOblique1.P[4] = (Me.DimArrowSize + d) '* invertida           ' X0
    '     eOblique1.P[6] = d '* invertida    ' X0
    '
    '     eOblique2.P[0] = 0           ' X0
    '     eOblique2.P[2] = -Me.DimArrowSize '* invertida
    '     eOblique2.P[4] = -Me.DimArrowSize '* invertida
    '     eOblique2.P[6] = 0           ' X0
    '
    '     ' el texto va afuera
    '     eText.P[0] = (d + Me.DimArrowSize / 2) '* invertida
    '     eText.P[1] = Me.DimArrowWidth
    '
    ' Else                                                                ' entra
    '     eOblique1.P[0] = 0 * invertida ' X0
    '     eOblique1.P[2] = Me.DimArrowSize * invertida
    '     eOblique1.P[4] = Me.DimArrowSize * invertida
    '     eOblique1.P[6] = 0 * invertida ' X0
    '
    '     eOblique2.P[0] = d '* invertida ' X0
    '     eOblique2.P[2] = -Me.DimArrowSize * invertida + d            ' X0
    '     eOblique2.P[4] = -Me.DimArrowSize * invertida + d            ' X0
    '     eOblique2.P[6] = d '* invertida            ' X0
    '
    '     ' el texto va adentro
    '     eText.P[0] = (d / 2 - flxTextExt[2] / 2) '* invertida
    '     eText.P[1] = Me.DimArrowWidth
    '
    ' End If
    '
    ' ' En esta parte ubico las cosas segun la extension, o sea la distancia a los puntos de demarcacion
    ' E.fParam[Me.ipaExtension] = puntos.PointToLineDistance([E.P[4], E.P[5]], [E.p[0], E.p[1], E.p[2], E.p[3]]) ' / puntos.distancia(eBuild.p[0],
    ' 'Me.extension = puntos.distancia(elem.P[2], elem.P[3], elem.P[4], elem.P[5])
    ' Me.extension = E.fParam[cadDimension.ipaExtension]
    ' Me.extension *= Sin(puntos.Angle2([E.P[2] - E.P[0], E.P[3] - E.P[1]], [E.P[4] - E.P[2], E.P[5] - E.P[3]]))
    '
    ' ' linea principal
    ' eLineaPpal.P[1] = Me.extension           ' Y0
    ' eLineaPpal.P[3] = Me.extension           ' Y1
    '
    ' ' linea de demarcacion
    ' eExtension1.P[1] = Me.DimExtension + Me.extension           ' Y0
    ' eExtension1.P[3] = -Me.DimExtension + Me.extension           ' Y1
    '
    ' ' segunda linea de demarcacion
    ' eExtension2.P[1] = Me.DimExtension + Me.extension           ' Y0
    ' eExtension2.P[3] = -Me.DimExtension + Me.extension           ' Y1
    '
    ' ' texto
    ' eText.P[1] = Me.DimArrowWidth + Me.extension
    '
    ' ' flechas
    ' eOblique1.P[1] = Me.extension           ' X0
    ' eOblique1.P[3] = Me.extension + Me.DimArrowWidth
    ' eOblique1.P[5] = Me.extension - Me.DimArrowWidth
    ' eOblique1.P[7] = Me.extension           ' X0
    '
    ' eOblique2.P[1] = Me.extension           ' X0
    ' eOblique2.P[3] = Me.extension + Me.DimArrowWidth
    ' eOblique2.P[5] = Me.extension - Me.DimArrowWidth
    ' eOblique2.P[7] = Me.extension           ' X0
    '
    ' ' End If
    '
    ' ' ' Traslado todo
    ' ' For Each e As Entity In newBlock.entities
    ' '     gcd.CCC[e.gender].translate(dX, dY)
    ' ' Next

    Return newBlock

End
