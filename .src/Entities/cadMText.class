' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast
Inherits CadText
Public Const USEWITH As String = "MTEXTBUILDER"
Public Const Gender As String = "MTEXT"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = ("Inserts a multiline text")
Public Const ParamType As String = "PAFT"
Public Const ParamHelper As String = "Start point;Angle;Heigth;"     ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = " ; 0 ; 10 ; "

' esto es para texto RTF o complejos
Public Printing As Boolean

Public TextAngle As Float

Public TextLines As New String[]
Public TextHeigth As New Float[]
Public TextPosX As New Float[]
Public TextBoxWidth As New Float[]
Public TextPosY As New Float[]
Public TextBoxHeight As New Float[]
Public TextAlignment As New Integer[]
Public TextFont As New String[]
Public TextBold As New Boolean[]

Public CurrentTextLines As String
Public CurrentTextHeigth As Float
Public OriginalTextHeigth As Float
Public CurrentTextPosX As Float
Public OriginalTextPosX As Float
Public OriginalTextPosY As Float
Public CurrentTextBoxWidth As Float
Public CurrentTextPosY As Float
Public CurrentTextBoxHeight As Float
Public CurrentTextAlignment As Integer                 ' horizontal alignment 0 left/1 center/2 right
Public CurrentTextAlignmentVertical As Integer         '
Public CurrentParagraphAlignment As Integer         '

Public CurrentTextFont As String
Public CurrentTextBold As Boolean
Public CurrentTextItalic As Boolean
Public CurrentTextCrossed As Boolean
Public CurrentTextUnderline As Boolean
Public CurrentTextOverline As Boolean

Public CurrentTextAngle As Float
Public CurrentTextColor As Integer

Public Lines As Integer
Public NewLine As Boolean
Public Trimmed As Boolean
Public TrimText As Boolean

Public LastTextLengh As Integer

' to create the contour

Public MyPolygon As New Float[]
Public flxText As New Float[]

Public TxtStyles As New TextStyle[] ' creados a partir de {}
Public TxtStyle As TextStyle ' el que estoy usando

' The entity handler receives a user action, and returns the number of expected parameter
' If definitive = true, means the parameter is set
Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    Dim f As Float
    Dim ip As Integer

    If gcd.StepsDone = 0 Then  '  posicion

        If vParam[0] <> "point" Then Return False

        Try eBuild.P[0] = vParam[1]
        Try eBuild.P[1] = vParam[2]

        If definitive Then Return True

    Else If gcd.StepsDone = 1 Then ' angulo del texto

        If vParam[0] <> "float" Then Return False

        eBuild.fParam[Me.ipaTextAngle] = vParam[1]
        eBuild.fParam[Me.ipaAttchmPoint] = 0
        eBuild.fParam[Me.ipaDrawingDirec] = 0

        If definitive Then Return True

    Else If gcd.StepsDone = 2 Then   ' altura

        If vParam[0] <> "float" Then Return False

        eBuild.fParam[Me.ipaTextHeight] = vParam[1]

        If definitive Then Return True

    Else If gcd.StepsDone = 3 Then    ' texto

        If vParam[0] <> "text" Then Return False

        eBuild.sParam[Me.sdaText] = vParam[1]

        If definitive Then Return True

    Else
        Return False
    End If

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    Dim i As Integer

    If OnlySelected Then

        For i = 0 To e.Psel.Max
            If e.Psel[i] Then

                e.P[i * 2] += dx
                e.P[i * 2 + 1] += dy

            Endif
        Next

    Else

        puntos.Translate(e.p, dx, dy)
    Endif

    CreatePolygon(e)
    BuildPOI(e)

End

Public Sub Rotate(e As Entity, radians As Float)

    puntos.Rotate(e.P, radians)

    ' el parametro lo tengo que pasar a grados porque la rutina que dibuja el texto usa eso
    E.fParam[Me.ipaTextAngle] += radians

    CreatePolygon(e)
    BuildPOI(e)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    Dim i As Integer

    E.fParam[Me.ipaTextHeight] *= sY
    For i = 0 To e.p.max Step 2

        e.P[i] = e.P[i] * sX
        e.P[i + 1] = e.P[i + 1] * sY

    Next

    CreatePolygon(e)
    BuildPOI(e)

End

'' A fat version of the line
Public Sub DrawSelected(oE As Entity)

    glx.PolyLines(oE.Polygon, config.ColorForSelected, gcd.GetLineWt(oE.LineWIdth, oe.pLayer), gcd.stiDashed)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

    If Not oE.Visible Then Return

    glx.PolyLines(oE.Polygon, gcd.GetGBColor(oE.Colour, oe.pLayer), gcd.GetLineWt(oE.LineWIdth, oe.pLayer), gcd.stiDashed)

End

Public Function Draw2(oE As Entity)

    Printing = True
    Draw(oe)
    Printing = False

End

Public Sub CreatePolygon(oE As Entity)

    Dim tRect As New Float[]

    oE.Polygon.Clear

    ' tRect = glx.MTextExtends(oE.stringdata[Me.sdaText], oE.p[0], oE.p[1], oE.fParam[Me.ipaTextHeight])
    If MyPolygon.Count = 0 Then
        MyPolygon.Clear
        MyPolygon.insert([1e10, 1e10, -1e10, -1e10])

    Endif
    ' armo el poligono , que ya tiene la escala
    If Abs(Me.MyPolygon[0]) > 1e9 Then Return
    oE.Polygon.Insert([Me.MyPolygon[0], Me.MyPolygon[1]])
    oE.Polygon.Insert([Me.MyPolygon[0], Me.MyPolygon[3]])
    oE.Polygon.Insert([Me.MyPolygon[2], Me.MyPolygon[3]])
    oE.Polygon.Insert([Me.MyPolygon[2], Me.MyPolygon[1]])
    oE.Polygon.Insert([Me.MyPolygon[0], Me.MyPolygon[1]])

End
'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity) As Integer

    ' points

    oe.PoiPoints.Clear
    oe.PoiType.Clear

    oe.poiPoints.insert([oE.p[0], oE.p[1]])
    oe.poiType.Add(gcd.poiBasePoint)
    'oe.poiEntities.Add(arrIndex)

End

Public Sub Draw(oE As Entity)

    If Not oE.Visible Then Return
    'If oe.id = "1B4571" Then Stop
    TextAngle = oe.fParam[Me.ipaTextAngle]
    ' voy a procesar texto
    OriginalTextPosX = oE.p[0]
    OriginalTextPosY = oE.p[1]

    ' ' para chequear los aligments
    ' gl.PointSize(3)
    ' gl.Begin(gl.POINTS)
    ' gl.Vertex2f(oe.P[0], oe.P[1])
    ' gl.End

    CurrentTextHeigth = oE.fParam[Me.ipaTextHeight]
    OriginalTextHeigth = CurrentTextHeigth
    CurrentTextBoxWidth = oE.fParam[Me.ipaRectangleWidth]

    If CurrentTextHeigth = 0 Then CurrentTextHeigth = 1
    'CurrentTextPosY -= CurrentTextHeigth
    Select Case oe.fParam[Me.ipaAttchmPoint]

        Case 1      ' Top/Left
            'CurrentTextPosY -= CurrentTextHeigth
            CurrentTextAlignment = 0
            CurrentTextAlignmentVertical = 0            ' top
        Case 2      ' Top/Center
            'CurrentTextPosY -= CurrentTextHeigth
            CurrentTextAlignment = 1
            CurrentTextAlignmentVertical = 0            ' top
        Case 3      ' Top/Right
            'CurrentTextPosY -= CurrentTextHeigth
            CurrentTextAlignment = 2
            CurrentTextAlignmentVertical = 0            ' top
        Case 4      ' Middle/Left
            'CurrentTextPosY -= CurrentTextHeigth / 2
            CurrentTextAlignment = 0
            CurrentTextAlignmentVertical = 1            ' mid
        Case 5      ' Middle/Center
            'CurrentTextPosY -= CurrentTextHeigth / 2
            CurrentTextAlignment = 1
            CurrentTextAlignmentVertical = 1            ' mid
        Case 6      ' Middle/Right
            'CurrentTextPosY -= CurrentTextHeigth / 2
            CurrentTextAlignment = 2
            CurrentTextAlignmentVertical = 1            ' mid
        Case 7      ' Bottom/Left
            'CurrentTextPosY -= 0
            CurrentTextAlignment = 0
            CurrentTextAlignmentVertical = 2            ' top
        Case 8      ' Bottom/Center
            'CurrentTextPosY -= 0
            CurrentTextAlignment = 1
            CurrentTextAlignmentVertical = 2            ' bottom
        Case 9      ' Bottom/Right
            'CurrentTextPosY -= 0
            CurrentTextAlignment = 2
            CurrentTextAlignmentVertical = 2            ' bottom

    End Select

    CurrentTextAngle = Deg(oE.fParam[Me.ipaTextAngle])
    CurrentTextColor = gcd.GetGBColor(oE.Colour, oe.pLayer)
    TrimText = True
    'If InStr(oE.Handle, "1C1DD12D") > 0 Then Stop
    '
    ' If InStr(oE.stringdata[0], "TRANSFERE") > 0 Then Stop
    'If oe.Handle = "13C574" Then Stop

    ' https://ezdxf.readthedocs.io/en/stable/tutorials/mtext.html
    ' https://ezdxf.readthedocs.io/en/stable/dxfentities/mtext.html#mtext-inline-codes

    ' MTEXT tiene in-line formatting, ver esa web

    TxtStyle = gcd.Drawing.CurrTextStyle
    If Not TxtStyle Then TxtStyle = New TextStyle
    TxtStyles.Add(TxtStyle)

    oe.pStyle = gcd.Drawing.TextStyles[oE.sParam[Me.sdaStyle]]

    CurrentTextFont = Utils.FileWithoutExtension(oe.pStyle.sFont_3)

    ProcessText3(oE.sParam[Me.sdaText])

    CreatePolygon(oe)

    'glx.DrawMultilineText(oE.stringdata[0], oE.p[0], oE.p[1], oE.fParam[0], oE.fParam[1], gcd.GetGBColor(oE.Colour, oe.pLayer))

    'If oE.stringdata[0] <> "" Then CreatePolygon(oe)

End

Public Sub ProcessText3(RTF As String)

    ' voy a hacer una gran division
    ' separo el texto a imprimir en lineas \P
    ' busco lo que esta entre {}
    Dim p1, p2, p3 As Integer
    Dim sLines As New String[]
    Dim sRemains, sToProcess As String
    Dim fRect As New Float[]
    Dim px, py, dx, dy, dy2 As Float

    flxText.Clear ' limpio los glyphs

    MyPolygon.Clear
    MyPolygon.insert([1e10, 1e10, -1e10, -1e10])

    Trimmed = False

    sLines = Utils.SplitComplex(rtf, "\\P")
    Lines = 0
    'If InStr(LCase(rtf), "pxqc;11") > 0 Then Stop

    'If sLines.Count > 1 Then Stop

    ' con esto los glyps vienen hacia abajo
    CurrentTextPosY = 0'-CurrentTextHeigth * 1.4
    CurrentParagraphAlignment = 0
    For Each sRemains In sLines
        'Print sRemains
        ProcessPart3(sRemains)
        lines += 1
    Next

    fRect = puntos.Limits(flxText)

    dy = Abs(fRect[3] - fRect[1])
    'dy = Lines * CurrentTextHeigth * 1.4 ' la altura total del texto
    dy2 = dy / Lines
    dx = fRect[2] - fRect[0]
    ' ' but
    ' If Trimmed Then dy = CurrentTextHeigth * 1.2

    If CurrentTextAlignmentVertical = 2 Then py = OriginalTextPosY + dy - dy2
    If CurrentTextAlignmentVertical = 1 Then py = OriginalTextPosY + dy / 2 - dy2
    If CurrentTextAlignmentVertical = 0 Then py = OriginalTextPosY - dy2 '* sLines.Count

    If CurrentTextAlignment = 0 Then px = OriginalTextPosX

    ' TODO: ver cual de los dos es valido
    ' If CurrentTextAlignment = 1 Then px = OriginalTextPosX + CurrentTextBoxWidth / 2 - dx / 2
    If CurrentTextAlignment = 1 Then px = OriginalTextPosX - dx / 2

    ' TODO: ver cual de los dos es valido
    'If CurrentTextAlignment = 2 Then px = OriginalTextPosX + CurrentTextBoxWidth - dx
    If CurrentTextAlignment = 2 Then px = OriginalTextPosX - dx

    puntos.Translate(flxText, px, py)

    puntos.RotatePointsFromBase(OriginalTextPosX, OriginalTextPosY, Rad(CurrentTextAngle), flxText)

    fRect = puntos.Limits(flxText)
    Me.MyPolygon[0] = fRect[0]
    Me.MyPolygon[1] = fRect[1]
    Me.MyPolygon[2] = fRect[2]
    Me.MyPolygon[3] = fRect[3]

    If Printing Then
        paintPlus.Lines(flxText)
    Else
        glx.DrawLines(flxText, CurrentTextColor)
    End If
    ' Code   Description
    ' \L   Start underline
    ' \l   Stop underline
    ' \O   Start overline
    ' \o   Stop overline
    ' \K   Start strike-through
    ' \k   Stop strike-through
    ' \P   New paragraph (new line)
    ' \p   Paragraphs properties: indentation, alignment, tabulator stops
    ' \pi \pxi \pxt    Control codes for bullets, numbered paragraphs, tab stops and columns - e.g. bullets: \pxi-3,l3,t3;, tab stops: \pxt10,t12;
    ' \X    Paragraph wrap on the dimension line (only in dimensions)

    ' \X   Paragraph wrap on the dimension line (only in dimensions)
    ' \Q   Slanting (oblique) text by angle - e.g. \Q30;
    ' \H   Text height - e.g. relative \H3x; absolut \H3;
    ' \W   Text width - e.g. relative \W0.8x; absolut \W0.8;
    ' \T   Tracking, character spacing - e.g. relative \T0.5x; absolut \T2;
    ' \F   Font selection e.g. \Fgdt;o - GDT-tolerance
    ' \S   Stacking, fractions e.g. \SA^ B; space after “^” is required to avoid caret decoding, \SX/Y; \S1#4;
    ' \A   Alignment
    '
    '     \A0; = bottom
    '     \A1; = center
    '     \A2; = top
    '
    ' \C   Color change
    '
    '     \C1; = red
    '     \C2; = yellow
    '     \C3; = green
    '     \C4; = cyan
    '     \C5; = blue
    '     \C6; = magenta
    '     \C7; = white
    '
    ' \~   Non breaking space
    ' {}   Braces - define the text area influenced by the code, codes and braces can be nested up to 8 levels deep
    ' \   Escape character - e.g. \{ = “{”

End

' procesa una linea de MText con todos sus modificadores
Public Function ProcessPart3(sLine As String) As String

    Dim s2, sFont, s3, s4, sTab, sPrint As String
    Dim p1, p2, p3, p4, p5 As Integer
    Dim fAlign, fAlignR, fRect As New Float[]

    Dim angulo As Float, hText As New PaintExtents, lText As String
    Dim FontScalePrev As Float
    Dim iSpace As Integer
    Dim s5 As String
    Dim stxWords As String[]
    Dim i4 As Integer
    Dim dx, dy, LineOffsetX As Float

    Dim flxWords, flxPAragraph, flxTemp As New Float[]

    s2 = sLine

    'If InStr(s2, "por lado") > 0 Then Stop

    ' reemplazo caracteres especiales
    s2 = Replace(s2, "%%D", "°", gb.IgnoreCase)
    s2 = Replace(s2, "%%P", "±", gb.IgnoreCase)
    s2 = Replace(s2, "%%C", "∅", gb.IgnoreCase)

    Do ' proceso la linea hasta que no me queden mas caracteres
        If Left$(s2, 1) = "{" Then  ' voy a modificar los parametros del estilo de texto
            TxtStyle = New TextStyle
            TxtStyles.Add(TxtStyle)
            s2 = Mid(s2, 2)
        End If

        If Left$(s2, 1) = "}" Then  ' vuelvo al estilo anterior
            CurrentTextHeigth = OriginalTextHeigth
            TxtStyles.Remove(TxtStyles.max)
            TxtStyle = TxtStyles.Last
            s2 = Mid(s2, 2)
        End If

        If Left(s2, 1) = "\\" Then
            Select Case Mid$(s2, 2, 1)

                Case "U" ' ej \U+0045
                    p2 = InStr(s2, "\\", 1)
                    If p2 > 0 Then
                        s2 = Mid(s2, p2 + 1)
                    Else
                        s2 = Mid(s2, 8)
                    End If
                    ' es un caracter utf, no hago nada

                Case "f"            ' esta indicado un cambio en la fuente
                    '  \fVerdana|b0|i0|cxxx|p34;
                    p1 = InStr(s2, "|")
                    TxtStyle.FontName = Mid$(s2, 3, p1 - 3)
                    CurrentTextFont = Lower(TxtStyle.FontName)

                    p1 = InStr(s2, "|b")
                    If p1 > 0 Then
                        TxtStyle.Bold = (Mid$(s2, p1 + 2, 1) = "1")
                    End If
                    p1 = InStr(s2, "|i")
                    If p1 > 0 Then

                        TxtStyle.Italic = (Mid$(s2, p1 + 2, 1) = "1")
                    End If

                    p1 = InStr(s2, "|c")    ' codepage
                    If p1 > 0 Then

                        p2 = InStr(s2, "|", p1 + 1)
                        ' Try CurrentTextColor = Mid$(s2, p1 + 2, p2 - p1 - 1) = "1"
                    End If
                    p1 = p2 + 1

                    p1 = InStr(s2, "|p") ' paragraph
                    p2 = InStr(s2, ";", p1)
                    If p1 > 0 Then

                        'CurrentTextHeigth = CFloat(Mid$(s2, p1 + 2, p2 - p1 - 2)) / 100
                    End If

                    s2 = Mid(s2, p2 + 1)

                Case "C"            ' cambio de color

                    p2 = InStr(s2, ";", 1)

                    TxtStyle.cadColor = gcd.GetGBColor(CInt(Mid(s2, 3, p2 - 3)))

                    s2 = Mid(s2, p2 + 1)

                    ' Case "\\P"            ' New line
                    '     CurrentTextPosY -= glx.TextExtends("XXX", CurrentTextHeigth)[1] * 1.2
                    '     CurrentTextPosX = OriginalTextPosX
                    '     NewLine = True
                    '     s2 = Mid(s2, 3)
                    '     If Len(s2) > 0 Then ProcessPart(s2)

                Case "p"            ' no se que significa esto, suele venir \p12.55;
                    ' \pxqc = centered
                    ' \pxqr = right
                    ' \pxql = left
                    If Left(s2, 5) = "\\pxql" Then CurrentParagraphAlignment = 0
                    If Left(s2, 5) = "\\pxqc" Then CurrentParagraphAlignment = 1
                    If Left(s2, 5) = "\\pxqr" Then CurrentParagraphAlignment = 2

                    p2 = InStr(s2, ";", 1)
                    s2 = Mid(s2, p2 + 1)

                    ' Case "\\t", "^I"            ' tab avanzo 4-texto anterior
                    '   ' TODO: verificar sin Tab=4 espacios
                    '   If LastTextLengh > 4 Then sTab = "    " Else sTab = Space(4 - LastTextLengh)
                    '   s2 = stab & Mid(s2, 3)
                    '   If Len(s2) > 0 Then ProcessPart(s2)
                    '   LastTextLengh = 0

                Case "T" 'Adjusts the space between characters. Valid values range from a minimum of .75 to 4 times the original spacing between characters.
                    p2 = InStr(s2, ";", 1)
                    s2 = Mid(s2, p2 + 1)

                Case "Q"  '\Q angle; changes obliquing angle
                    s2 = Mid(s2, 3)
                Case "O"  '\O changes to overline
                    s2 = Mid(s2, 3)
                    CurrentTextOverline = True
                Case "o"  '\O changes to overline
                    s2 = Mid(s2, 3)
                    CurrentTextOverline = False

                Case "L"  '\O changes to underline
                    s2 = Mid(s2, 3)
                    CurrentTextUnderline = True
                Case "l"  'changes to underline
                    s2 = Mid(s2, 3)
                    CurrentTextUnderline = False

                Case "W"            ' \W value; changes width factor To produce wide text
                    p2 = InStr(s2, ";", 1)
                    CurrentTextPosX += CFloat(Mid(s2, 3, p2 - 3))
                    s2 = Mid(s2, p2 + 1)
                Case "S"            ' fracciones
                    p2 = InStr(s2, ";", 1)

                    s2 = Mid(s2, 3, p2 - 3) & " " & Mid(s2, p2 + 1)
                Case "A"            ' Sets the alignment value; valid values: 0, 1, 2(bottom, center, top)

                    ' extraigo el texto puro para poder calcular bien el centrado
                    'CurrentTextAlignmentVertical = CInt(Mid(s2, 3, 1))
                    p2 = InStr(s2, ";", 1)
                    s2 = Mid(s2, p2 + 1)
                    '     If CurrentTextAlignmentVertical = 1 Then ' es mid
                    '
                    '
                    '     fAlign = glx.TextExtends(s2, CurrentTextHeigth)
                    '     'fAlign[0] *= -1
                    '     'fAlign[1] *= 1
                    '
                    '     puntos.Rotate(fAlign, CurrentTextAngle / 180 * Pi)
                    '     'CurrentTextPosX -= fAlign[0] * 0.5
                    '
                    '     ' alineo Y
                    '     CurrentTextPosY += fAlign[1] * 0.5
                    '
                    '     ' pero , y si esta rotado el texto???
                    '
                    '     ' Else
                    '     '   Stop
                    '
                    ' End If

                Case "H"            ' cambia la altura del texto

                    p2 = InStr(s2, ";", 1)
                    s3 = Mid(s2, 3, p2 - 3)
                    If InStr(s3, "x") > 0 Then  ' cambia x veces la altura actual
                        CurrentTextHeigth *= CFloat(Left(s3, -1))
                    Else
                        CurrentTextHeigth = CFloat(s3)
                    Endif
                    s2 = Mid(s2, p2 + 1)

                Case Else            ' codigo no imprementado, lo paso de largo;
                    p2 = InStr(s2, ";", 1)
                    If p2 > 0 Then
                        s2 = Mid(s2, p2 + 1)
                    Else
                        s2 = Mid(s2, 3)
                    End If
            End Select
        Else ' es texto

            ' es un texto, pero puede terminar en un scape o cambio de TeextStyles
            p2 = InStr(s2, "\\")
            If p2 = 0 Then p2 = 1000 'Else Stop
            p3 = InStr(s2, "}")
            If p3 = 0 Then p3 = 1000 'Else Stop
            p4 = InStr(s2, "{")
            If p4 = 0 Then p4 = 1000

            If p3 < p2 Then p2 = p3
            If p4 < p2 Then p2 = p4

            If p2 < 1000 Then

                s5 = Left(s2, p2 - 1)       ' s5 es el texto puro
                s2 = Mid(s2, p2)            ' s2 es el resto , a procesar
            Else
                s5 = s2
                s2 = ""
            Endif

            '
            ' If p2 = 1 Then ' es un escape desconocido
            '     p2 = InStr(s2, ";")
            '     If p2 = 0 Then
            '         s2 = Mid(s2, 3)
            '     Else
            '         s2 = Mid(s2, p2 + 1)
            '     End If
            '     If Len(s2) > 0 Then ProcessPart(s2)
            '
            ' Else
            'If InStr(s5, "C(1)") > 0 Then Stop
            s5 = Utils.ProcessTabs(s5)

            If gcd.FontReplacements.Exist(CurrentTextFont) Then
                CurrentTextFont = gcd.FontReplacements[CurrentTextFont]
            Else
                CurrentTextFont = "romans"
            Endif

            glx.SelectFont(CurrentTextFont)

            ' tengo que trimar?
            If TrimText Then
                stxWords = Split(s5, " ")
                ' For iSpace = stxWords.Max To 0 Step -1
                '     If stxWords[iSpace] = "" Then stxWords.Remove(iSpace)
                ' Next

                For iSpace = 0 To stxWords.Max - 1
                    If stxWords[iSpace] <> "" Then stxWords[iSpace] &= " "
                Next
                ' If stxWords[stxWords.max] = "" Then stxWords.Remove(stxWords.Max)
                NewLine = False   ' supongo que entra todo
                If (CurrentTextBoxWidth > 0) And (stxWords.Count > 1) Then ' debo trimar

                    iSpace = 0
                    ' nuevo:  tengo que ver si no excede el ancho del rectangulo

                    s5 = ""

                    Do
                        s5 &= stxWords[iSpace]
                        fRect = glx.TextExtends(s5, CurrentTextHeigth)

                        If fRect[0] + LineOffsetX < CurrentTextBoxWidth Then
                            's5 = s4
                            Inc iSpace
                        Else' debo trimar
                            NewLine = True
                            Trimmed = True

                            Break

                        End If
                    Loop Until iSpace = stxWords.Count

                    s4 = ""
                    For i4 = iSpace + 1 To stxWords.max
                        s4 &= stxWords[i4]

                    Next
                    s2 = s4 & s2

                End If

            End If

            flxTemp = glx.DrawTextPoly(s5, CurrentTextHeigth)
            fRect = puntos.Limits(flxTemp)

            If CurrentTextUnderline Then
                flxTemp.Insert([fRect[0], fRect[1] - CurrentTextHeigth * 0.2, fRect[2], fRect[1] - CurrentTextHeigth * 0.2])
            Endif

            If CurrentTextOverline Then
                flxTemp.Insert([fRect[0], fRect[3] + CurrentTextHeigth * 0.2, fRect[2], fRect[3] + CurrentTextHeigth * 0.2])
            Endif

            If CurrentTextCrossed Then
                flxTemp.Insert([fRect[0], (fRect[3] + fRect[1]) / 2, fRect[2], (fRect[3] + fRect[1]) / 2])
            Endif

            flxWords.Insert(flxTemp)
            puntos.Translate(flxWords, LineOffsetX, CurrentTextPosY)
            LineOffsetX += fRect[2]
            flxPAragraph.Insert(flxWords)
            flxWords.Clear

            If NewLine Then         ' necesito una nueva linea porque tuve que ajustar el texto
                CurrentTextPosY -= CurrentTextHeigth * 1.4
                Lines += 1
                LineOffsetX = 0

            Endif

        End If
    Loop Until s2 = ""
    ' alinemaiento produce problemas porque se refiere a todo el texto y no a la parte
    fRect = puntos.Limits(flxPAragraph)
    fRect[0] = fRect[2] - fRect[0]
    dx = 0
    If CurrentParagraphAlignment = 1 Then dx = CurrentTextBoxWidth / 2 - fRect[0] / 2
    If CurrentParagraphAlignment = 2 Then dx = CurrentTextBoxWidth - fRect[0]

    puntos.Translate(flxPAragraph, dx, 0)
    flxText.insert(flxPAragraph)
    CurrentTextPosY -= CurrentTextHeigth * 1.4

    Return

End

Public Sub ExportDXFCol(e As Entity, ByRef stxExport As String[]) As Boolean

    Dim i As Integer, sText As String

    ' stxExport.insert(["MTEXT", dxf.codEntity])
    ' Los datos comunes a todas las entidades son guardados por la rutina que llama a esta
    stxExport.insert(["AcDbMText", "100"])

    stxExport.insert([CStr(e.p[0]), dxf.codX0])                    ' insertion point
    stxExport.insert([CStr(e.p[1]), dxf.codY0])
    stxExport.insert(["0", dxf.codZ0])

    stxExport.insert([CStr(e.fParam[Me.ipaTextHeight]), "40"])       ' heigth
    stxExport.insert([CStr(e.fParam[Me.ipaRectangleWidth]), "41"])   ' Rectang width
    stxExport.insert([e.fParam[Me.ipaAttchmPoint], "71"])            ' attchm point
    stxExport.insert([e.fParam[Me.ipaDrawingDirec], "72"])           ' drawing direction

    If e.sParam[0].Len > 250 Then
        stxExport.insert([Left(e.sParam[Me.sdaText], 250), "1"])                ' Texti = 250
        i = 251         ' next offset
        Do

            If e.sParam[0].Len - i > 250 Then
                sText = Mid(e.sParam[0], i, 250)
                stxExport.insert([sText, "3"])                ' Texti += 250
                i += 250
            Else
                sText = Mid(e.sParam[0], i)
                stxExport.insert([sText, "3"])                ' Texti += 250
                Break

            End If

        Loop
    Else
        stxExport.insert([e.sParam[Me.sdaText], "1"])                ' Text
    Endif

    stxExport.insert([e.sParam[Me.sdaStyle], "7"])               ' text style

    stxExport.insert(["0", "210"])                                   ' extrusion direction
    stxExport.insert(["0", "220"])
    stxExport.insert(["1", "230"])

    stxExport.insert([CStr(e.fParam[Me.ipaTextAngle]), "50"])        ' rotation in radians

    stxExport.insert([CStr(e.fParam[Me.ipaBackFillType]), "90"])     ' Background fill style

    stxExport.insert([CStr(e.fParam[Me.ipaBackColor]), "63"])         ' Background color

    stxExport.insert(["0", "75"]) ' Column type
    stxExport.insert(["0", "76"]) ' Column count
    stxExport.insert(["0", "78"]) ' Column Flow Reversed
    stxExport.insert(["0", "79"]) ' Column Autoheight
    stxExport.insert(["0", "48"]) ' Column width
    stxExport.insert(["0", "49"]) ' Column gutter
    stxExport.insert(["0", "50"]) ' Column heights

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer
    Dim TextHeigthSet As Boolean = False
    Dim TextAngleSet As Boolean = False
    Dim ax, ay, az As Single ' angulo del texto
    Dim s As String
    'If e.id = "13C919" Then Stop

    i = dxf.ReadCodePlus(10, sClaves, sValues, ByRef e.p[0],, 101, 100)
    i = dxf.ReadCodePlus(20, sClaves, sValues, ByRef e.p[1],, 101, 100)
    i = dxf.ReadCodePlus(40, sClaves, sValues, ByRef e.fParam[Me.ipaTextHeight],, 101, 100)
    i = dxf.ReadCodePlus(41, sClaves, sValues, ByRef e.fParam[Me.ipaRectangleWIdth],, 101, 100)

    i = dxf.ReadCodePlus(71, sClaves, sValues, ByRef e.fParam[Me.ipaAttchmPoint],, 101, 100)
    i = dxf.ReadCodePlus(72, sClaves, sValues, ByRef e.fParam[Me.ipaDrawingDirec],, 101, 100)
    i = dxf.ReadCodePlus(1, sClaves, sValues, ByRef e.sParam[Me.sdaText],, 101, 100)
    Do
        i = dxf.ReadCodePlus(3, sClaves, sValues, ByRef s,, 101, i)
        If s = "" Then Break
        e.sParam[Me.sdaText] &= s
    Loop Until i = 0
    i = dxf.ReadCodePlus(7, sClaves, sValues, ByRef e.sParam[Me.sdaStyle],, 101, 100)
    i = dxf.ReadCodePlus(11, sClaves, sValues, ByRef ax,, 101, 100)
    i = dxf.ReadCodePlus(21, sClaves, sValues, ByRef ay,, 101, 100)
    i = dxf.ReadCodePlus(31, sClaves, sValues, ByRef az,, 101, 100)
    i = dxf.ReadCodePlus(50, sClaves, sValues, ByRef e.fParam[Me.ipaTextAngle],, 101, 100)
    i = dxf.ReadCodePlus(90, sClaves, sValues, ByRef e.fParam[Me.ipaBackFillType],, 101, 100)
    i = dxf.ReadCodePlus(63, sClaves, sValues, ByRef e.fParam[Me.ipaBackColor],, 101, 100)

    If (ax <> 0) Or (ay <> 0) Or (az <> 0) Then

        e.fParam[Me.ipaTextAngle] = Ang(ax, ay)

    Endif
    e.sParam[Me.sdaStyle] = Lower(e.sParam[Me.sdaStyle])
    If e.sParam[Me.sdaStyle] = "" Then e.sParam[Me.sdaStyle] = "standard"

    Return True

End
