' Gambas class file

Create Static
Inherits CadRectangle
Public Const Gender As String = "VIEWPORT"
Public Const DrawingOrder As Integer = 1        ' 1 = draws first
Public Const CmdLineHelper As String = ("a line")
Public Const ParamType As String = "PP"                             ' that is Point, Point; could be Color Text, etc
Public Const ParamHelper As String = "Start point;End point"
Public Const TotalPoints As Integer = 2

Public Sub Draw(oE As Entity)

    ' En esta entidad , la rutina Draw funciona solo durante la construccion
    Dim flxPoly As New Float[]

    Dim w, h As Float

    w = oE.p[2] - oE.p[0]
    h = oE.p[3] - oE.p[1]
    flxPoly.Add(oE.p[0])
    flxPoly.Add(oE.p[1])
    flxPoly.Add(oE.p[0] + w)
    flxPoly.Add(oE.p[1])
    flxPoly.Add(oE.p[0] + w)
    flxPoly.Add(oE.p[1] + h)
    flxPoly.Add(oE.p[0])
    flxPoly.Add(oE.p[1] + h)


    GLplus.PolyLines(flxPoly, Color.Blue, oe.LineWidth, oe.LineType.TrameLength, True)



    ' test

End

Public Sub DrawSelected(oE As Entity)

    Dim w, h As Float

    w = oE.p[2] - oE.p[0]
    h = oE.p[3] - oE.p[1]

    GLplus.PolyLines(oE.Polygon, config.WindowBackColor, oE.LineWidth, gcd.stiDashed, oe.iParam[Me.iiiPolylineClosed])
    GLplus.PolyLines(oE.Polygon, config.ColorForSelected, oE.LineWidth, oE.LineType.TrameLength, oe.iParam[Me.iiiPolylineClosed])

    glPlus.Rectangle2D(oE.p[0] - gcd.Metros(4), oE.p[1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1)
    glPlus.Rectangle2D(oE.p[0] + W - gcd.Metros(4), oE.p[1] - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1)
    glPlus.Rectangle2D(oE.p[0] + W - gcd.Metros(4), oE.p[1] + H - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1)
    glPlus.Rectangle2D(oE.p[0] - gcd.Metros(4), oE.p[1] + H - gcd.Metros(4), gcd.Metros(8), gcd.Metros(8), Color.Blue,,,, Color.Blue, 1)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

    If Not oE.Visible Then Return

    '  GLplus.PolyLines(oE.p, config.WindowBackColor, oE.LineWidth, gcd.stiDashed)
    '  GLplus.PolyLines(oE.p, gcd.GetGBColor(oE.Colour, oe.pLayer),oE.LineWidth + 2, oE.LineType)
    If oe.Selected Then
        GLplus.PolyLines(oE.Polygon, config.WindowBackColor, oE.LineWidth + 2, gcd.stiDashed)
        GLplus.PolyLines(oE.Polygon, config.ColorForSelected, oE.LineWidth + 2, oE.LineType.TrameLength, True)
    Else
        GLplus.PolyLines(oE.Polygon, config.WindowBackColor, oE.LineWidth, gcd.stiDashed)
        GLplus.PolyLines(oE.Polygon, gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth + 2, oE.LineType.TrameLength, True)
    Endif

End

Public Sub Finish(oE As Entity) As Boolean

    ' tareas finales de armado del objeto
    Dim l As Layer
    Dim c As Collection

    oe.PaperSpace = True

    Me.BuildGeometry(oe)
    Dim w, h As Float
    w = oE.p[2] - oE.p[0]
    h = oE.p[3] - oE.p[1]
    oE.Polygon.add(oE.p[0])
    oe.Polygon.add(oE.p[1])
    oE.Polygon.add(oE.p[0] + w)
    oe.Polygon.Add(oE.p[1])
    oE.Polygon.add(oE.p[0] + w)
    oe.Polygon.add(oE.p[1] + h)
    oE.Polygon.add(oE.p[0])
    oe.Polygon.add(oE.p[1] + h)
    ' oE.Polygon.add(oE.p[0])
    ' oe.Polygon.add(oE.p[1])

    oE.psel.resize(oE.p.count / 2)

    Try oe.MakePolyLine(oe)

    oE.Selected = False

    Dim v As New Viewport
    v.Handle = gcd.NewHandle()
    v.X0 = oe.P[0]
    v.Y0 = oe.P[1]
    v.X1 = oe.P[2]
    v.Y1 = oe.P[3]

    If v.x0 > v.x1 Then Swap v.x0, v.x1
    If v.y0 > v.y1 Then Swap v.y0, v.y1

    v.PanX = (v.x1 + v.x0) / 2
    v.PanY = (v.y1 + v.y0) / 2

    gcd.Drawing.Sheet.vViewports.Add(v, v.Handle)
    c = gcd.Drawing.Sheet.vViewports[gcd.Drawing.Sheet.vViewports.Last].layers
    For Each l In gcd.Drawing.Layers
        If l.Visible Then c.add(l, l.handle)
    Next

    ' pero tengo que hacer algo mas aca, centrar el grafico en el viewport

    ' esto es un copy/paste de cadZoomE
    Dim limits As New Float[]

    limits = clsEntities.ComputeLimits(gcd.Drawing.model.Entities)

    gcd.Drawing.xmenor = limits[0]
    gcd.Drawing.Ymenor = limits[1]
    gcd.Drawing.xmayor = limits[2]
    gcd.Drawing.ymayor = limits[3]

    If gcd.Drawing.model.Entities.Count = 0 Then Return

    Dim SZx As Float
    ' ahora calculo donde estaria el centro de este dibujo

    Dim cx, cy As Float
    Dim px, py As Integer           ' coordenadas del punto medio

    cx = (gcd.Drawing.xmayor - gcd.Drawing.xmenor) ' tama√±o del mundo
    cy = (gcd.Drawing.Ymayor - gcd.Drawing.Ymenor)

    If cx = 0 Then cx = 0.00001
    If cy = 0 Then cy = 0.00001
    v.ScaleZoom = (v.y1 - v.y0) / cy * 0.9

    szx = (v.x1 - v.x0) / cx * 0.9

    If szx < v.ScaleZoom Then v.ScaleZoom = szx

    ' posicion del punto medio
    px = (gcd.Drawing.xmayor + gcd.Drawing.xmenor) / 2
    py = (gcd.Drawing.Ymayor + gcd.Drawing.Ymenor) / 2

    v.PanX += -gcd.Pixels(px)
    v.PanY += -gcd.Pixels(py)

    If v.ScaleZoom > 1e6 Or v.ScaleZoom < 1e-6 Then
        v.ScaleZoom = 1
        v.PanX = 0
        v.PanY = 0
    End If

    gcd.Drawing.Sheet.Viewport = v


End

'' Return if that position is over the entity within the tolerance
Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean

    If e.Polygon Then
        If puntos.isInside(e.Polygon, xr, yr) Then Return True
    End If

    Return False

End
