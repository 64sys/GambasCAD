' Gambas class file

' GambasCAD
' A simple CAD made in Gambas
'
' Copyright (C) Ing Martin P Cristia
'
' This program is free software; you can redistribute it and/or modify
' it under the terms of the GNU General Public License as published by
' the Free Software Foundation; either version 3 of the License, or
' (at your option) any later version.
'
' This program is distributed in the hope that it will be useful,
' but WITHOUT ANY WARRANTY; without even the implied warranty of
' MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
' GNU General Public License for more details.
'
' You should have received a copy of the GNU General Public License
' along with this program; if not, write to the Free Software
' Foundation, Inc., 51 Franklin St, Fifth Floor,
' Boston, MA  02110-1301  USA
Create Static
' Fast
Inherits EntityBase

Public Const Gender As String = "Text"
Public Const DrawingOrder As Integer = 100 ' 1 a 32.724 esto debe Drawse primero y ser sobreescrito por el resto
Public Const PointsToDraw As Integer = 1             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = ("Inserts a text")
Public Const ParamType As String = "PAFT"
Public Const ParamHelper As String = "Start point;Angle;Heigth;"      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = " ; 0 ; 10 ; "

' fParam helpers
Public Const TotalParams As Integer = 13
Public Const ipaTextHeight As Integer = 0
Public Const ipaTextAngle As Integer = 1
Public Const ipaGenerationFlags As Integer = 2
Public Const ipaHorizJustif As Integer = 3
Public Const ipaVertJustif As Integer = 4
Public Const ipaRelativeFactor As Integer = 5
Public Const ipaHorizAngle As Integer = 6
Public Const ipaTextVisibility As Integer = 7
Public Const ipaAttchmPoint As Integer = 8
Public Const ipaRectangleWidth As Integer = 9
Public Const ipaDrawingDirec As Integer = 10
Public Const ipaBackFillType As Integer = 11
Public Const ipaBackColor As Integer = 12

' stringdata helpers
Public Const sdaTotalParams As Integer = 2
Public Const sdaText As Integer = 0
Public Const sdaStyle As Integer = 1
Public Const TotalPoints As Integer = 1 ' 2021 cambie esto

' The entity handler receives a user action, and returns the number of expected parameter
' If definitive = true, means the parameter is set
Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean

    Dim f As Float
    Dim ip As Integer

    If Me.StepsDone = 0 Then  '  posicion

        If vParam[0] <> "point" Then Return Me.StepsDone

        Try eBuild.P[0] = vParam[1]
        Try eBuild.P[1] = vParam[2]

        If definitive Then

            Return True
        End If
    Else If Me.StepsDone = 1 Then ' angulo del texto

        If vParam[0] <> "float" Then Return False

        eBuild.fParam[Me.ipaTextAngle] = vParam[1]

        If definitive Then Return True

    Else If Me.StepsDone = 2 Then   ' altura

        If vParam[0] <> "float" Then Return False

        eBuild.fParam[Me.ipaTextHeight] = vParam[1]

        If definitive Then Return True

    Else If Me.StepsDone = 3 Then    ' texto

        If vParam[0] <> "text" Then Return False

        eBuild.StringData[0] = vParam[1]

        If definitive Then Return True

    Else
        Return False
    End If

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    Dim i As Integer

    If OnlySelected Then

        For i = 0 To e.Psel.Max
            If e.Psel[i] Then

                e.P[i * 2] += dx
                e.P[i * 2 + 1] += dy

            Endif
        Next

    Else

        puntos.Translate(e.p, dx, dy)
    Endif

    'CreatePolygon(e)
    BuildPOI(e)

End

Public Sub Rotate(e As Entity, radians As Float)

    puntos.Rotate(e.P, radians)

    ' el parametro lo tengo que pasar a grados porque la rutina que dibuja el texto usa eso
    E.fParam[Me.ipaTextAngle] += radians * 180 / Pi

    'CreatePolygon(e)
    BuildPOI(e)

End

Public Sub Scale(e As Entity, sX As Float, sY As Float)

    Dim i As Integer

    E.fParam[Me.ipaTextHeight] *= sY
    For i = 0 To e.p.max Step 2

        e.P[i] = e.P[i] * sX
        e.P[i + 1] = e.P[i + 1] * sY

    Next

    'CreatePolygon(e)
    BuildPOI(e)

End

Public Sub Draw(oE As Entity)

    If Not oE.Visible Then Return

    ' Debug oE.stringdata[0]
    Dim s2 As String

    s2 = oE.stringdata[Me.sdaText]
    s2 = Replace(s2, "%%D", "°", gb.IgnoreCase)
    s2 = Replace(s2, "%%P", "±", gb.IgnoreCase)
    s2 = Replace(s2, "%%C", "∅", gb.IgnoreCase)

    ' Vamos a trbajar un poco en la alineacion, obtenemos el tamanio del texto:
    Dim rText As Float[]
    Dim dY As Float     ' correccion de Y debido a la alineacion
    Dim dX As Float     ' correccion de X debido a la alineacion

    rText = glPlus.TextExtends(s2, oE.fParam[Me.ipaTextHeight])

    If oe.P.Count = 2 Then          ' hay solo un punto, la alineacion es Baseline/Left

        dX = oE.p[0]    ' nada que corregir
        dY = oE.p[1]

    Else    ' tengo dos puntos

        ' veo la alineacion vertical
        If oe.fParam[Me.ipaVertJustif] <= 1 Then       'es Baseline/Bottom que es casi lo mismo

            dY = oE.p[1]
        Else If oe.fParam[Me.ipaVertJustif] = 2 Then   'Center
            ' TODO: verificar si mejor no debiera usar rText[1]
            dY = (oe.P[3] - oe.P[1]) / 2 - oe.fParam[Me.ipaTextHeight] / 2

        Else                                            'top
            dY = oe.P[3] - oe.fParam[Me.ipaTextHeight]
        End If

        ' veo la alineacion horizontal
        If oe.fParam[Me.ipaHorizJustif] = 0 Then       'es Left

            dX = oE.p[0]
        Else If oe.fParam[Me.ipaHorizJustif] = 1 Then   'Center
            dX = oE.p[0] + (oe.P[2] - oe.P[0]) / 2 - rText[0] / 2
        Else If oe.fParam[Me.ipaHorizJustif] = 2 Then   'Right
            dX = oE.p[0] + oe.P[2] - rText[0]
        Else If oe.fParam[Me.ipaHorizJustif] = 3 Then   'Aligned , pero no se que es
            dX = oE.p[0] + (oe.P[2] - oe.P[0]) / 2 - rText[0] / 2

        Else If oe.fParam[Me.ipaHorizJustif] = 4 Then   ' Middle, se calcula en base al segunto punto.
            dX = oE.p[0] + (oe.P[2] - oe.P[0]) - rText[0] / 2

        Else If oe.fParam[Me.ipaHorizJustif] = 5 Then   ' Fit, pero no tengo esta capability en glPlus.DrawTExt
            dx = oE.p[0]
        End If
    End If
    glPlus.DrawText(s2, dX, dY, oE.fParam[Me.ipaTextAngle], oE.fParam[Me.ipaTextHeight], gcd.GetGBColor(oE.Colour, oe.pLayer))

End

'' A fat version of the line
Public Sub DrawSelected(oE As Entity)

    GLplus.Polygon(oE.Polygon, config.ColorForSelected, oE.LineWidth, gcd.stiDashed)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

    If Not oE.Visible Then Return

    GLplus.Polygon(oE.Polygon, gcd.GetGBColor(oE.Colour, oe.pLayer), oE.LineWidth, gcd.stiDashed)

End

Public Function Draw2(oE As Entity)

    If Not oE.Visible Then Return

    Dim angulo As Float, hText As New PaintExtents, lText As String
    Dim FontScalePrev As Float

    ' angulo = oE.fParam[Me.ipaTextAngle] / 180 * Pi    ' ojo OPENGL--> GRADOS, GAMBAS-->RADIANESDXF
    '
    ' htext = paint.TextExtents(oe.StringData[Me.sdaText])
    ' paint.save
    ' paint.Translate(oE.p[0], oE.p[1])
    ' paint.Rotate(-angulo)
    ' paint.Scale(1, -1)
    ' Paint.Font.Size = oe.fParam[Me.ipaTextHeight] / gcd.PrintingScale * 2
    ' 'paint.DrawText(oe.StringData[Me.sdaText])
    paintPlus.DrawText(oe.StringData[Me.sdaText], oE.p[0], oE.p[1], -angulo, oe.fParam[Me.ipaTextHeight])

    paint.Stroke

    ' paint.Restore

End

'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity) As Integer

    ' si este valor no es provisto , estos POI son de la ultima entidad

    oe.PoiPoints.Clear
    oe.PoiType.Clear

    ' points
    oe.poiPoints.insert([oE.p[0], oE.p[1]])
    oe.poiType.Add(gcd.poiBasePoint)
    'oe.poiEntities.Add(arrIndex)

    ' line

    ' Polygon

    Dim tRect As New Float[], poli As New Float[]

    tRect = glPlus.TextExtends(oE.stringdata[Me.sdaText], oE.fParam[Me.ipaTextHeight])
    poli.Insert([0, 0, tRect[0], 0, tRect[0], tRect[1], 0, tRect[1]]) ' armo el poligono , que ya tiene la escala
    puntos.Rotate(Poli, oE.fParam[Me.ipaTextAngle] * Pi / 180)
    puntos.Translate(Poli, oE.P[0], oE.P[1])

    oe.Polygon.Clear
    oe.Polygon.Insert(poli)

End

Public Sub ExportDXFCol(e As Entity, ByRef stxExport As String[]) As Boolean

    ' stxExport.insert(["TEXT", dxf.codEntity])
    ' Los datos comunes a todas las entidades son guardados por la rutina que llama a esta
    stxExport.insert(["AcDbText", "100"])

    stxExport.insert([CStr(e.p[0]), dxf.codX0])                    ' insertion point
    stxExport.insert([CStr(e.p[1]), dxf.codY0])
    stxExport.insert(["0", dxf.codZ0])

    stxExport.insert([CStr(e.fParam[Me.ipaTextHeight]), "40"])      ' heigth
    stxExport.insert([e.stringdata[Me.sdaText], "1"])             ' Text
    stxExport.insert([CStr(e.fParam[Me.ipaTextAngle]), "50"])       ' rotation

    stxExport.insert(["1", "41"])
    stxExport.insert(["0", "51"])
    stxExport.insert([e.StringData[Me.sdaStyle], "7"])             ' text style
    stxExport.insert([e.fParam[Me.ipaGenerationFlags], "71"])      ' generation flags
    stxExport.insert([e.fParam[Me.ipaHorizJustif], "72"])          ' horiz justiff

    If e.P.Count = 4 Then   ' some DXF come with z, some with
        stxExport.insert([CStr(e.p[2]), dxf.codX1])                    ' second point
        stxExport.insert([CStr(e.p[3]), dxf.codY1])
        stxExport.insert(["0", dxf.codZ1])
    End If
    stxExport.insert(["0", "210"])                                 ' extrusion direction
    stxExport.insert(["0", "220"])
    stxExport.insert(["1", "230"])

    stxExport.insert(["AcDbText", "100"])

    stxExport.insert([e.fParam[Me.ipaVertJustif], "73"])

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer

    For i = 0 To sClaves.Max

        If sClaves[i] = "10" Then e.p[0] = (CFloat(sValues[i]))         ' X0
        If sClaves[i] = "20" Then e.P[1] = (CFloat(sValues[i]))         ' Y0

        ' el segundo punto es alternativo
        If sClaves[i] = "11" Then e.p.Add((CFloat(sValues[i])))         ' X1
        If sClaves[i] = "21" Then e.P.Add((CFloat(sValues[i])))         ' Y1

        If sClaves[i] = "40" Then e.fParam[Me.ipaTextHeight] = CFloat(sValues[i])         ' Altura
        If sClaves[i] = "1" Then e.StringData[Me.sdaText] &= sValues[i]                ' Texto
        ' Importante , el TEXT no tiene code 3 para mas texto

        If sClaves[i] = "50" Then e.fParam[Me.ipaTextAngle] = CFloat(sValues[i])      ' rotacion
        If sClaves[i] = "7" Then e.StringData[Me.sdaStyle] = sValues[i]                ' texy
        If sClaves[i] = "41" Then e.fParam[Me.ipaRelativeFactor] = CFloat(sValues[i])
        If sClaves[i] = "51" Then e.fParam[Me.ipaHorizAngle] = CFloat(sValues[i])
        If sClaves[i] = "71" Then e.fParam[Me.ipaGenerationFlags] = CInt(sValues[i])
        If sClaves[i] = "72" Then e.fParam[Me.ipaHorizJustif] = CFloat(sValues[i])
        If sClaves[i] = "73" Then e.fParam[Me.ipaVertJustif] = CFloat(sValues[i])
    Next

    If e.StringData[Me.sdaStyle] = "" Then e.StringData[Me.sdaStyle] = "STANDARD"

    Return True

    ' catch

    Return False

End

' Group 72 and 73 integer codes
'
' Group 73/72         0     1       2       3       4     5
' 3 (top)          TLeft TCenter TRight
' 2 (middle)       MLeft MCenter MRight
' 1 (bottom)       BLeft BCenter BRight
' 0 (baseline)     Left  Center  Right  Aligned  Middle Fit

'' Return if that position is over the entity within the tolerance
Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean

    Return False

End
