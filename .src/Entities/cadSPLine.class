' Gambas class file

' Represents a poli line
' Element maintained by Terco

' Usando partes de la informacion de
' http://devmag.org.za/2011/04/05/bzier-curves-a-tutorial/

Create Static
Inherits EntityBase
Public Const Gender As String = "SPLINE"
Public Const PointsToDraw As Integer = 0             ' minimal point requered for drawing something usefull
Public Const CmdLineHelper As String = "SPLine"
Public Const ParamType As String = "P+"                             ' that is Point, Point, Float could be Color Text, etc
Public Const ParamHelper As String = ("Next Point")      ' a little text that is shown at the prompt waiting for user input during build
Public Const ParamDefault As String = "Close/Undo"
Public Const ContextMenu As String = ("Close polyline;_CLOSE;;;Undo last point;_UNDO;;;End in last point;_END;;") ' el menu para el boton derecho, los comandos en mayusculas NO se traducen

' otras const
Public Const TypeControls As Integer = 0
Public Const TypeTangent As Integer = 1
Public drawingPoints As New Float[]

Public numDrawingPoints As Integer = 100

' DXF Read/Export

Public Const DXF_Export As Boolean = True

' fParam helpers
Public Const TotalParams As Integer = 10
Public Const ipaDegree As Integer = 0
Public Const ipaTotalKnots As Integer = 1
Public Const ipaTotalControlPoints As Integer = 2
Public Const ipaTotalFitPoints As Integer = 3
Public Const ipaKnotTolerance As Integer = 4
Public Const ipaControlTolerance As Integer = 5
Public Const ipaFitTolerance As Integer = 6
Public Const ipaFlag As Integer = 7
Public Const ipaTang1 As Integer = 8
Public Const ipaTang2 As Integer = 9


Public LOD As Integer = 100

Public g_points As New Float[]
Public Knots As Float[]
Public sp As SPline

Public Function NewEntity(Optional fPoints As Float[], bNewHandle As Boolean = False) As Entity

    Dim e As Entity

    e = Super.NewEntity(fPoints, bNewHandle)

    e.pBlock = New SPline

    Return e


End

Public Sub ClonEntity(eOrigen As Entity) As Entity

    Dim e As Entity, s, bBase As SPline


    e = Super.ClonEntity(eOrigen)
    bBase = eOrigen.pBlock
    s = New SPline

    s.ControlPoints.Insert(bBase.ControlPoints.copy())
    s.ControlTolerance = bBase.ControlTolerance
    s.Degree = bBase.Degree
    s.FitPoints.Insert(bBase.FitPoints.copy())
    s.FitTolerance = bBase.FitTolerance
    s.KnotTolerance = bBase.KnotTolerance
    s.KnotValues.Insert(bBase.KnotValues.copy())
    s.Periodic = bBase.Periodic
    s.Rational = bBase.Rational
    s.TangentFinal.Insert(bBase.TangentFinal.copy())
    s.TangentInitial.Insert(bBase.TangentInitial.copy())
    s.Weigths.Insert(bBase.Weigths.copy())
    e.pBlock = s
    Return e


End


Public Function NewParameter(eBuild As Entity, vParam As Variant[], Optional Definitive As Boolean = False) As Boolean


    Dim i As Integer
    Dim sp As SPline

    sp = ebuild.pBlock


    If vParam[0] = "point" Then

        sp.ControlPoints[sp.ControlPoints.Max - 1] = vParam[1]
        sp.ControlPoints[sp.ControlPoints.Max] = vParam[2]
        GoSub DoKnots
        If definitive Then

            sp.ControlPoints.Insert(sp.ControlPoints.Copy(sp.ControlPoints.Max - 1, 2))
            GoSub DoKnots
            Return True
        End If
    Else If vParam[1] = "CLOSE" Then
        If sp.ControlPoints.Count > 4 Then sp.ControlPoints.Remove(sp.ControlPoints.Max - 1, 2)
        sp.ControlPoints[sp.ControlPoints.Max - 1] = sp.ControlPoints[0]
        sp.ControlPoints[sp.ControlPoints.Max] = sp.ControlPoints[1]
        GoSub DoKnots
        Inc gcd.StepsDone
        Return True

    Else If vParam[1] = "UNDO" Then
        If sp.ControlPoints.Count > 4 Then
            sp.ControlPoints.Remove(sp.ControlPoints.Max - 1, 2)
            GoSub DoKnots
        End If

        Return True
    Else If vParam[1] = "END" Then
        If sp.ControlPoints.Count > 4 Then sp.ControlPoints.Remove(sp.ControlPoints.Max - 1, 2)
        GoSub DoKnots
        Inc gcd.StepsDone

        Return True

    Endif

DoKnots:

    sp.kNotValues.Clear

    sp.kNotValues.Add(0)
    sp.kNotValues.Add(0)
    sp.kNotValues.Add(0)

    If sp.ControlPoints.Count / 2 > 3 Then
        For i = 1 To sp.ControlPoints.count / 2 - 3
            sp.kNotValues.Add(i / ((sp.ControlPoints.count / 2 - 2)))
        Next
    End If
    sp.kNotValues.Add(1)
    sp.kNotValues.Add(1)
    sp.kNotValues.Add(1)

    Return

End

Public Sub Translate(e As Entity, dX As Float, dY As Float, Optional OnlySelected As Boolean = False)

    Dim i As Integer

    sp = e.pBlock

    puntos.Translate(sp.ControlPoints, dx, dy)
    puntos.Translate(sp.FitPoints, dx, dy)
    puntos.Translate(sp.TangentFinal, dx, dy)
    puntos.Translate(sp.TangentInitial, dx, dy)

    e.PolyLine.Clear
    Me.makepolyline(e)



End

Public Sub Rotate(e As Entity, radians As Float)

    sp = e.pBlock

    puntos.Rotate(sp.ControlPoints, radians)
    puntos.Rotate(sp.FitPoints, radians)
    puntos.Rotate(sp.TangentFinal, radians)
    puntos.Rotate(sp.TangentInitial, radians)


    e.PolyLine.Clear
    Me.makepolyline(e)


End

Public Sub Scale(e As Entity, dX As Float, dY As Float)

    sp = e.pBlock

    puntos.Scale(sp.ControlPoints, dx, dy)
    puntos.Scale(sp.FitPoints, dx, dy)
    puntos.Scale(sp.TangentFinal, dx, dy)
    puntos.Scale(sp.TangentInitial, dx, dy)


    e.PolyLine.Clear
    Me.makepolyline(e)


End

'' A fat version of the entity
Public Sub DrawSelected(oE As Entity)


    glx.PolyLines(oE.PolyLine, config.ColorForSelected, gcd.GetLineWt(oE.LineWIdth, oe.pLayer), oE.LineType.TrameLength)

End

'' A fat version of the line
Public Sub DrawRemark(oE As Entity)

    If Not oE.Visible Then Return



    glx.PolyLines(oE.PolyLine, gcd.GetGBColor(oE.Colour, oe.pLayer), gcd.GetLineWt(oE.LineWIdth, oe.pLayer) + 1, oE.LineType.TrameLength)

End

Public Sub Draw2(oE As Entity)

    paintPlus.Lines(oe.PolyLine)

End
'' Creo los puntos de interes
'' Build point of interest

Public Function BuildPOI(oE As Entity) As Integer

    cadLWPolyline.BuildPOI(oe)

End

Public Sub ExportDXFCol(e As Entity, ByRef stxExport As String[]) As Boolean

    Dim i As Integer

    ' stxExport.insert(["SPLINE", dxf.codEntity])
    ' Los datos comunes a todas las entidades son guardados por la rutina que llama a esta
    stxExport.insert(["AcDbSpline", "100"])
    stxExport.insert([CStr(e.fParam[Me.ipaFlag]), "70"])
    ' 70' SPLINE flag(bit coded):
    ' 1 = Closed spline
    ' 2 = Periodic spline
    ' 4 = Rational spline
    ' 8 = Planar
    ' 16 = Linear(planar bit Is Also set)
    stxExport.insert([CStr(e.fParam[Me.ipaDegree]), "71"])                 ' 2 = quadrtic 3 = cubic
    stxExport.insert([CStr(e.fParam[Me.ipaTotalKnots]), "72"])
    stxExport.insert([CStr(e.fParam[Me.ipaTotalControlPoints]), "73"])
    stxExport.insert([CStr(e.fParam[Me.ipaTotalFitPoints]), "74"])
    stxExport.insert([CStr(e.fParam[Me.ipaKnotTolerance]), "42"])          ' 0.0000001
    stxExport.insert([CStr(e.fParam[Me.ipaControlTolerance]), "43"])       ' 0.0000001
    stxExport.insert([CStr(e.fParam[Me.ipaFitTolerance]), "44"])           ' 0.0000000001
    For i = 1 To e.fParam[Me.ipaTotalKnots]
        stxExport.insert([CStr(e.fParam[Me.TotalParams + i - 1]), "40"])
    Next
    For i = 0 To e.p.Max Step 2
        stxExport.insert([CStr(e.p[i]), dxf.codX0])
        stxExport.insert([CStr(e.p[i + 1]), dxf.codY0])
        stxExport.insert(["0", dxf.codZ0])
    Next

End

Public Function ImportDXF(e As Entity, sClaves As String[], sValues As String[]) As Boolean

    Dim i As Integer

    Dim Pbase, PFit As New Float[]
    Dim Ptang1 As New Float[]
    Dim Ptang2 As New Float[]

    sp = New SPline
    e.pBlock = sp


    For i = 0 To sClaves.Max

        If sClaves[i] = "70" Then sp.Periodic = (CInt(sValues[i]) <> 0)
        If sClaves[i] = "71" Then sp.Degree = CInt(sValues[i])

        'If sClaves[i] = "72" Then e.fParam[Me.ipaTotalKnots] = CInt(sValues[i])            'innecesario
        'If sClaves[i] = "73" Then e.fParam[Me.ipaTotalControlPoints] = CInt(sValues[i])            'innecesario
        'If sClaves[i] = "74" Then e.fParam[Me.ipaTotalFitPoints] = CInt(sValues[i])            'innecesario
        If sClaves[i] = "42" Then sp.KnotTolerance = CFloat(sValues[i])
        If sClaves[i] = "43" Then sp.Controltolerance = CFloat(sValues[i])
        If sClaves[i] = "44" Then sp.FitTolerance = CFloat(sValues[i])

        ' Los Knots estan en el indice me.TotalParams en adelante
        If sClaves[i] = "40" Then sp.KnotValues.Add(CFloat(sValues[i]))

        If sClaves[i] = "41" Then sp.Weigths.Add(CFloat(sValues[i]))

        ' Control points
        If sClaves[i] = "10" Then SP.ControlPoints.Add(CFloat(sValues[i]))
        If sClaves[i] = "20" Then SP.ControlPoints.Add(CFloat(sValues[i]))

        ' Estos Fitting points no se usan en la construccion, tengo que verificar si los necesitan otros programas para guardarlos y reescribirlos
        If sClaves[i] = "11" Then sp.FitPoints.Add(CFloat(sValues[i]))
        If sClaves[i] = "21" Then sp.FitPoints.Add(CFloat(sValues[i]))

        ' tangentes, no se usan DXF
        If sClaves[i] = "12" Then sp.TangentInitial.Add(CFloat(sValues[i]))
        If sClaves[i] = "22" Then sp.TangentInitial.Add(CFloat(sValues[i]))

        If sClaves[i] = "13" Then sp.TangentFinal.Add(CFloat(sValues[i]))
        If sClaves[i] = "23" Then sp.TangentFinal.Add(CFloat(sValues[i]))

    Next

    e.P.Clear
    e.P.Add(sp.ControlPoints[0])
    e.P.Add(sp.ControlPoints[1])
    e.P.Add(sp.ControlPoints[sp.ControlPoints.Max - 1])
    e.P.Add(sp.ControlPoints[sp.ControlPoints.Max])

    '
    Return True

    ' catch

    Return False

End

Private Function CoxDeBoor(u As Float, i As Float, k As Float) As Float

    Dim Eq1, Eq2 As Float
    Dim Den1, Den2 As Float

    If (k = 1) Then

        If ((Knots[i] <= u) And (u <= Knots[i + 1])) Then
            Return 1.0
        Else
            Return 0.0
        End If
    End If
    Den1 = Knots[i + k - 1] - Knots[i]
    Den2 = Knots[i + k] - Knots[i + 1]

    If (Den1 > 0) Then
        Eq1 = ((u - Knots[i]) / Den1) * CoxDeBoor(u, i, k - 1)
    End If
    If (Den2 > 0) Then
        Eq2 = (Knots[i + k] - u) / Den2 * CoxDeBoor(u, i + 1, k - 1)
    End If
    Return Eq1 + Eq2

End

' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -GetOutpoint()
'
' Public Sub GetOutpoint(t As Float, OutPoint As Float[])
'
'     ' sum the effect Of all CV 's on the curve at this point to
'     ' get the evaluated curve point
'     Dim i As Integer
'     Dim fVal As Float
'
'     For i = 0 To g_num_cvs - 1
'
'         ' calculate the effect Of this point On the curve
'
'         fVal = CoxDeBoor(t, i, g_order)
'
'         If (fVal > 0.001) Then
'
'             ' sum effect Of CV On this part Of the curve
'             OutPoint[0] += fVal * g_Points[i * 2 + 0]
'             OutPoint[1] += fVal * g_Points[i * 2 + 1]
'             OutPoint[2] += 0 'fVal * g_Points[i * 3 + 2] ' Para 3D el array g_points deberia ser 3D
'         End If
'     Next
'
' End

Public Sub makepolyline(oe As Entity, Optional density As Integer = 36)

    Dim OutPoint As New Float[]
    Dim i As Integer
    Dim t As Float

    sp = oe.pBlock

    If sp.ControlPoints.Count = 2 Then Return

    If sp.ControlPoints.Count = 4 Then
        cadLine.Draw(oe)
        Return
    End If
    oe.PolyLine.Clear

    For i = 0 To LOD - 1    ' LOD es el nummero de tramos

        't = Knots[Knots.Max] * i / (LOD - 1)
        t = i / (LOD - 1)
        'If (i = LOD - 1) Then t -= 0.001

        OutPoint = interpolate2(t, sp.Degree, sp.ControlPoints, sp.KnotValues)

        oe.PolyLine.Add(Outpoint[0])
        oe.PolyLine.Add(Outpoint[1])

    Next

End



Public Sub Draw(oE As Entity)

    ' This routine is based on the work of:
    ' Rob Bateman
    ' Date 9 - feb - 2005
    ' This Is A very simple example Of a bezier curve
    ' Thank you! - Martin


    Me.makepolyline(oe)

    glx.PolyLines(oe.PolyLine, gcd.GetGBColor(oE.Colour, oe.pLayer), gcd.GetLineWt(oE.LineWIdth, oe.pLayer), oE.LineType.TrameLength)



End


'Fast
Public Function interpolate2(t As Float, degree As Integer, points As Float[], Optional knots As Float[], weights As Float[]) As Float[]

    Dim i, j, s, l As Integer ' function - scoped iteration variables
    Dim d As Integer = 2 ' 2d o 3d o mas dimensiones
    Dim Resultado As New Float[]
    Dim n As Integer = points.Count / d ' numero de puntos

    If (degree < 1) Then Stop ' Error( 'degree must be at least 1 (linear)')
    If (degree > (n - 1)) Then Stop ' Error( 'degree must be less than or equal to point count - 1')

    ' Genero los pesos de cada punto para el caso que no sean provistos
    If Not weights Then
        ' build weight vector Of length[n]
        weights = New Float[]
        weights.Add(1)
        weights.Add(1)
        For i = 1 To n - 3
            weights.Add(1)
        Next
        weights.Add(1)
        weights.Add(1)
    Endif

    ' genero los nudos
    If Not knots Then knots = New Float[]
    If knots.Count = 0 Then
        ' build knot vector Of length[n + degree + 1]

        For i = 0 To n + degree
            knots.Add(i)
        Next
    Else ' lo verifico
        If (knots.Count <> n + degree + 1) Then Stop  'Error( 'bad knot vector length')
    End If

    Dim domain As New Float[]
    domain.Insert([degree, knots.count - 1 - degree])

    ' remap t To the domain where the spline Is Defined
    Dim low As Float = knots[domain[0]]
    Dim high As Float = knots[domain[1]]
    t = t * (high - low) + low

    If (t < low) Or (t > high) Then Debug "Stop Error(out of bounds)"

    ' find s(the spline segment) For the[t]value provided
    For s = domain[0] To domain[1] - 1
        If (t >= knots[s]) And (t <= knots[s + 1]) Then
            Break
        Endif
    Next
    If s > domain[1] - 1 Then s = domain[1] - 1

    'Debug "S=", s

    ' convert points To homogeneous coordinates (gana una dimension mas)
    Dim v As New Float[][]   ' v=[x1,y1,w1,x2,y2,w2.....] w=weigth
    For i = 0 To n - 1
        v.Add([])
        For j = 0 To d - 1
            v[i].Add(points[i * d + j] * weights[i])
        Next
        ' esto no se
        v[i].Add(weights[i])
    Next

    ' l(level)goes From 1 To the curve degree + 1
    Dim alpha As Float
    For l = 1 To degree + 1
        ' build level l Of the pyramid
        For i = s To s - degree + l Step -1
            If (knots[i + degree + 1 - l] - knots[i]) <> 0 Then
                alpha = (t - knots[i]) / (knots[i + degree + 1 - l] - knots[i])
            Else
                alpha = 1 'or 0
            End If
            ' interpolo cada dimension
            For j = 0 To d
                v[i][j] = (1 - alpha) * v[(i - 1)][j] + alpha * v[i][j]
            Next
        Next
    Next

    ' convert back To cartesian And Return
    For i = 0 To d - 1
        Resultado.Add(v[s][i] / v[s][d])
    Next

    Return Resultado

End

'' Return if that position is over the entity within the tolerance
Public Function OverMe(e As Entity, Xr As Float, Yr As Float, tolerance As Float) As Boolean

    Return cadPolyline.OverMe(e, xr, yr, tolerance)

End
